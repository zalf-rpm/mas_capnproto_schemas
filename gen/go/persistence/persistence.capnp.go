// Code generated by capnpc-go. DO NOT EDIT.

package persistence

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	common "github.com/zalf-rpm/mas_capnproto_schemas/gen/go/common"
	strconv "strconv"
)

type VatId capnp.Struct

// VatId_TypeID is the unique identifier for the type VatId.
const VatId_TypeID = 0xe10a5d74d58bd18d

func NewVatId(s *capnp.Segment) (VatId, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return VatId(st), err
}

func NewRootVatId(s *capnp.Segment) (VatId, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return VatId(st), err
}

func ReadRootVatId(msg *capnp.Message) (VatId, error) {
	root, err := msg.Root()
	return VatId(root.Struct()), err
}

func (s VatId) String() string {
	str, _ := text.Marshal(0xe10a5d74d58bd18d, capnp.Struct(s))
	return str
}

func (s VatId) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VatId) DecodeFromPtr(p capnp.Ptr) VatId {
	return VatId(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VatId) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VatId) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VatId) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VatId) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VatId) PublicKey0() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s VatId) SetPublicKey0(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s VatId) PublicKey1() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s VatId) SetPublicKey1(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s VatId) PublicKey2() uint64 {
	return capnp.Struct(s).Uint64(16)
}

func (s VatId) SetPublicKey2(v uint64) {
	capnp.Struct(s).SetUint64(16, v)
}

func (s VatId) PublicKey3() uint64 {
	return capnp.Struct(s).Uint64(24)
}

func (s VatId) SetPublicKey3(v uint64) {
	capnp.Struct(s).SetUint64(24, v)
}

// VatId_List is a list of VatId.
type VatId_List = capnp.StructList[VatId]

// NewVatId creates a new list of VatId.
func NewVatId_List(s *capnp.Segment, sz int32) (VatId_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0}, sz)
	return capnp.StructList[VatId](l), err
}

// VatId_Future is a wrapper for a VatId promised by a client call.
type VatId_Future struct{ *capnp.Future }

func (f VatId_Future) Struct() (VatId, error) {
	p, err := f.Future.Ptr()
	return VatId(p.Struct()), err
}

type Address capnp.Struct
type Address_ip6 Address
type Address_Which uint16

const (
	Address_Which_ip6  Address_Which = 0
	Address_Which_host Address_Which = 1
)

func (w Address_Which) String() string {
	const s = "ip6host"
	switch w {
	case Address_Which_ip6:
		return s[0:3]
	case Address_Which_host:
		return s[3:7]

	}
	return "Address_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Address_TypeID is the unique identifier for the type Address.
const Address_TypeID = 0xfb47810671a05b0d

func NewAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Address(st), err
}

func NewRootAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Address(st), err
}

func ReadRootAddress(msg *capnp.Message) (Address, error) {
	root, err := msg.Root()
	return Address(root.Struct()), err
}

func (s Address) String() string {
	str, _ := text.Marshal(0xfb47810671a05b0d, capnp.Struct(s))
	return str
}

func (s Address) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Address) DecodeFromPtr(p capnp.Ptr) Address {
	return Address(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Address) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Address) Which() Address_Which {
	return Address_Which(capnp.Struct(s).Uint16(18))
}
func (s Address) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Address) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Address) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Address) Ip6() Address_ip6 { return Address_ip6(s) }

func (s Address) SetIp6() {
	capnp.Struct(s).SetUint16(18, 0)
}

func (s Address_ip6) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Address_ip6) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Address_ip6) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Address_ip6) Lower64() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Address_ip6) SetLower64(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Address_ip6) Upper64() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s Address_ip6) SetUpper64(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s Address) Host() (string, error) {
	if capnp.Struct(s).Uint16(18) != 1 {
		panic("Which() != host")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Address) HasHost() bool {
	if capnp.Struct(s).Uint16(18) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Address) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Address) SetHost(v string) error {
	capnp.Struct(s).SetUint16(18, 1)
	return capnp.Struct(s).SetText(0, v)
}

func (s Address) Port() uint16 {
	return capnp.Struct(s).Uint16(16)
}

func (s Address) SetPort(v uint16) {
	capnp.Struct(s).SetUint16(16, v)
}

// Address_List is a list of Address.
type Address_List = capnp.StructList[Address]

// NewAddress creates a new list of Address.
func NewAddress_List(s *capnp.Segment, sz int32) (Address_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[Address](l), err
}

// Address_Future is a wrapper for a Address promised by a client call.
type Address_Future struct{ *capnp.Future }

func (f Address_Future) Struct() (Address, error) {
	p, err := f.Future.Ptr()
	return Address(p.Struct()), err
}
func (p Address_Future) Ip6() Address_ip6_Future { return Address_ip6_Future{p.Future} }

// Address_ip6_Future is a wrapper for a Address_ip6 promised by a client call.
type Address_ip6_Future struct{ *capnp.Future }

func (f Address_ip6_Future) Struct() (Address_ip6, error) {
	p, err := f.Future.Ptr()
	return Address_ip6(p.Struct()), err
}

type VatPath capnp.Struct

// VatPath_TypeID is the unique identifier for the type VatPath.
const VatPath_TypeID = 0xd9eccdf2dbc48087

func NewVatPath(s *capnp.Segment) (VatPath, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return VatPath(st), err
}

func NewRootVatPath(s *capnp.Segment) (VatPath, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return VatPath(st), err
}

func ReadRootVatPath(msg *capnp.Message) (VatPath, error) {
	root, err := msg.Root()
	return VatPath(root.Struct()), err
}

func (s VatPath) String() string {
	str, _ := text.Marshal(0xd9eccdf2dbc48087, capnp.Struct(s))
	return str
}

func (s VatPath) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VatPath) DecodeFromPtr(p capnp.Ptr) VatPath {
	return VatPath(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VatPath) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VatPath) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VatPath) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VatPath) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VatPath) Id() (VatId, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VatId(p.Struct()), err
}

func (s VatPath) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s VatPath) SetId(v VatId) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewId sets the id field to a newly
// allocated VatId struct, preferring placement in s's segment.
func (s VatPath) NewId() (VatId, error) {
	ss, err := NewVatId(capnp.Struct(s).Segment())
	if err != nil {
		return VatId{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VatPath) Address() (Address, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Address(p.Struct()), err
}

func (s VatPath) HasAddress() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s VatPath) SetAddress(v Address) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewAddress sets the address field to a newly
// allocated Address struct, preferring placement in s's segment.
func (s VatPath) NewAddress() (Address, error) {
	ss, err := NewAddress(capnp.Struct(s).Segment())
	if err != nil {
		return Address{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// VatPath_List is a list of VatPath.
type VatPath_List = capnp.StructList[VatPath]

// NewVatPath creates a new list of VatPath.
func NewVatPath_List(s *capnp.Segment, sz int32) (VatPath_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[VatPath](l), err
}

// VatPath_Future is a wrapper for a VatPath promised by a client call.
type VatPath_Future struct{ *capnp.Future }

func (f VatPath_Future) Struct() (VatPath, error) {
	p, err := f.Future.Ptr()
	return VatPath(p.Struct()), err
}
func (p VatPath_Future) Id() VatId_Future {
	return VatId_Future{Future: p.Future.Field(0, nil)}
}
func (p VatPath_Future) Address() Address_Future {
	return Address_Future{Future: p.Future.Field(1, nil)}
}

type SturdyRef capnp.Struct

// SturdyRef_TypeID is the unique identifier for the type SturdyRef.
const SturdyRef_TypeID = 0x886d68271d83de4d

func NewSturdyRef(s *capnp.Segment) (SturdyRef, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SturdyRef(st), err
}

func NewRootSturdyRef(s *capnp.Segment) (SturdyRef, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SturdyRef(st), err
}

func ReadRootSturdyRef(msg *capnp.Message) (SturdyRef, error) {
	root, err := msg.Root()
	return SturdyRef(root.Struct()), err
}

func (s SturdyRef) String() string {
	str, _ := text.Marshal(0x886d68271d83de4d, capnp.Struct(s))
	return str
}

func (s SturdyRef) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SturdyRef) DecodeFromPtr(p capnp.Ptr) SturdyRef {
	return SturdyRef(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SturdyRef) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SturdyRef) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SturdyRef) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SturdyRef) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SturdyRef) Vat() (VatPath, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VatPath(p.Struct()), err
}

func (s SturdyRef) HasVat() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SturdyRef) SetVat(v VatPath) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewVat sets the vat field to a newly
// allocated VatPath struct, preferring placement in s's segment.
func (s SturdyRef) NewVat() (VatPath, error) {
	ss, err := NewVatPath(capnp.Struct(s).Segment())
	if err != nil {
		return VatPath{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s SturdyRef) LocalRef() (SturdyRef_Token, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return SturdyRef_Token(p.Struct()), err
}

func (s SturdyRef) HasLocalRef() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s SturdyRef) SetLocalRef(v SturdyRef_Token) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewLocalRef sets the localRef field to a newly
// allocated SturdyRef_Token struct, preferring placement in s's segment.
func (s SturdyRef) NewLocalRef() (SturdyRef_Token, error) {
	ss, err := NewSturdyRef_Token(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef_Token{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// SturdyRef_List is a list of SturdyRef.
type SturdyRef_List = capnp.StructList[SturdyRef]

// NewSturdyRef creates a new list of SturdyRef.
func NewSturdyRef_List(s *capnp.Segment, sz int32) (SturdyRef_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[SturdyRef](l), err
}

// SturdyRef_Future is a wrapper for a SturdyRef promised by a client call.
type SturdyRef_Future struct{ *capnp.Future }

func (f SturdyRef_Future) Struct() (SturdyRef, error) {
	p, err := f.Future.Ptr()
	return SturdyRef(p.Struct()), err
}
func (p SturdyRef_Future) Vat() VatPath_Future {
	return VatPath_Future{Future: p.Future.Field(0, nil)}
}
func (p SturdyRef_Future) LocalRef() SturdyRef_Token_Future {
	return SturdyRef_Token_Future{Future: p.Future.Field(1, nil)}
}

type SturdyRef_Owner capnp.Struct

// SturdyRef_Owner_TypeID is the unique identifier for the type SturdyRef_Owner.
const SturdyRef_Owner_TypeID = 0xfdd799ed60c87723

func NewSturdyRef_Owner(s *capnp.Segment) (SturdyRef_Owner, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SturdyRef_Owner(st), err
}

func NewRootSturdyRef_Owner(s *capnp.Segment) (SturdyRef_Owner, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SturdyRef_Owner(st), err
}

func ReadRootSturdyRef_Owner(msg *capnp.Message) (SturdyRef_Owner, error) {
	root, err := msg.Root()
	return SturdyRef_Owner(root.Struct()), err
}

func (s SturdyRef_Owner) String() string {
	str, _ := text.Marshal(0xfdd799ed60c87723, capnp.Struct(s))
	return str
}

func (s SturdyRef_Owner) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SturdyRef_Owner) DecodeFromPtr(p capnp.Ptr) SturdyRef_Owner {
	return SturdyRef_Owner(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SturdyRef_Owner) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SturdyRef_Owner) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SturdyRef_Owner) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SturdyRef_Owner) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SturdyRef_Owner) Guid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s SturdyRef_Owner) HasGuid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SturdyRef_Owner) GuidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s SturdyRef_Owner) SetGuid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// SturdyRef_Owner_List is a list of SturdyRef_Owner.
type SturdyRef_Owner_List = capnp.StructList[SturdyRef_Owner]

// NewSturdyRef_Owner creates a new list of SturdyRef_Owner.
func NewSturdyRef_Owner_List(s *capnp.Segment, sz int32) (SturdyRef_Owner_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[SturdyRef_Owner](l), err
}

// SturdyRef_Owner_Future is a wrapper for a SturdyRef_Owner promised by a client call.
type SturdyRef_Owner_Future struct{ *capnp.Future }

func (f SturdyRef_Owner_Future) Struct() (SturdyRef_Owner, error) {
	p, err := f.Future.Ptr()
	return SturdyRef_Owner(p.Struct()), err
}

type SturdyRef_Token capnp.Struct
type SturdyRef_Token_Which uint16

const (
	SturdyRef_Token_Which_text SturdyRef_Token_Which = 0
	SturdyRef_Token_Which_data SturdyRef_Token_Which = 1
)

func (w SturdyRef_Token_Which) String() string {
	const s = "textdata"
	switch w {
	case SturdyRef_Token_Which_text:
		return s[0:4]
	case SturdyRef_Token_Which_data:
		return s[4:8]

	}
	return "SturdyRef_Token_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// SturdyRef_Token_TypeID is the unique identifier for the type SturdyRef_Token.
const SturdyRef_Token_TypeID = 0xfa412bb47f11b488

func NewSturdyRef_Token(s *capnp.Segment) (SturdyRef_Token, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return SturdyRef_Token(st), err
}

func NewRootSturdyRef_Token(s *capnp.Segment) (SturdyRef_Token, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return SturdyRef_Token(st), err
}

func ReadRootSturdyRef_Token(msg *capnp.Message) (SturdyRef_Token, error) {
	root, err := msg.Root()
	return SturdyRef_Token(root.Struct()), err
}

func (s SturdyRef_Token) String() string {
	str, _ := text.Marshal(0xfa412bb47f11b488, capnp.Struct(s))
	return str
}

func (s SturdyRef_Token) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SturdyRef_Token) DecodeFromPtr(p capnp.Ptr) SturdyRef_Token {
	return SturdyRef_Token(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SturdyRef_Token) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s SturdyRef_Token) Which() SturdyRef_Token_Which {
	return SturdyRef_Token_Which(capnp.Struct(s).Uint16(0))
}
func (s SturdyRef_Token) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SturdyRef_Token) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SturdyRef_Token) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SturdyRef_Token) Text() (string, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != text")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s SturdyRef_Token) HasText() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s SturdyRef_Token) TextBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s SturdyRef_Token) SetText(v string) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetText(0, v)
}

func (s SturdyRef_Token) Data() ([]byte, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != data")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s SturdyRef_Token) HasData() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s SturdyRef_Token) SetData(v []byte) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetData(0, v)
}

// SturdyRef_Token_List is a list of SturdyRef_Token.
type SturdyRef_Token_List = capnp.StructList[SturdyRef_Token]

// NewSturdyRef_Token creates a new list of SturdyRef_Token.
func NewSturdyRef_Token_List(s *capnp.Segment, sz int32) (SturdyRef_Token_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[SturdyRef_Token](l), err
}

// SturdyRef_Token_Future is a wrapper for a SturdyRef_Token promised by a client call.
type SturdyRef_Token_Future struct{ *capnp.Future }

func (f SturdyRef_Token_Future) Struct() (SturdyRef_Token, error) {
	p, err := f.Future.Ptr()
	return SturdyRef_Token(p.Struct()), err
}

type Heartbeat capnp.Client

// Heartbeat_TypeID is the unique identifier for the type Heartbeat.
const Heartbeat_TypeID = 0x9fb3bdfad147ca3a

func (c Heartbeat) Beat(ctx context.Context, params func(Heartbeat_beat_Params) error) (Heartbeat_beat_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9fb3bdfad147ca3a,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Heartbeat",
			MethodName:    "beat",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Heartbeat_beat_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Heartbeat_beat_Results_Future{Future: ans.Future()}, release

}

func (c Heartbeat) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Heartbeat) String() string {
	return "Heartbeat(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Heartbeat) AddRef() Heartbeat {
	return Heartbeat(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Heartbeat) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Heartbeat) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Heartbeat) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Heartbeat) DecodeFromPtr(p capnp.Ptr) Heartbeat {
	return Heartbeat(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Heartbeat) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Heartbeat) IsSame(other Heartbeat) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Heartbeat) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Heartbeat) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Heartbeat_Server is a Heartbeat with a local implementation.
type Heartbeat_Server interface {
	Beat(context.Context, Heartbeat_beat) error
}

// Heartbeat_NewServer creates a new Server from an implementation of Heartbeat_Server.
func Heartbeat_NewServer(s Heartbeat_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Heartbeat_Methods(nil, s), s, c)
}

// Heartbeat_ServerToClient creates a new Client from an implementation of Heartbeat_Server.
// The caller is responsible for calling Release on the returned Client.
func Heartbeat_ServerToClient(s Heartbeat_Server) Heartbeat {
	return Heartbeat(capnp.NewClient(Heartbeat_NewServer(s)))
}

// Heartbeat_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Heartbeat_Methods(methods []server.Method, s Heartbeat_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9fb3bdfad147ca3a,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Heartbeat",
			MethodName:    "beat",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Beat(ctx, Heartbeat_beat{call})
		},
	})

	return methods
}

// Heartbeat_beat holds the state for a server call to Heartbeat.beat.
// See server.Call for documentation.
type Heartbeat_beat struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Heartbeat_beat) Args() Heartbeat_beat_Params {
	return Heartbeat_beat_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Heartbeat_beat) AllocResults() (Heartbeat_beat_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Heartbeat_beat_Results(r), err
}

// Heartbeat_List is a list of Heartbeat.
type Heartbeat_List = capnp.CapList[Heartbeat]

// NewHeartbeat_List creates a new list of Heartbeat.
func NewHeartbeat_List(s *capnp.Segment, sz int32) (Heartbeat_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Heartbeat](l), err
}

type Heartbeat_beat_Params capnp.Struct

// Heartbeat_beat_Params_TypeID is the unique identifier for the type Heartbeat_beat_Params.
const Heartbeat_beat_Params_TypeID = 0x8ab68adabfa134ca

func NewHeartbeat_beat_Params(s *capnp.Segment) (Heartbeat_beat_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Heartbeat_beat_Params(st), err
}

func NewRootHeartbeat_beat_Params(s *capnp.Segment) (Heartbeat_beat_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Heartbeat_beat_Params(st), err
}

func ReadRootHeartbeat_beat_Params(msg *capnp.Message) (Heartbeat_beat_Params, error) {
	root, err := msg.Root()
	return Heartbeat_beat_Params(root.Struct()), err
}

func (s Heartbeat_beat_Params) String() string {
	str, _ := text.Marshal(0x8ab68adabfa134ca, capnp.Struct(s))
	return str
}

func (s Heartbeat_beat_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Heartbeat_beat_Params) DecodeFromPtr(p capnp.Ptr) Heartbeat_beat_Params {
	return Heartbeat_beat_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Heartbeat_beat_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Heartbeat_beat_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Heartbeat_beat_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Heartbeat_beat_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Heartbeat_beat_Params_List is a list of Heartbeat_beat_Params.
type Heartbeat_beat_Params_List = capnp.StructList[Heartbeat_beat_Params]

// NewHeartbeat_beat_Params creates a new list of Heartbeat_beat_Params.
func NewHeartbeat_beat_Params_List(s *capnp.Segment, sz int32) (Heartbeat_beat_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Heartbeat_beat_Params](l), err
}

// Heartbeat_beat_Params_Future is a wrapper for a Heartbeat_beat_Params promised by a client call.
type Heartbeat_beat_Params_Future struct{ *capnp.Future }

func (f Heartbeat_beat_Params_Future) Struct() (Heartbeat_beat_Params, error) {
	p, err := f.Future.Ptr()
	return Heartbeat_beat_Params(p.Struct()), err
}

type Heartbeat_beat_Results capnp.Struct

// Heartbeat_beat_Results_TypeID is the unique identifier for the type Heartbeat_beat_Results.
const Heartbeat_beat_Results_TypeID = 0xf43682c2a6e815f8

func NewHeartbeat_beat_Results(s *capnp.Segment) (Heartbeat_beat_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Heartbeat_beat_Results(st), err
}

func NewRootHeartbeat_beat_Results(s *capnp.Segment) (Heartbeat_beat_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Heartbeat_beat_Results(st), err
}

func ReadRootHeartbeat_beat_Results(msg *capnp.Message) (Heartbeat_beat_Results, error) {
	root, err := msg.Root()
	return Heartbeat_beat_Results(root.Struct()), err
}

func (s Heartbeat_beat_Results) String() string {
	str, _ := text.Marshal(0xf43682c2a6e815f8, capnp.Struct(s))
	return str
}

func (s Heartbeat_beat_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Heartbeat_beat_Results) DecodeFromPtr(p capnp.Ptr) Heartbeat_beat_Results {
	return Heartbeat_beat_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Heartbeat_beat_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Heartbeat_beat_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Heartbeat_beat_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Heartbeat_beat_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Heartbeat_beat_Results_List is a list of Heartbeat_beat_Results.
type Heartbeat_beat_Results_List = capnp.StructList[Heartbeat_beat_Results]

// NewHeartbeat_beat_Results creates a new list of Heartbeat_beat_Results.
func NewHeartbeat_beat_Results_List(s *capnp.Segment, sz int32) (Heartbeat_beat_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Heartbeat_beat_Results](l), err
}

// Heartbeat_beat_Results_Future is a wrapper for a Heartbeat_beat_Results promised by a client call.
type Heartbeat_beat_Results_Future struct{ *capnp.Future }

func (f Heartbeat_beat_Results_Future) Struct() (Heartbeat_beat_Results, error) {
	p, err := f.Future.Ptr()
	return Heartbeat_beat_Results(p.Struct()), err
}

type Persistent capnp.Client

// Persistent_TypeID is the unique identifier for the type Persistent.
const Persistent_TypeID = 0xc1a7daa0dc36cb65

func (c Persistent) Save(ctx context.Context, params func(Persistent_SaveParams) error) (Persistent_SaveResults_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc1a7daa0dc36cb65,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Persistent",
			MethodName:    "save",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Persistent_SaveParams(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Persistent_SaveResults_Future{Future: ans.Future()}, release

}

func (c Persistent) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Persistent) String() string {
	return "Persistent(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Persistent) AddRef() Persistent {
	return Persistent(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Persistent) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Persistent) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Persistent) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Persistent) DecodeFromPtr(p capnp.Ptr) Persistent {
	return Persistent(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Persistent) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Persistent) IsSame(other Persistent) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Persistent) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Persistent) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Persistent_Server is a Persistent with a local implementation.
type Persistent_Server interface {
	Save(context.Context, Persistent_save) error
}

// Persistent_NewServer creates a new Server from an implementation of Persistent_Server.
func Persistent_NewServer(s Persistent_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Persistent_Methods(nil, s), s, c)
}

// Persistent_ServerToClient creates a new Client from an implementation of Persistent_Server.
// The caller is responsible for calling Release on the returned Client.
func Persistent_ServerToClient(s Persistent_Server) Persistent {
	return Persistent(capnp.NewClient(Persistent_NewServer(s)))
}

// Persistent_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Persistent_Methods(methods []server.Method, s Persistent_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc1a7daa0dc36cb65,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Persistent",
			MethodName:    "save",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Save(ctx, Persistent_save{call})
		},
	})

	return methods
}

// Persistent_save holds the state for a server call to Persistent.save.
// See server.Call for documentation.
type Persistent_save struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Persistent_save) Args() Persistent_SaveParams {
	return Persistent_SaveParams(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Persistent_save) AllocResults() (Persistent_SaveResults, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Persistent_SaveResults(r), err
}

// Persistent_List is a list of Persistent.
type Persistent_List = capnp.CapList[Persistent]

// NewPersistent_List creates a new list of Persistent.
func NewPersistent_List(s *capnp.Segment, sz int32) (Persistent_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Persistent](l), err
}

type Persistent_SaveParams capnp.Struct

// Persistent_SaveParams_TypeID is the unique identifier for the type Persistent_SaveParams.
const Persistent_SaveParams_TypeID = 0xd5e0aac4225e0343

func NewPersistent_SaveParams(s *capnp.Segment) (Persistent_SaveParams, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Persistent_SaveParams(st), err
}

func NewRootPersistent_SaveParams(s *capnp.Segment) (Persistent_SaveParams, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Persistent_SaveParams(st), err
}

func ReadRootPersistent_SaveParams(msg *capnp.Message) (Persistent_SaveParams, error) {
	root, err := msg.Root()
	return Persistent_SaveParams(root.Struct()), err
}

func (s Persistent_SaveParams) String() string {
	str, _ := text.Marshal(0xd5e0aac4225e0343, capnp.Struct(s))
	return str
}

func (s Persistent_SaveParams) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Persistent_SaveParams) DecodeFromPtr(p capnp.Ptr) Persistent_SaveParams {
	return Persistent_SaveParams(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Persistent_SaveParams) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Persistent_SaveParams) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Persistent_SaveParams) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Persistent_SaveParams) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Persistent_SaveParams) SealFor() (SturdyRef_Owner, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef_Owner(p.Struct()), err
}

func (s Persistent_SaveParams) HasSealFor() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Persistent_SaveParams) SetSealFor(v SturdyRef_Owner) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSealFor sets the sealFor field to a newly
// allocated SturdyRef_Owner struct, preferring placement in s's segment.
func (s Persistent_SaveParams) NewSealFor() (SturdyRef_Owner, error) {
	ss, err := NewSturdyRef_Owner(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef_Owner{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Persistent_SaveParams_List is a list of Persistent_SaveParams.
type Persistent_SaveParams_List = capnp.StructList[Persistent_SaveParams]

// NewPersistent_SaveParams creates a new list of Persistent_SaveParams.
func NewPersistent_SaveParams_List(s *capnp.Segment, sz int32) (Persistent_SaveParams_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Persistent_SaveParams](l), err
}

// Persistent_SaveParams_Future is a wrapper for a Persistent_SaveParams promised by a client call.
type Persistent_SaveParams_Future struct{ *capnp.Future }

func (f Persistent_SaveParams_Future) Struct() (Persistent_SaveParams, error) {
	p, err := f.Future.Ptr()
	return Persistent_SaveParams(p.Struct()), err
}
func (p Persistent_SaveParams_Future) SealFor() SturdyRef_Owner_Future {
	return SturdyRef_Owner_Future{Future: p.Future.Field(0, nil)}
}

type Persistent_SaveResults capnp.Struct

// Persistent_SaveResults_TypeID is the unique identifier for the type Persistent_SaveResults.
const Persistent_SaveResults_TypeID = 0xdc5bd1ef982cec13

func NewPersistent_SaveResults(s *capnp.Segment) (Persistent_SaveResults, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Persistent_SaveResults(st), err
}

func NewRootPersistent_SaveResults(s *capnp.Segment) (Persistent_SaveResults, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Persistent_SaveResults(st), err
}

func ReadRootPersistent_SaveResults(msg *capnp.Message) (Persistent_SaveResults, error) {
	root, err := msg.Root()
	return Persistent_SaveResults(root.Struct()), err
}

func (s Persistent_SaveResults) String() string {
	str, _ := text.Marshal(0xdc5bd1ef982cec13, capnp.Struct(s))
	return str
}

func (s Persistent_SaveResults) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Persistent_SaveResults) DecodeFromPtr(p capnp.Ptr) Persistent_SaveResults {
	return Persistent_SaveResults(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Persistent_SaveResults) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Persistent_SaveResults) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Persistent_SaveResults) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Persistent_SaveResults) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Persistent_SaveResults) SturdyRef() (SturdyRef, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef(p.Struct()), err
}

func (s Persistent_SaveResults) HasSturdyRef() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Persistent_SaveResults) SetSturdyRef(v SturdyRef) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSturdyRef sets the sturdyRef field to a newly
// allocated SturdyRef struct, preferring placement in s's segment.
func (s Persistent_SaveResults) NewSturdyRef() (SturdyRef, error) {
	ss, err := NewSturdyRef(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Persistent_SaveResults) UnsaveSR() (SturdyRef, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return SturdyRef(p.Struct()), err
}

func (s Persistent_SaveResults) HasUnsaveSR() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Persistent_SaveResults) SetUnsaveSR(v SturdyRef) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewUnsaveSR sets the unsaveSR field to a newly
// allocated SturdyRef struct, preferring placement in s's segment.
func (s Persistent_SaveResults) NewUnsaveSR() (SturdyRef, error) {
	ss, err := NewSturdyRef(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Persistent_SaveResults_List is a list of Persistent_SaveResults.
type Persistent_SaveResults_List = capnp.StructList[Persistent_SaveResults]

// NewPersistent_SaveResults creates a new list of Persistent_SaveResults.
func NewPersistent_SaveResults_List(s *capnp.Segment, sz int32) (Persistent_SaveResults_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Persistent_SaveResults](l), err
}

// Persistent_SaveResults_Future is a wrapper for a Persistent_SaveResults promised by a client call.
type Persistent_SaveResults_Future struct{ *capnp.Future }

func (f Persistent_SaveResults_Future) Struct() (Persistent_SaveResults, error) {
	p, err := f.Future.Ptr()
	return Persistent_SaveResults(p.Struct()), err
}
func (p Persistent_SaveResults_Future) SturdyRef() SturdyRef_Future {
	return SturdyRef_Future{Future: p.Future.Field(0, nil)}
}
func (p Persistent_SaveResults_Future) UnsaveSR() SturdyRef_Future {
	return SturdyRef_Future{Future: p.Future.Field(1, nil)}
}

type Persistent_ReleaseSturdyRef capnp.Client

// Persistent_ReleaseSturdyRef_TypeID is the unique identifier for the type Persistent_ReleaseSturdyRef.
const Persistent_ReleaseSturdyRef_TypeID = 0x8f700f81169f2e52

func (c Persistent_ReleaseSturdyRef) ReleaseSR(ctx context.Context, params func(Persistent_ReleaseSturdyRef_releaseSR_Params) error) (Persistent_ReleaseSturdyRef_releaseSR_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8f700f81169f2e52,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Persistent.ReleaseSturdyRef",
			MethodName:    "release",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Persistent_ReleaseSturdyRef_releaseSR_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Persistent_ReleaseSturdyRef_releaseSR_Results_Future{Future: ans.Future()}, release

}

func (c Persistent_ReleaseSturdyRef) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Persistent_ReleaseSturdyRef) String() string {
	return "Persistent_ReleaseSturdyRef(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Persistent_ReleaseSturdyRef) AddRef() Persistent_ReleaseSturdyRef {
	return Persistent_ReleaseSturdyRef(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Persistent_ReleaseSturdyRef) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Persistent_ReleaseSturdyRef) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Persistent_ReleaseSturdyRef) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Persistent_ReleaseSturdyRef) DecodeFromPtr(p capnp.Ptr) Persistent_ReleaseSturdyRef {
	return Persistent_ReleaseSturdyRef(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Persistent_ReleaseSturdyRef) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Persistent_ReleaseSturdyRef) IsSame(other Persistent_ReleaseSturdyRef) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Persistent_ReleaseSturdyRef) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Persistent_ReleaseSturdyRef) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Persistent_ReleaseSturdyRef_Server is a Persistent_ReleaseSturdyRef with a local implementation.
type Persistent_ReleaseSturdyRef_Server interface {
	ReleaseSR(context.Context, Persistent_ReleaseSturdyRef_releaseSR) error
}

// Persistent_ReleaseSturdyRef_NewServer creates a new Server from an implementation of Persistent_ReleaseSturdyRef_Server.
func Persistent_ReleaseSturdyRef_NewServer(s Persistent_ReleaseSturdyRef_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Persistent_ReleaseSturdyRef_Methods(nil, s), s, c)
}

// Persistent_ReleaseSturdyRef_ServerToClient creates a new Client from an implementation of Persistent_ReleaseSturdyRef_Server.
// The caller is responsible for calling Release on the returned Client.
func Persistent_ReleaseSturdyRef_ServerToClient(s Persistent_ReleaseSturdyRef_Server) Persistent_ReleaseSturdyRef {
	return Persistent_ReleaseSturdyRef(capnp.NewClient(Persistent_ReleaseSturdyRef_NewServer(s)))
}

// Persistent_ReleaseSturdyRef_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Persistent_ReleaseSturdyRef_Methods(methods []server.Method, s Persistent_ReleaseSturdyRef_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8f700f81169f2e52,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Persistent.ReleaseSturdyRef",
			MethodName:    "release",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ReleaseSR(ctx, Persistent_ReleaseSturdyRef_releaseSR{call})
		},
	})

	return methods
}

// Persistent_ReleaseSturdyRef_releaseSR holds the state for a server call to Persistent_ReleaseSturdyRef.releaseSR.
// See server.Call for documentation.
type Persistent_ReleaseSturdyRef_releaseSR struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Persistent_ReleaseSturdyRef_releaseSR) Args() Persistent_ReleaseSturdyRef_releaseSR_Params {
	return Persistent_ReleaseSturdyRef_releaseSR_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Persistent_ReleaseSturdyRef_releaseSR) AllocResults() (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Results(r), err
}

// Persistent_ReleaseSturdyRef_List is a list of Persistent_ReleaseSturdyRef.
type Persistent_ReleaseSturdyRef_List = capnp.CapList[Persistent_ReleaseSturdyRef]

// NewPersistent_ReleaseSturdyRef_List creates a new list of Persistent_ReleaseSturdyRef.
func NewPersistent_ReleaseSturdyRef_List(s *capnp.Segment, sz int32) (Persistent_ReleaseSturdyRef_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Persistent_ReleaseSturdyRef](l), err
}

type Persistent_ReleaseSturdyRef_releaseSR_Params capnp.Struct

// Persistent_ReleaseSturdyRef_releaseSR_Params_TypeID is the unique identifier for the type Persistent_ReleaseSturdyRef_releaseSR_Params.
const Persistent_ReleaseSturdyRef_releaseSR_Params_TypeID = 0xa4db8c20d9807c15

func NewPersistent_ReleaseSturdyRef_releaseSR_Params(s *capnp.Segment) (Persistent_ReleaseSturdyRef_releaseSR_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Params(st), err
}

func NewRootPersistent_ReleaseSturdyRef_releaseSR_Params(s *capnp.Segment) (Persistent_ReleaseSturdyRef_releaseSR_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Params(st), err
}

func ReadRootPersistent_ReleaseSturdyRef_releaseSR_Params(msg *capnp.Message) (Persistent_ReleaseSturdyRef_releaseSR_Params, error) {
	root, err := msg.Root()
	return Persistent_ReleaseSturdyRef_releaseSR_Params(root.Struct()), err
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) String() string {
	str, _ := text.Marshal(0xa4db8c20d9807c15, capnp.Struct(s))
	return str
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Persistent_ReleaseSturdyRef_releaseSR_Params) DecodeFromPtr(p capnp.Ptr) Persistent_ReleaseSturdyRef_releaseSR_Params {
	return Persistent_ReleaseSturdyRef_releaseSR_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Persistent_ReleaseSturdyRef_releaseSR_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Persistent_ReleaseSturdyRef_releaseSR_Params_List is a list of Persistent_ReleaseSturdyRef_releaseSR_Params.
type Persistent_ReleaseSturdyRef_releaseSR_Params_List = capnp.StructList[Persistent_ReleaseSturdyRef_releaseSR_Params]

// NewPersistent_ReleaseSturdyRef_releaseSR_Params creates a new list of Persistent_ReleaseSturdyRef_releaseSR_Params.
func NewPersistent_ReleaseSturdyRef_releaseSR_Params_List(s *capnp.Segment, sz int32) (Persistent_ReleaseSturdyRef_releaseSR_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Persistent_ReleaseSturdyRef_releaseSR_Params](l), err
}

// Persistent_ReleaseSturdyRef_releaseSR_Params_Future is a wrapper for a Persistent_ReleaseSturdyRef_releaseSR_Params promised by a client call.
type Persistent_ReleaseSturdyRef_releaseSR_Params_Future struct{ *capnp.Future }

func (f Persistent_ReleaseSturdyRef_releaseSR_Params_Future) Struct() (Persistent_ReleaseSturdyRef_releaseSR_Params, error) {
	p, err := f.Future.Ptr()
	return Persistent_ReleaseSturdyRef_releaseSR_Params(p.Struct()), err
}

type Persistent_ReleaseSturdyRef_releaseSR_Results capnp.Struct

// Persistent_ReleaseSturdyRef_releaseSR_Results_TypeID is the unique identifier for the type Persistent_ReleaseSturdyRef_releaseSR_Results.
const Persistent_ReleaseSturdyRef_releaseSR_Results_TypeID = 0x932d6ee32410e853

func NewPersistent_ReleaseSturdyRef_releaseSR_Results(s *capnp.Segment) (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Results(st), err
}

func NewRootPersistent_ReleaseSturdyRef_releaseSR_Results(s *capnp.Segment) (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Results(st), err
}

func ReadRootPersistent_ReleaseSturdyRef_releaseSR_Results(msg *capnp.Message) (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	root, err := msg.Root()
	return Persistent_ReleaseSturdyRef_releaseSR_Results(root.Struct()), err
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) String() string {
	str, _ := text.Marshal(0x932d6ee32410e853, capnp.Struct(s))
	return str
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Persistent_ReleaseSturdyRef_releaseSR_Results) DecodeFromPtr(p capnp.Ptr) Persistent_ReleaseSturdyRef_releaseSR_Results {
	return Persistent_ReleaseSturdyRef_releaseSR_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Persistent_ReleaseSturdyRef_releaseSR_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Persistent_ReleaseSturdyRef_releaseSR_Results) Success() bool {
	return capnp.Struct(s).Bit(0)
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) SetSuccess(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// Persistent_ReleaseSturdyRef_releaseSR_Results_List is a list of Persistent_ReleaseSturdyRef_releaseSR_Results.
type Persistent_ReleaseSturdyRef_releaseSR_Results_List = capnp.StructList[Persistent_ReleaseSturdyRef_releaseSR_Results]

// NewPersistent_ReleaseSturdyRef_releaseSR_Results creates a new list of Persistent_ReleaseSturdyRef_releaseSR_Results.
func NewPersistent_ReleaseSturdyRef_releaseSR_Results_List(s *capnp.Segment, sz int32) (Persistent_ReleaseSturdyRef_releaseSR_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Persistent_ReleaseSturdyRef_releaseSR_Results](l), err
}

// Persistent_ReleaseSturdyRef_releaseSR_Results_Future is a wrapper for a Persistent_ReleaseSturdyRef_releaseSR_Results promised by a client call.
type Persistent_ReleaseSturdyRef_releaseSR_Results_Future struct{ *capnp.Future }

func (f Persistent_ReleaseSturdyRef_releaseSR_Results_Future) Struct() (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	p, err := f.Future.Ptr()
	return Persistent_ReleaseSturdyRef_releaseSR_Results(p.Struct()), err
}

type Restorer capnp.Client

// Restorer_TypeID is the unique identifier for the type Restorer.
const Restorer_TypeID = 0x9fb6218427d92e3c

func (c Restorer) Restore(ctx context.Context, params func(Restorer_RestoreParams) error) (Restorer_restore_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Restorer",
			MethodName:    "restore",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Restorer_RestoreParams(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Restorer_restore_Results_Future{Future: ans.Future()}, release

}

func (c Restorer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Restorer) String() string {
	return "Restorer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Restorer) AddRef() Restorer {
	return Restorer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Restorer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Restorer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Restorer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Restorer) DecodeFromPtr(p capnp.Ptr) Restorer {
	return Restorer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Restorer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Restorer) IsSame(other Restorer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Restorer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Restorer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Restorer_Server is a Restorer with a local implementation.
type Restorer_Server interface {
	Restore(context.Context, Restorer_restore) error
}

// Restorer_NewServer creates a new Server from an implementation of Restorer_Server.
func Restorer_NewServer(s Restorer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Restorer_Methods(nil, s), s, c)
}

// Restorer_ServerToClient creates a new Client from an implementation of Restorer_Server.
// The caller is responsible for calling Release on the returned Client.
func Restorer_ServerToClient(s Restorer_Server) Restorer {
	return Restorer(capnp.NewClient(Restorer_NewServer(s)))
}

// Restorer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Restorer_Methods(methods []server.Method, s Restorer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Restorer",
			MethodName:    "restore",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Restore(ctx, Restorer_restore{call})
		},
	})

	return methods
}

// Restorer_restore holds the state for a server call to Restorer.restore.
// See server.Call for documentation.
type Restorer_restore struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Restorer_restore) Args() Restorer_RestoreParams {
	return Restorer_RestoreParams(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Restorer_restore) AllocResults() (Restorer_restore_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Restorer_restore_Results(r), err
}

// Restorer_List is a list of Restorer.
type Restorer_List = capnp.CapList[Restorer]

// NewRestorer_List creates a new list of Restorer.
func NewRestorer_List(s *capnp.Segment, sz int32) (Restorer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Restorer](l), err
}

type Restorer_RestoreParams capnp.Struct

// Restorer_RestoreParams_TypeID is the unique identifier for the type Restorer_RestoreParams.
const Restorer_RestoreParams_TypeID = 0xc541e5764a37d73a

func NewRestorer_RestoreParams(s *capnp.Segment) (Restorer_RestoreParams, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Restorer_RestoreParams(st), err
}

func NewRootRestorer_RestoreParams(s *capnp.Segment) (Restorer_RestoreParams, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Restorer_RestoreParams(st), err
}

func ReadRootRestorer_RestoreParams(msg *capnp.Message) (Restorer_RestoreParams, error) {
	root, err := msg.Root()
	return Restorer_RestoreParams(root.Struct()), err
}

func (s Restorer_RestoreParams) String() string {
	str, _ := text.Marshal(0xc541e5764a37d73a, capnp.Struct(s))
	return str
}

func (s Restorer_RestoreParams) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Restorer_RestoreParams) DecodeFromPtr(p capnp.Ptr) Restorer_RestoreParams {
	return Restorer_RestoreParams(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Restorer_RestoreParams) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Restorer_RestoreParams) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Restorer_RestoreParams) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Restorer_RestoreParams) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Restorer_RestoreParams) LocalRef() (SturdyRef_Token, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef_Token(p.Struct()), err
}

func (s Restorer_RestoreParams) HasLocalRef() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Restorer_RestoreParams) SetLocalRef(v SturdyRef_Token) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLocalRef sets the localRef field to a newly
// allocated SturdyRef_Token struct, preferring placement in s's segment.
func (s Restorer_RestoreParams) NewLocalRef() (SturdyRef_Token, error) {
	ss, err := NewSturdyRef_Token(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef_Token{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Restorer_RestoreParams) SealedBy() (SturdyRef_Owner, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return SturdyRef_Owner(p.Struct()), err
}

func (s Restorer_RestoreParams) HasSealedBy() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Restorer_RestoreParams) SetSealedBy(v SturdyRef_Owner) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewSealedBy sets the sealedBy field to a newly
// allocated SturdyRef_Owner struct, preferring placement in s's segment.
func (s Restorer_RestoreParams) NewSealedBy() (SturdyRef_Owner, error) {
	ss, err := NewSturdyRef_Owner(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef_Owner{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Restorer_RestoreParams_List is a list of Restorer_RestoreParams.
type Restorer_RestoreParams_List = capnp.StructList[Restorer_RestoreParams]

// NewRestorer_RestoreParams creates a new list of Restorer_RestoreParams.
func NewRestorer_RestoreParams_List(s *capnp.Segment, sz int32) (Restorer_RestoreParams_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Restorer_RestoreParams](l), err
}

// Restorer_RestoreParams_Future is a wrapper for a Restorer_RestoreParams promised by a client call.
type Restorer_RestoreParams_Future struct{ *capnp.Future }

func (f Restorer_RestoreParams_Future) Struct() (Restorer_RestoreParams, error) {
	p, err := f.Future.Ptr()
	return Restorer_RestoreParams(p.Struct()), err
}
func (p Restorer_RestoreParams_Future) LocalRef() SturdyRef_Token_Future {
	return SturdyRef_Token_Future{Future: p.Future.Field(0, nil)}
}
func (p Restorer_RestoreParams_Future) SealedBy() SturdyRef_Owner_Future {
	return SturdyRef_Owner_Future{Future: p.Future.Field(1, nil)}
}

type Restorer_restore_Results capnp.Struct

// Restorer_restore_Results_TypeID is the unique identifier for the type Restorer_restore_Results.
const Restorer_restore_Results_TypeID = 0xda966d1d252e4d25

func NewRestorer_restore_Results(s *capnp.Segment) (Restorer_restore_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Restorer_restore_Results(st), err
}

func NewRootRestorer_restore_Results(s *capnp.Segment) (Restorer_restore_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Restorer_restore_Results(st), err
}

func ReadRootRestorer_restore_Results(msg *capnp.Message) (Restorer_restore_Results, error) {
	root, err := msg.Root()
	return Restorer_restore_Results(root.Struct()), err
}

func (s Restorer_restore_Results) String() string {
	str, _ := text.Marshal(0xda966d1d252e4d25, capnp.Struct(s))
	return str
}

func (s Restorer_restore_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Restorer_restore_Results) DecodeFromPtr(p capnp.Ptr) Restorer_restore_Results {
	return Restorer_restore_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Restorer_restore_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Restorer_restore_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Restorer_restore_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Restorer_restore_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Restorer_restore_Results) Cap() capnp.Client {
	p, _ := capnp.Struct(s).Ptr(0)
	return p.Interface().Client()
}

func (s Restorer_restore_Results) HasCap() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Restorer_restore_Results) SetCap(c capnp.Client) error {
	if !c.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(c))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Restorer_restore_Results_List is a list of Restorer_restore_Results.
type Restorer_restore_Results_List = capnp.StructList[Restorer_restore_Results]

// NewRestorer_restore_Results creates a new list of Restorer_restore_Results.
func NewRestorer_restore_Results_List(s *capnp.Segment, sz int32) (Restorer_restore_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Restorer_restore_Results](l), err
}

// Restorer_restore_Results_Future is a wrapper for a Restorer_restore_Results promised by a client call.
type Restorer_restore_Results_Future struct{ *capnp.Future }

func (f Restorer_restore_Results_Future) Struct() (Restorer_restore_Results, error) {
	p, err := f.Future.Ptr()
	return Restorer_restore_Results(p.Struct()), err
}
func (p Restorer_restore_Results_Future) Cap() capnp.Client {
	return p.Future.Field(0, nil).Client()
}

type HostPortResolver capnp.Client

// HostPortResolver_TypeID is the unique identifier for the type HostPortResolver.
const HostPortResolver_TypeID = 0xaa8d91fab6d01d9f

func (c HostPortResolver) ResolveIdent(ctx context.Context, params func(HostPortResolver_ResolveIdent_Params) error) (HostPortResolver_ResolveIdent_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xaa8d91fab6d01d9f,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:HostPortResolver",
			MethodName:    "resolve",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(HostPortResolver_ResolveIdent_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return HostPortResolver_ResolveIdent_Results_Future{Future: ans.Future()}, release

}

func (c HostPortResolver) Info(ctx context.Context, params func(common.Identifiable_info_Params) error) (common.IdInformation_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(common.Identifiable_info_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return common.IdInformation_Future{Future: ans.Future()}, release

}

func (c HostPortResolver) Restore(ctx context.Context, params func(Restorer_RestoreParams) error) (Restorer_restore_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Restorer",
			MethodName:    "restore",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Restorer_RestoreParams(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Restorer_restore_Results_Future{Future: ans.Future()}, release

}

func (c HostPortResolver) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c HostPortResolver) String() string {
	return "HostPortResolver(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c HostPortResolver) AddRef() HostPortResolver {
	return HostPortResolver(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c HostPortResolver) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c HostPortResolver) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c HostPortResolver) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (HostPortResolver) DecodeFromPtr(p capnp.Ptr) HostPortResolver {
	return HostPortResolver(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c HostPortResolver) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c HostPortResolver) IsSame(other HostPortResolver) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c HostPortResolver) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c HostPortResolver) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A HostPortResolver_Server is a HostPortResolver with a local implementation.
type HostPortResolver_Server interface {
	ResolveIdent(context.Context, HostPortResolver_ResolveIdent) error

	Info(context.Context, common.Identifiable_info) error

	Restore(context.Context, Restorer_restore) error
}

// HostPortResolver_NewServer creates a new Server from an implementation of HostPortResolver_Server.
func HostPortResolver_NewServer(s HostPortResolver_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(HostPortResolver_Methods(nil, s), s, c)
}

// HostPortResolver_ServerToClient creates a new Client from an implementation of HostPortResolver_Server.
// The caller is responsible for calling Release on the returned Client.
func HostPortResolver_ServerToClient(s HostPortResolver_Server) HostPortResolver {
	return HostPortResolver(capnp.NewClient(HostPortResolver_NewServer(s)))
}

// HostPortResolver_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func HostPortResolver_Methods(methods []server.Method, s HostPortResolver_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 3)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xaa8d91fab6d01d9f,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:HostPortResolver",
			MethodName:    "resolve",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ResolveIdent(ctx, HostPortResolver_ResolveIdent{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Info(ctx, common.Identifiable_info{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Restorer",
			MethodName:    "restore",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Restore(ctx, Restorer_restore{call})
		},
	})

	return methods
}

// HostPortResolver_ResolveIdent holds the state for a server call to HostPortResolver.ResolveIdent.
// See server.Call for documentation.
type HostPortResolver_ResolveIdent struct {
	*server.Call
}

// Args returns the call's arguments.
func (c HostPortResolver_ResolveIdent) Args() HostPortResolver_ResolveIdent_Params {
	return HostPortResolver_ResolveIdent_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c HostPortResolver_ResolveIdent) AllocResults() (HostPortResolver_ResolveIdent_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Results(r), err
}

// HostPortResolver_List is a list of HostPortResolver.
type HostPortResolver_List = capnp.CapList[HostPortResolver]

// NewHostPortResolver_List creates a new list of HostPortResolver.
func NewHostPortResolver_List(s *capnp.Segment, sz int32) (HostPortResolver_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[HostPortResolver](l), err
}

type HostPortResolver_Registrar capnp.Client

// HostPortResolver_Registrar_TypeID is the unique identifier for the type HostPortResolver_Registrar.
const HostPortResolver_Registrar_TypeID = 0xb0caf775704690b2

func (c HostPortResolver_Registrar) Register(ctx context.Context, params func(HostPortResolver_Registrar_RegisterParams) error) (HostPortResolver_Registrar_register_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb0caf775704690b2,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:HostPortResolver.Registrar",
			MethodName:    "register",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 4}
		s.PlaceArgs = func(s capnp.Struct) error { return params(HostPortResolver_Registrar_RegisterParams(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return HostPortResolver_Registrar_register_Results_Future{Future: ans.Future()}, release

}

func (c HostPortResolver_Registrar) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c HostPortResolver_Registrar) String() string {
	return "HostPortResolver_Registrar(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c HostPortResolver_Registrar) AddRef() HostPortResolver_Registrar {
	return HostPortResolver_Registrar(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c HostPortResolver_Registrar) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c HostPortResolver_Registrar) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c HostPortResolver_Registrar) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (HostPortResolver_Registrar) DecodeFromPtr(p capnp.Ptr) HostPortResolver_Registrar {
	return HostPortResolver_Registrar(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c HostPortResolver_Registrar) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c HostPortResolver_Registrar) IsSame(other HostPortResolver_Registrar) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c HostPortResolver_Registrar) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c HostPortResolver_Registrar) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A HostPortResolver_Registrar_Server is a HostPortResolver_Registrar with a local implementation.
type HostPortResolver_Registrar_Server interface {
	Register(context.Context, HostPortResolver_Registrar_register) error
}

// HostPortResolver_Registrar_NewServer creates a new Server from an implementation of HostPortResolver_Registrar_Server.
func HostPortResolver_Registrar_NewServer(s HostPortResolver_Registrar_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(HostPortResolver_Registrar_Methods(nil, s), s, c)
}

// HostPortResolver_Registrar_ServerToClient creates a new Client from an implementation of HostPortResolver_Registrar_Server.
// The caller is responsible for calling Release on the returned Client.
func HostPortResolver_Registrar_ServerToClient(s HostPortResolver_Registrar_Server) HostPortResolver_Registrar {
	return HostPortResolver_Registrar(capnp.NewClient(HostPortResolver_Registrar_NewServer(s)))
}

// HostPortResolver_Registrar_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func HostPortResolver_Registrar_Methods(methods []server.Method, s HostPortResolver_Registrar_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb0caf775704690b2,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:HostPortResolver.Registrar",
			MethodName:    "register",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Register(ctx, HostPortResolver_Registrar_register{call})
		},
	})

	return methods
}

// HostPortResolver_Registrar_register holds the state for a server call to HostPortResolver_Registrar.register.
// See server.Call for documentation.
type HostPortResolver_Registrar_register struct {
	*server.Call
}

// Args returns the call's arguments.
func (c HostPortResolver_Registrar_register) Args() HostPortResolver_Registrar_RegisterParams {
	return HostPortResolver_Registrar_RegisterParams(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c HostPortResolver_Registrar_register) AllocResults() (HostPortResolver_Registrar_register_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_Registrar_register_Results(r), err
}

// HostPortResolver_Registrar_List is a list of HostPortResolver_Registrar.
type HostPortResolver_Registrar_List = capnp.CapList[HostPortResolver_Registrar]

// NewHostPortResolver_Registrar_List creates a new list of HostPortResolver_Registrar.
func NewHostPortResolver_Registrar_List(s *capnp.Segment, sz int32) (HostPortResolver_Registrar_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[HostPortResolver_Registrar](l), err
}

type HostPortResolver_Registrar_RegisterParams capnp.Struct

// HostPortResolver_Registrar_RegisterParams_TypeID is the unique identifier for the type HostPortResolver_Registrar_RegisterParams.
const HostPortResolver_Registrar_RegisterParams_TypeID = 0xbf018f62ff460d0f

func NewHostPortResolver_Registrar_RegisterParams(s *capnp.Segment) (HostPortResolver_Registrar_RegisterParams, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 4})
	return HostPortResolver_Registrar_RegisterParams(st), err
}

func NewRootHostPortResolver_Registrar_RegisterParams(s *capnp.Segment) (HostPortResolver_Registrar_RegisterParams, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 4})
	return HostPortResolver_Registrar_RegisterParams(st), err
}

func ReadRootHostPortResolver_Registrar_RegisterParams(msg *capnp.Message) (HostPortResolver_Registrar_RegisterParams, error) {
	root, err := msg.Root()
	return HostPortResolver_Registrar_RegisterParams(root.Struct()), err
}

func (s HostPortResolver_Registrar_RegisterParams) String() string {
	str, _ := text.Marshal(0xbf018f62ff460d0f, capnp.Struct(s))
	return str
}

func (s HostPortResolver_Registrar_RegisterParams) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_Registrar_RegisterParams) DecodeFromPtr(p capnp.Ptr) HostPortResolver_Registrar_RegisterParams {
	return HostPortResolver_Registrar_RegisterParams(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_Registrar_RegisterParams) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_Registrar_RegisterParams) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_Registrar_RegisterParams) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_Registrar_RegisterParams) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HostPortResolver_Registrar_RegisterParams) Base64VatId() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s HostPortResolver_Registrar_RegisterParams) HasBase64VatId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HostPortResolver_Registrar_RegisterParams) Base64VatIdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s HostPortResolver_Registrar_RegisterParams) SetBase64VatId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s HostPortResolver_Registrar_RegisterParams) Host() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s HostPortResolver_Registrar_RegisterParams) HasHost() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s HostPortResolver_Registrar_RegisterParams) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s HostPortResolver_Registrar_RegisterParams) SetHost(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s HostPortResolver_Registrar_RegisterParams) Port() uint16 {
	return capnp.Struct(s).Uint16(0)
}

func (s HostPortResolver_Registrar_RegisterParams) SetPort(v uint16) {
	capnp.Struct(s).SetUint16(0, v)
}

func (s HostPortResolver_Registrar_RegisterParams) Alias() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s HostPortResolver_Registrar_RegisterParams) HasAlias() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s HostPortResolver_Registrar_RegisterParams) AliasBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s HostPortResolver_Registrar_RegisterParams) SetAlias(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s HostPortResolver_Registrar_RegisterParams) IdentityProof() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s HostPortResolver_Registrar_RegisterParams) HasIdentityProof() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s HostPortResolver_Registrar_RegisterParams) SetIdentityProof(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

// HostPortResolver_Registrar_RegisterParams_List is a list of HostPortResolver_Registrar_RegisterParams.
type HostPortResolver_Registrar_RegisterParams_List = capnp.StructList[HostPortResolver_Registrar_RegisterParams]

// NewHostPortResolver_Registrar_RegisterParams creates a new list of HostPortResolver_Registrar_RegisterParams.
func NewHostPortResolver_Registrar_RegisterParams_List(s *capnp.Segment, sz int32) (HostPortResolver_Registrar_RegisterParams_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 4}, sz)
	return capnp.StructList[HostPortResolver_Registrar_RegisterParams](l), err
}

// HostPortResolver_Registrar_RegisterParams_Future is a wrapper for a HostPortResolver_Registrar_RegisterParams promised by a client call.
type HostPortResolver_Registrar_RegisterParams_Future struct{ *capnp.Future }

func (f HostPortResolver_Registrar_RegisterParams_Future) Struct() (HostPortResolver_Registrar_RegisterParams, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_Registrar_RegisterParams(p.Struct()), err
}

type HostPortResolver_Registrar_register_Results capnp.Struct

// HostPortResolver_Registrar_register_Results_TypeID is the unique identifier for the type HostPortResolver_Registrar_register_Results.
const HostPortResolver_Registrar_register_Results_TypeID = 0xfafc816633f98bb9

func NewHostPortResolver_Registrar_register_Results(s *capnp.Segment) (HostPortResolver_Registrar_register_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_Registrar_register_Results(st), err
}

func NewRootHostPortResolver_Registrar_register_Results(s *capnp.Segment) (HostPortResolver_Registrar_register_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_Registrar_register_Results(st), err
}

func ReadRootHostPortResolver_Registrar_register_Results(msg *capnp.Message) (HostPortResolver_Registrar_register_Results, error) {
	root, err := msg.Root()
	return HostPortResolver_Registrar_register_Results(root.Struct()), err
}

func (s HostPortResolver_Registrar_register_Results) String() string {
	str, _ := text.Marshal(0xfafc816633f98bb9, capnp.Struct(s))
	return str
}

func (s HostPortResolver_Registrar_register_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_Registrar_register_Results) DecodeFromPtr(p capnp.Ptr) HostPortResolver_Registrar_register_Results {
	return HostPortResolver_Registrar_register_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_Registrar_register_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_Registrar_register_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_Registrar_register_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_Registrar_register_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HostPortResolver_Registrar_register_Results) Heartbeat() Heartbeat {
	p, _ := capnp.Struct(s).Ptr(0)
	return Heartbeat(p.Interface().Client())
}

func (s HostPortResolver_Registrar_register_Results) HasHeartbeat() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HostPortResolver_Registrar_register_Results) SetHeartbeat(v Heartbeat) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s HostPortResolver_Registrar_register_Results) SecsHeartbeatInterval() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s HostPortResolver_Registrar_register_Results) SetSecsHeartbeatInterval(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

// HostPortResolver_Registrar_register_Results_List is a list of HostPortResolver_Registrar_register_Results.
type HostPortResolver_Registrar_register_Results_List = capnp.StructList[HostPortResolver_Registrar_register_Results]

// NewHostPortResolver_Registrar_register_Results creates a new list of HostPortResolver_Registrar_register_Results.
func NewHostPortResolver_Registrar_register_Results_List(s *capnp.Segment, sz int32) (HostPortResolver_Registrar_register_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[HostPortResolver_Registrar_register_Results](l), err
}

// HostPortResolver_Registrar_register_Results_Future is a wrapper for a HostPortResolver_Registrar_register_Results promised by a client call.
type HostPortResolver_Registrar_register_Results_Future struct{ *capnp.Future }

func (f HostPortResolver_Registrar_register_Results_Future) Struct() (HostPortResolver_Registrar_register_Results, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_Registrar_register_Results(p.Struct()), err
}
func (p HostPortResolver_Registrar_register_Results_Future) Heartbeat() Heartbeat {
	return Heartbeat(p.Future.Field(0, nil).Client())
}

type HostPortResolver_ResolveIdent_Params capnp.Struct

// HostPortResolver_ResolveIdent_Params_TypeID is the unique identifier for the type HostPortResolver_ResolveIdent_Params.
const HostPortResolver_ResolveIdent_Params_TypeID = 0xe6f8966f0f2cbb33

func NewHostPortResolver_ResolveIdent_Params(s *capnp.Segment) (HostPortResolver_ResolveIdent_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Params(st), err
}

func NewRootHostPortResolver_ResolveIdent_Params(s *capnp.Segment) (HostPortResolver_ResolveIdent_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Params(st), err
}

func ReadRootHostPortResolver_ResolveIdent_Params(msg *capnp.Message) (HostPortResolver_ResolveIdent_Params, error) {
	root, err := msg.Root()
	return HostPortResolver_ResolveIdent_Params(root.Struct()), err
}

func (s HostPortResolver_ResolveIdent_Params) String() string {
	str, _ := text.Marshal(0xe6f8966f0f2cbb33, capnp.Struct(s))
	return str
}

func (s HostPortResolver_ResolveIdent_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_ResolveIdent_Params) DecodeFromPtr(p capnp.Ptr) HostPortResolver_ResolveIdent_Params {
	return HostPortResolver_ResolveIdent_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_ResolveIdent_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_ResolveIdent_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_ResolveIdent_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_ResolveIdent_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HostPortResolver_ResolveIdent_Params) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s HostPortResolver_ResolveIdent_Params) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HostPortResolver_ResolveIdent_Params) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s HostPortResolver_ResolveIdent_Params) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// HostPortResolver_ResolveIdent_Params_List is a list of HostPortResolver_ResolveIdent_Params.
type HostPortResolver_ResolveIdent_Params_List = capnp.StructList[HostPortResolver_ResolveIdent_Params]

// NewHostPortResolver_ResolveIdent_Params creates a new list of HostPortResolver_ResolveIdent_Params.
func NewHostPortResolver_ResolveIdent_Params_List(s *capnp.Segment, sz int32) (HostPortResolver_ResolveIdent_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HostPortResolver_ResolveIdent_Params](l), err
}

// HostPortResolver_ResolveIdent_Params_Future is a wrapper for a HostPortResolver_ResolveIdent_Params promised by a client call.
type HostPortResolver_ResolveIdent_Params_Future struct{ *capnp.Future }

func (f HostPortResolver_ResolveIdent_Params_Future) Struct() (HostPortResolver_ResolveIdent_Params, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_ResolveIdent_Params(p.Struct()), err
}

type HostPortResolver_ResolveIdent_Results capnp.Struct

// HostPortResolver_ResolveIdent_Results_TypeID is the unique identifier for the type HostPortResolver_ResolveIdent_Results.
const HostPortResolver_ResolveIdent_Results_TypeID = 0xfc185f518d220b8c

func NewHostPortResolver_ResolveIdent_Results(s *capnp.Segment) (HostPortResolver_ResolveIdent_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Results(st), err
}

func NewRootHostPortResolver_ResolveIdent_Results(s *capnp.Segment) (HostPortResolver_ResolveIdent_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Results(st), err
}

func ReadRootHostPortResolver_ResolveIdent_Results(msg *capnp.Message) (HostPortResolver_ResolveIdent_Results, error) {
	root, err := msg.Root()
	return HostPortResolver_ResolveIdent_Results(root.Struct()), err
}

func (s HostPortResolver_ResolveIdent_Results) String() string {
	str, _ := text.Marshal(0xfc185f518d220b8c, capnp.Struct(s))
	return str
}

func (s HostPortResolver_ResolveIdent_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_ResolveIdent_Results) DecodeFromPtr(p capnp.Ptr) HostPortResolver_ResolveIdent_Results {
	return HostPortResolver_ResolveIdent_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_ResolveIdent_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_ResolveIdent_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_ResolveIdent_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_ResolveIdent_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HostPortResolver_ResolveIdent_Results) Host() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s HostPortResolver_ResolveIdent_Results) HasHost() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HostPortResolver_ResolveIdent_Results) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s HostPortResolver_ResolveIdent_Results) SetHost(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s HostPortResolver_ResolveIdent_Results) Port() uint16 {
	return capnp.Struct(s).Uint16(0)
}

func (s HostPortResolver_ResolveIdent_Results) SetPort(v uint16) {
	capnp.Struct(s).SetUint16(0, v)
}

// HostPortResolver_ResolveIdent_Results_List is a list of HostPortResolver_ResolveIdent_Results.
type HostPortResolver_ResolveIdent_Results_List = capnp.StructList[HostPortResolver_ResolveIdent_Results]

// NewHostPortResolver_ResolveIdent_Results creates a new list of HostPortResolver_ResolveIdent_Results.
func NewHostPortResolver_ResolveIdent_Results_List(s *capnp.Segment, sz int32) (HostPortResolver_ResolveIdent_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[HostPortResolver_ResolveIdent_Results](l), err
}

// HostPortResolver_ResolveIdent_Results_Future is a wrapper for a HostPortResolver_ResolveIdent_Results promised by a client call.
type HostPortResolver_ResolveIdent_Results_Future struct{ *capnp.Future }

func (f HostPortResolver_ResolveIdent_Results_Future) Struct() (HostPortResolver_ResolveIdent_Results, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_ResolveIdent_Results(p.Struct()), err
}

type Gateway capnp.Client

// Gateway_TypeID is the unique identifier for the type Gateway.
const Gateway_TypeID = 0x8f9c2c0a602f27ed

func (c Gateway) Register(ctx context.Context, params func(Gateway_register_Params) error) (Gateway_RegResults_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8f9c2c0a602f27ed,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Gateway",
			MethodName:    "register",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Gateway_register_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Gateway_RegResults_Future{Future: ans.Future()}, release

}

func (c Gateway) Info(ctx context.Context, params func(common.Identifiable_info_Params) error) (common.IdInformation_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(common.Identifiable_info_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return common.IdInformation_Future{Future: ans.Future()}, release

}

func (c Gateway) Restore(ctx context.Context, params func(Restorer_RestoreParams) error) (Restorer_restore_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Restorer",
			MethodName:    "restore",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Restorer_RestoreParams(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Restorer_restore_Results_Future{Future: ans.Future()}, release

}

func (c Gateway) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Gateway) String() string {
	return "Gateway(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Gateway) AddRef() Gateway {
	return Gateway(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Gateway) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Gateway) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Gateway) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Gateway) DecodeFromPtr(p capnp.Ptr) Gateway {
	return Gateway(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Gateway) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Gateway) IsSame(other Gateway) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Gateway) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Gateway) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Gateway_Server is a Gateway with a local implementation.
type Gateway_Server interface {
	Register(context.Context, Gateway_register) error

	Info(context.Context, common.Identifiable_info) error

	Restore(context.Context, Restorer_restore) error
}

// Gateway_NewServer creates a new Server from an implementation of Gateway_Server.
func Gateway_NewServer(s Gateway_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Gateway_Methods(nil, s), s, c)
}

// Gateway_ServerToClient creates a new Client from an implementation of Gateway_Server.
// The caller is responsible for calling Release on the returned Client.
func Gateway_ServerToClient(s Gateway_Server) Gateway {
	return Gateway(capnp.NewClient(Gateway_NewServer(s)))
}

// Gateway_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Gateway_Methods(methods []server.Method, s Gateway_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 3)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8f9c2c0a602f27ed,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Gateway",
			MethodName:    "register",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Register(ctx, Gateway_register{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Info(ctx, common.Identifiable_info{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:Restorer",
			MethodName:    "restore",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Restore(ctx, Restorer_restore{call})
		},
	})

	return methods
}

// Gateway_register holds the state for a server call to Gateway.register.
// See server.Call for documentation.
type Gateway_register struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Gateway_register) Args() Gateway_register_Params {
	return Gateway_register_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Gateway_register) AllocResults() (Gateway_RegResults, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Gateway_RegResults(r), err
}

// Gateway_List is a list of Gateway.
type Gateway_List = capnp.CapList[Gateway]

// NewGateway_List creates a new list of Gateway.
func NewGateway_List(s *capnp.Segment, sz int32) (Gateway_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Gateway](l), err
}

type Gateway_RegResults capnp.Struct

// Gateway_RegResults_TypeID is the unique identifier for the type Gateway_RegResults.
const Gateway_RegResults_TypeID = 0xa232c65d79e97faa

func NewGateway_RegResults(s *capnp.Segment) (Gateway_RegResults, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Gateway_RegResults(st), err
}

func NewRootGateway_RegResults(s *capnp.Segment) (Gateway_RegResults, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Gateway_RegResults(st), err
}

func ReadRootGateway_RegResults(msg *capnp.Message) (Gateway_RegResults, error) {
	root, err := msg.Root()
	return Gateway_RegResults(root.Struct()), err
}

func (s Gateway_RegResults) String() string {
	str, _ := text.Marshal(0xa232c65d79e97faa, capnp.Struct(s))
	return str
}

func (s Gateway_RegResults) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Gateway_RegResults) DecodeFromPtr(p capnp.Ptr) Gateway_RegResults {
	return Gateway_RegResults(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Gateway_RegResults) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Gateway_RegResults) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Gateway_RegResults) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Gateway_RegResults) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Gateway_RegResults) SturdyRef() (SturdyRef, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef(p.Struct()), err
}

func (s Gateway_RegResults) HasSturdyRef() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Gateway_RegResults) SetSturdyRef(v SturdyRef) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSturdyRef sets the sturdyRef field to a newly
// allocated SturdyRef struct, preferring placement in s's segment.
func (s Gateway_RegResults) NewSturdyRef() (SturdyRef, error) {
	ss, err := NewSturdyRef(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Gateway_RegResults) Heartbeat() Heartbeat {
	p, _ := capnp.Struct(s).Ptr(1)
	return Heartbeat(p.Interface().Client())
}

func (s Gateway_RegResults) HasHeartbeat() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Gateway_RegResults) SetHeartbeat(v Heartbeat) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

func (s Gateway_RegResults) SecsHeartbeatInterval() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Gateway_RegResults) SetSecsHeartbeatInterval(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

// Gateway_RegResults_List is a list of Gateway_RegResults.
type Gateway_RegResults_List = capnp.StructList[Gateway_RegResults]

// NewGateway_RegResults creates a new list of Gateway_RegResults.
func NewGateway_RegResults_List(s *capnp.Segment, sz int32) (Gateway_RegResults_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Gateway_RegResults](l), err
}

// Gateway_RegResults_Future is a wrapper for a Gateway_RegResults promised by a client call.
type Gateway_RegResults_Future struct{ *capnp.Future }

func (f Gateway_RegResults_Future) Struct() (Gateway_RegResults, error) {
	p, err := f.Future.Ptr()
	return Gateway_RegResults(p.Struct()), err
}
func (p Gateway_RegResults_Future) SturdyRef() SturdyRef_Future {
	return SturdyRef_Future{Future: p.Future.Field(0, nil)}
}
func (p Gateway_RegResults_Future) Heartbeat() Heartbeat {
	return Heartbeat(p.Future.Field(1, nil).Client())
}

type Gateway_register_Params capnp.Struct

// Gateway_register_Params_TypeID is the unique identifier for the type Gateway_register_Params.
const Gateway_register_Params_TypeID = 0xc78c1529af44abab

func NewGateway_register_Params(s *capnp.Segment) (Gateway_register_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Gateway_register_Params(st), err
}

func NewRootGateway_register_Params(s *capnp.Segment) (Gateway_register_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Gateway_register_Params(st), err
}

func ReadRootGateway_register_Params(msg *capnp.Message) (Gateway_register_Params, error) {
	root, err := msg.Root()
	return Gateway_register_Params(root.Struct()), err
}

func (s Gateway_register_Params) String() string {
	str, _ := text.Marshal(0xc78c1529af44abab, capnp.Struct(s))
	return str
}

func (s Gateway_register_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Gateway_register_Params) DecodeFromPtr(p capnp.Ptr) Gateway_register_Params {
	return Gateway_register_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Gateway_register_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Gateway_register_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Gateway_register_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Gateway_register_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Gateway_register_Params) Cap() capnp.Client {
	p, _ := capnp.Struct(s).Ptr(0)
	return p.Interface().Client()
}

func (s Gateway_register_Params) HasCap() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Gateway_register_Params) SetCap(c capnp.Client) error {
	if !c.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(c))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Gateway_register_Params_List is a list of Gateway_register_Params.
type Gateway_register_Params_List = capnp.StructList[Gateway_register_Params]

// NewGateway_register_Params creates a new list of Gateway_register_Params.
func NewGateway_register_Params_List(s *capnp.Segment, sz int32) (Gateway_register_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Gateway_register_Params](l), err
}

// Gateway_register_Params_Future is a wrapper for a Gateway_register_Params promised by a client call.
type Gateway_register_Params_Future struct{ *capnp.Future }

func (f Gateway_register_Params_Future) Struct() (Gateway_register_Params, error) {
	p, err := f.Future.Ptr()
	return Gateway_register_Params(p.Struct()), err
}
func (p Gateway_register_Params_Future) Cap() capnp.Client {
	return p.Future.Field(0, nil).Client()
}

type GatewayRegistrable capnp.Client

// GatewayRegistrable_TypeID is the unique identifier for the type GatewayRegistrable.
const GatewayRegistrable_TypeID = 0x8253222fdf37608d

func (c GatewayRegistrable) SturdyRefAtGateway(ctx context.Context, params func(GatewayRegistrable_sturdyRefAtGateway_Params) error) (GatewayRegistrable_sturdyRefAtGateway_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8253222fdf37608d,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:GatewayRegistrable",
			MethodName:    "sturdyRefAtGateway",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(GatewayRegistrable_sturdyRefAtGateway_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return GatewayRegistrable_sturdyRefAtGateway_Results_Future{Future: ans.Future()}, release

}

func (c GatewayRegistrable) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c GatewayRegistrable) String() string {
	return "GatewayRegistrable(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c GatewayRegistrable) AddRef() GatewayRegistrable {
	return GatewayRegistrable(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c GatewayRegistrable) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c GatewayRegistrable) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c GatewayRegistrable) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (GatewayRegistrable) DecodeFromPtr(p capnp.Ptr) GatewayRegistrable {
	return GatewayRegistrable(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c GatewayRegistrable) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c GatewayRegistrable) IsSame(other GatewayRegistrable) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c GatewayRegistrable) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c GatewayRegistrable) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A GatewayRegistrable_Server is a GatewayRegistrable with a local implementation.
type GatewayRegistrable_Server interface {
	SturdyRefAtGateway(context.Context, GatewayRegistrable_sturdyRefAtGateway) error
}

// GatewayRegistrable_NewServer creates a new Server from an implementation of GatewayRegistrable_Server.
func GatewayRegistrable_NewServer(s GatewayRegistrable_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(GatewayRegistrable_Methods(nil, s), s, c)
}

// GatewayRegistrable_ServerToClient creates a new Client from an implementation of GatewayRegistrable_Server.
// The caller is responsible for calling Release on the returned Client.
func GatewayRegistrable_ServerToClient(s GatewayRegistrable_Server) GatewayRegistrable {
	return GatewayRegistrable(capnp.NewClient(GatewayRegistrable_NewServer(s)))
}

// GatewayRegistrable_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func GatewayRegistrable_Methods(methods []server.Method, s GatewayRegistrable_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8253222fdf37608d,
			MethodID:      0,
			InterfaceName: "persistence/persistence.capnp:GatewayRegistrable",
			MethodName:    "sturdyRefAtGateway",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.SturdyRefAtGateway(ctx, GatewayRegistrable_sturdyRefAtGateway{call})
		},
	})

	return methods
}

// GatewayRegistrable_sturdyRefAtGateway holds the state for a server call to GatewayRegistrable.sturdyRefAtGateway.
// See server.Call for documentation.
type GatewayRegistrable_sturdyRefAtGateway struct {
	*server.Call
}

// Args returns the call's arguments.
func (c GatewayRegistrable_sturdyRefAtGateway) Args() GatewayRegistrable_sturdyRefAtGateway_Params {
	return GatewayRegistrable_sturdyRefAtGateway_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c GatewayRegistrable_sturdyRefAtGateway) AllocResults() (GatewayRegistrable_sturdyRefAtGateway_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return GatewayRegistrable_sturdyRefAtGateway_Results(r), err
}

// GatewayRegistrable_List is a list of GatewayRegistrable.
type GatewayRegistrable_List = capnp.CapList[GatewayRegistrable]

// NewGatewayRegistrable_List creates a new list of GatewayRegistrable.
func NewGatewayRegistrable_List(s *capnp.Segment, sz int32) (GatewayRegistrable_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[GatewayRegistrable](l), err
}

type GatewayRegistrable_sturdyRefAtGateway_Params capnp.Struct

// GatewayRegistrable_sturdyRefAtGateway_Params_TypeID is the unique identifier for the type GatewayRegistrable_sturdyRefAtGateway_Params.
const GatewayRegistrable_sturdyRefAtGateway_Params_TypeID = 0xb64c5d78d2b79d44

func NewGatewayRegistrable_sturdyRefAtGateway_Params(s *capnp.Segment) (GatewayRegistrable_sturdyRefAtGateway_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return GatewayRegistrable_sturdyRefAtGateway_Params(st), err
}

func NewRootGatewayRegistrable_sturdyRefAtGateway_Params(s *capnp.Segment) (GatewayRegistrable_sturdyRefAtGateway_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return GatewayRegistrable_sturdyRefAtGateway_Params(st), err
}

func ReadRootGatewayRegistrable_sturdyRefAtGateway_Params(msg *capnp.Message) (GatewayRegistrable_sturdyRefAtGateway_Params, error) {
	root, err := msg.Root()
	return GatewayRegistrable_sturdyRefAtGateway_Params(root.Struct()), err
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) String() string {
	str, _ := text.Marshal(0xb64c5d78d2b79d44, capnp.Struct(s))
	return str
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GatewayRegistrable_sturdyRefAtGateway_Params) DecodeFromPtr(p capnp.Ptr) GatewayRegistrable_sturdyRefAtGateway_Params {
	return GatewayRegistrable_sturdyRefAtGateway_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GatewayRegistrable_sturdyRefAtGateway_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GatewayRegistrable_sturdyRefAtGateway_Params) GatewaySR() (SturdyRef, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef(p.Struct()), err
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) HasGatewaySR() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) SetGatewaySR(v SturdyRef) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewGatewaySR sets the gatewaySR field to a newly
// allocated SturdyRef struct, preferring placement in s's segment.
func (s GatewayRegistrable_sturdyRefAtGateway_Params) NewGatewaySR() (SturdyRef, error) {
	ss, err := NewSturdyRef(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) GatewayId() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) HasGatewayId() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) GatewayIdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s GatewayRegistrable_sturdyRefAtGateway_Params) SetGatewayId(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// GatewayRegistrable_sturdyRefAtGateway_Params_List is a list of GatewayRegistrable_sturdyRefAtGateway_Params.
type GatewayRegistrable_sturdyRefAtGateway_Params_List = capnp.StructList[GatewayRegistrable_sturdyRefAtGateway_Params]

// NewGatewayRegistrable_sturdyRefAtGateway_Params creates a new list of GatewayRegistrable_sturdyRefAtGateway_Params.
func NewGatewayRegistrable_sturdyRefAtGateway_Params_List(s *capnp.Segment, sz int32) (GatewayRegistrable_sturdyRefAtGateway_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[GatewayRegistrable_sturdyRefAtGateway_Params](l), err
}

// GatewayRegistrable_sturdyRefAtGateway_Params_Future is a wrapper for a GatewayRegistrable_sturdyRefAtGateway_Params promised by a client call.
type GatewayRegistrable_sturdyRefAtGateway_Params_Future struct{ *capnp.Future }

func (f GatewayRegistrable_sturdyRefAtGateway_Params_Future) Struct() (GatewayRegistrable_sturdyRefAtGateway_Params, error) {
	p, err := f.Future.Ptr()
	return GatewayRegistrable_sturdyRefAtGateway_Params(p.Struct()), err
}
func (p GatewayRegistrable_sturdyRefAtGateway_Params_Future) GatewaySR() SturdyRef_Future {
	return SturdyRef_Future{Future: p.Future.Field(0, nil)}
}

type GatewayRegistrable_sturdyRefAtGateway_Results capnp.Struct

// GatewayRegistrable_sturdyRefAtGateway_Results_TypeID is the unique identifier for the type GatewayRegistrable_sturdyRefAtGateway_Results.
const GatewayRegistrable_sturdyRefAtGateway_Results_TypeID = 0xf7b8b0867aeef0b6

func NewGatewayRegistrable_sturdyRefAtGateway_Results(s *capnp.Segment) (GatewayRegistrable_sturdyRefAtGateway_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return GatewayRegistrable_sturdyRefAtGateway_Results(st), err
}

func NewRootGatewayRegistrable_sturdyRefAtGateway_Results(s *capnp.Segment) (GatewayRegistrable_sturdyRefAtGateway_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return GatewayRegistrable_sturdyRefAtGateway_Results(st), err
}

func ReadRootGatewayRegistrable_sturdyRefAtGateway_Results(msg *capnp.Message) (GatewayRegistrable_sturdyRefAtGateway_Results, error) {
	root, err := msg.Root()
	return GatewayRegistrable_sturdyRefAtGateway_Results(root.Struct()), err
}

func (s GatewayRegistrable_sturdyRefAtGateway_Results) String() string {
	str, _ := text.Marshal(0xf7b8b0867aeef0b6, capnp.Struct(s))
	return str
}

func (s GatewayRegistrable_sturdyRefAtGateway_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GatewayRegistrable_sturdyRefAtGateway_Results) DecodeFromPtr(p capnp.Ptr) GatewayRegistrable_sturdyRefAtGateway_Results {
	return GatewayRegistrable_sturdyRefAtGateway_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GatewayRegistrable_sturdyRefAtGateway_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GatewayRegistrable_sturdyRefAtGateway_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GatewayRegistrable_sturdyRefAtGateway_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GatewayRegistrable_sturdyRefAtGateway_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GatewayRegistrable_sturdyRefAtGateway_Results) SelfAtGatewaySR() (SturdyRef, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef(p.Struct()), err
}

func (s GatewayRegistrable_sturdyRefAtGateway_Results) HasSelfAtGatewaySR() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s GatewayRegistrable_sturdyRefAtGateway_Results) SetSelfAtGatewaySR(v SturdyRef) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSelfAtGatewaySR sets the selfAtGatewaySR field to a newly
// allocated SturdyRef struct, preferring placement in s's segment.
func (s GatewayRegistrable_sturdyRefAtGateway_Results) NewSelfAtGatewaySR() (SturdyRef, error) {
	ss, err := NewSturdyRef(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// GatewayRegistrable_sturdyRefAtGateway_Results_List is a list of GatewayRegistrable_sturdyRefAtGateway_Results.
type GatewayRegistrable_sturdyRefAtGateway_Results_List = capnp.StructList[GatewayRegistrable_sturdyRefAtGateway_Results]

// NewGatewayRegistrable_sturdyRefAtGateway_Results creates a new list of GatewayRegistrable_sturdyRefAtGateway_Results.
func NewGatewayRegistrable_sturdyRefAtGateway_Results_List(s *capnp.Segment, sz int32) (GatewayRegistrable_sturdyRefAtGateway_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[GatewayRegistrable_sturdyRefAtGateway_Results](l), err
}

// GatewayRegistrable_sturdyRefAtGateway_Results_Future is a wrapper for a GatewayRegistrable_sturdyRefAtGateway_Results promised by a client call.
type GatewayRegistrable_sturdyRefAtGateway_Results_Future struct{ *capnp.Future }

func (f GatewayRegistrable_sturdyRefAtGateway_Results_Future) Struct() (GatewayRegistrable_sturdyRefAtGateway_Results, error) {
	p, err := f.Future.Ptr()
	return GatewayRegistrable_sturdyRefAtGateway_Results(p.Struct()), err
}
func (p GatewayRegistrable_sturdyRefAtGateway_Results_Future) SelfAtGatewaySR() SturdyRef_Future {
	return SturdyRef_Future{Future: p.Future.Field(0, nil)}
}

const schema_855efed3475f6b26 = "x\xda\xb4X\x0fl\x13\xe7\x15\x7f\xef\xce\xc6I\x97\xc8" +
	"\xf9za\xed*\x81G\x1a\x08d\xe0\x90\x04\x85\x11\xb5" +
	"\x022\xc0$+\x9a\xbf\xcbV\xb5Ti\xb9$\x17\xe2" +
	"\xf5\xec\xb3\xef\xce\x0eFT\x01F7H\x89\xa0\xda\xd6" +
	"\xad\x13\x88\x82\xa6MM5\xd1fU\xb6n\xda*\xaa" +
	"\xb2\xadT\x95\x96N\xa8\x85V\xdb\xd0\xd4\xad\x95\x9am" +
	"T\x9b\xdae]o\xfa\xee\x7f\x12'\x0e\x13\x13\x12\xb2" +
	"?\xbf{\xef}\xef\xf7{\xbf\xf7.\xeb\xef\x8cm\x09" +
	"5W\x7f\xe7M\xe0\xba\xdf\xac\x0c/1G\xf7l\xfc" +
	"CS]\xf7a \xcbys\xd5\xc3\x0f%~\xf7\xc9" +
	"\x83\x8f\x02`k\xb32\x82B\xa7\x12\x01\x10\xb6+\x09" +
	"!\xcf>\x99\xbb~\xff\xb5e\x0d\x83\xe9\xa3@\x96\xa3" +
	"o\x1d\xe6\"\x00\xad=J\x07\x0ai\xa5\x01@8\xa4" +
	"\x0c\x01\x9a\x976\x9c}\xf1\xea\xc8\xc4\x08\x90\xd5\x08\x10" +
	"b6\xd7\x94s\x08!S\x8c\x9f\xf9\xf4\xa1h\xf6\x04" +
	"\x905\xbc)\xbf\xda\xf6\xf6SW\x7fx\x81\x05\x9dT" +
	"^Ga\xca\x0a\xfa\x9e\x92\x106\xa5Y\xd0\xa9\x86\xa6" +
	"=\xb7\xac=ubN\x8a+\xd2-(4\xa7o\x03" +
	"\x10\xeeN'\x84T\xba\x01\xc0L\x8d\x1c[\x1d\xea\x19" +
	"?\x01t\x15\xf2f\xf5\x03O\xe5\x96\x1cJ\xfc\x1b\x96" +
	"b\x04\x01Z\xa5\xb4\x88\x80B:\xcd\x12\xec~\xb7\xa6" +
	"\xfeO\x99u\xdf\x04\xda\x8en\x86\xaf\xa4E\x0ePx" +
	"'\xbd\x19\xd0l\xbf\x94\x98\x9c\xfe\xc5\x8f\xcf\xcc\x89\x1c" +
	"\xcet\xa0\xb04\xc3\xf2$\x99\x84\xb0\x89}2\xef\x8a" +
	"_i8\xb2bb\xae\xf5\x8aL;\x0a\xcd\x19+\xcf" +
	"LB\x90-\xeb\xb1\xe1\xf7\x8a=\xbfj9\xc7\xf2D" +
	"\xff\x8ev-weF\xd0\xb6\x13\xa4\xccy@s\xe9" +
	"\x81\x83W>{\xfc\xad\xef\x03iw3\xadT\xbb8" +
	"\x08\x99g\x96\xfdvb\xfa\xf1\xd1\xb1\xb99\xaa\xfbQ" +
	"\xf8\x8c\xca\xa2\xaeT\x13B^e\xd5\x19?\xb9#\x9b" +
	"\xff\xf0\xd2\xb3@\x9ax\xffQ\xc0\xd6\xb4z\x09\x85c" +
	"\x96\xf5\xb7\xd5\x84pAe9n;\xfd\x93\xd7\xf7\xf5" +
	"\xdc3\x01\xa4\x19\xc1I\xediu7+\xd0E\x95U" +
	"0Z\xbd\xc3\xec=\x81/\x02\xdd\x84\xe8;\x0f[\x09" +
	"\xae\xc9vpBg\x96}\xdc\x9e\x8d!\xa0\x0f\xf5\xec" +
	"\\{r](\xe4r\x1b\x01\x84\xb3\xb9\x84\xf0J\x8e" +
	"Eo\x7fccW\xe1\x9d\xad\x17\x814\xa0_\\;" +
	"\x8b\xe7rch\x9b\x09\x17s,\x93g\x9e\xd9v~" +
	"\xcd\xd2\xe3\xbf\x06\xb2\x8a\xa5\x8aV\x02\xda8\x03{\x93" +
	"\xc6\xb0\xfc\x02\xff`\xdd\xcbc\x7f\xbc\x0cdM \x11" +
	"\xdb\xf0~\xed\x1c\x0a9\x8dyK[\xc6\xdf8\xf8\xf2" +
	"[\x1f\xbc\xf6\xfe\x95R<\x1f\xd5ZP8m\x19?" +
	"\xa9\xb1\xd0+w\xc5W.K?q\x95\xe5\xe9\x86\xfe" +
	"\xa7\xf63\x16:\xac3o\xc2\xfbk\xbf\xfb\xb7\xc9\x07" +
	"\xde\x9e\x15\xda\xf2\xb6R\x1fC\xe1n\x9dy\xdb\xa43" +
	"o\xa3\x93\x8f]6zn\xb9\x06t9\x86\xfc\xd8V" +
	"EO\xebu(\xfc\xc82~Z\xff\x0b\xa0\xd9\xfa\xf3" +
	"\xb5Q\xf5\x89\x8f\xfe\x0c\xa4\xc9\x0b=j|\xc0B\x9f" +
	"5X\xe8\x8f\x96\xbe\xfb\x83\x97\x0e\xb7\xfd#\xd0\x83\x17" +
	"\x8c1\xd6\x83\x13\x7f\xff\xeb\xfe\xaf?\xfb\xd3\x0f\x1dl" +
	"\xadG\x9f3z\x19\xb6\xafY\x8f\x1e}\x9e\x0c?\xff" +
	"\xb9\xad\xd3@W#\xfa\x9d\xbf\x1d#\x1c@\xebuC" +
	"C!\x9cg\xa9`\x9e\xe5\xfd\xc2c\xffj\x1d8\xf4" +
	"\xf1\xb4E\x05\xd7aO\xde\xea\xa6\xa2e\xe1\xf5\"]" +
	"\x8e\x01\xf8\x99C\xacl\xbd\x96oA\xe1\xba\xe5p*" +
	"\xcf(\x7f\xfcSu\xa3\xf4\xa1\xdb?\x06\xda\xe4;L" +
	"\x15\xa6\xd9\xe5\x1e)0\x87w\x0e\xfdf\xcf\xd4\x93o" +
	"\xfc\x87]\xceO\xd06\xbcR\xd0P\x98*XJR" +
	"\xd8\x0c\xe6\x0d\xff\xfb\xa5\x99\x955=\xa5\x1br8\xd3" +
	"'7\xb9_2}r\xbcO\xcaf\xb2\xed\x09\xc9\x90" +
	"\x87\xa4\xa2(\xefM\xe9\x86&\xf5*2@\x12\x91\x86" +
	"\xf8p\xa0u\xd0\xad3!\xdf\x03\x8eTGL\xdd\xc8" +
	"k\xfdEQ\xc6\x81\xad\x86\xe5\x83\x97\x8a[0\x89\xe8" +
	"\x05\x0c\x95\x0e\xd8\xed<8\x00\xb4\x02\x83\xb7\xafl\xf1" +
	"\xc1\"\xe1\x96\xd8\x97\x862\xb2\x16\xfb\xb2\xfa\xb0\x9c\xa1" +
	"\x15|\x08 \x84\x00dM\x1d\x00\xad\xe7\x91\xae\xe7\x90" +
	" \xd6\xb2\xa2\x92u]\x00t-\x8f\xf4\xf3\x1cF\x0a" +
	"\x92\x815>\xf7\x01\xb1\x06\xd0T\xd4>IaQ\x01" +
	"\xb0\xc6\x0f\xe4\xfcZ\xa6H;eI3ze\xc9\x88" +
	"\xb3\xff\xea\x93\x92\x16\x91\xd2\xba\xf7\xd4\x92\xd2O%\xdd" +
	"\x13#.\xca\x8a,\xe9r\xb7W4\xbf\xc4\xae&\xa2" +
	"\xab\xe3\x84t\x10\x12\x03$\xeb\"\xc3\x9a\xfd\x1c\x0d!" +
	"g^\x1fm\xba\xed\xd6=/\xbc\x044\xc4\xe1\xd6Z" +
	"\xc4*\x00\x82\xa2\xe9\xd8t\x03\x8a\x003!\xe0\xe7\xc3" +
	"<f\x81NC\x88\xbe\x82\x13\xdcm\x8a\xf2^Q\xd6" +
	"\xf3\x0a\xf0\x86\xee\xe4\xe7J\x12\xba\x86\x84t\x01G*" +
	"#\xa6fqF\xd6\x80\x85\xb5\xc0\xbc\xbc\xf3\xd4\xfd\xaf" +
	"N\x9e\x1f\x87\xe0\x1c\x01(G\x89\xad\xfd\xfd\x9a\xac\xeb" +
	"\xf1T\x16\xdb\x82Pw\x94\x82\x9a\x1d\xae\xe6\x91n\xe0" +
	"pXQ\x87d\xadm\x03V\x02\x87\x95\x80\xc3\xf9l" +
	"6\xf8\xdd\x8b[q\xa3\x00\x0d\xc4\x9d\xaa\xd6[\xe50" +
	"\x90U\xc3\xcd\xab\x9a\xa5P\xc1#\xad\xe5pX\xcf\xf7" +
	"\xf5\xc9\xba\x8e\x08\x1c\"\x94e\xbf\xc7\xa4@\x93\xb9\x1b" +
	"\x06\xba2GH#p$\x1c\x892\xc3E!*\xca" +
	"\x9buC\xd5d\xcd\x82\xd4\x1f9\xa8\x99\xa2l\xfd\x92" +
	"\x84\x98\xa4Ii\x17U\xd7\x04]\xd9'\xa4\xc3\x8a9" +
	"\xac\xd9\xf63\xc3.,\x1eq\x976\x86n\x8bG\x95" +
	"W\xab\xed\"\x00\xdd\xc6#M\x060\xdc\xc5\x0e\xef\xe1" +
	"\x91\xde\xc7!r\xb5\xc8\x01\x90\xaf\x8c\x03\xd0\xfbx\xa4" +
	"\xfd\x1cz\xe2\x028\x805\xbe&:\xcd:\xe8\xd4\x10" +
	"\xd0@\xe2o7\x80H\x00M]\xee\xd3Y\x95\xd1*" +
	"sg\xc6\x88\xc9ZAR\xb0\x028\xac\xb89\x9cH" +
	"Z\x95,\xcf\xeb\x9d\xaan$U\xcd`\xe8\xa8J\xc1" +
	"A\xc7_^P4]\xdd\x05\xd4\x1cd\xdca\x88\xee" +
	"\xe4\x98\xa9\x07\x96\xa3\x05\xf4\xe0\xab\x0cpf\xd3\x09\xd1" +
	"~9c,\xba7\x97\x94\xbb\x83}\x85\xb8\x9b\xb1\x06" +
	"`]\xc7[\x9e\x08\xeew\xae#k\xb09\x19d\x9b" +
	"k\x83\xeex-\xad!A\xc6U,v\\\xc5]\xb2" +
	"\xb8\x83H*Z\x00\xf1i=\xa8%\xa2/\x1b\x1e\x0f" +
	"\x9b\xd9\xe1z\x1e\xe9]\x1c\x9a{\xedg\x99\x8c\x96\xe0" +
	"\x9c\xf3k'`?V\x01\x87U\xe5\x994\x7f\xe5\xe2" +
	"n\x99\x1c\"\xb1\x96\xa9\xf5R}\xa4\x17\x80\x1e\xe0\x91" +
	"\x1e\x0d\xa4\xfah#\x00=\xc8#=\xee\xb7\xcc1v" +
	"v\x84Gz\x92C\xc2s\xb5\xc8\x03\x90\xd1\x16\x00z" +
	"\x94G\xfa-\x0eI\x88\xaf\xc5\x10\x00y\x9c\x81u\x92" +
	"Gz\x8aC\xb3W\xd2\xe5\xb6\x0d\xf7J\x101:\xbd" +
	"\xcbD\x07U\xdd\xf0\xbedU\xcd\xc0\x08p\x18\x01\x8c" +
	"IJJ\xd2\xbdK\xa7\x18\xa9RF\x11bIMU" +
	"\x07\xb0\x1a8\xac.\xaf{~[\x01\xd0*\x0c.\xb2" +
	"dw`\xb5$\xbd\x81\xd7*2bvK\x05\x99U" +
	"\x09\xf8\xb4n}a:\x03\x11\xc5\xd0M\xb7=\xd1[" +
	"(\xc0\xa1\x9b\xeb\x1b]\xbf\x9e\xa0\xeaRaq\xca\xe6" +
	"\xa8&\x83\xca\x96O)\xca\xa0bH\x05H\xd5U\x8a" +
	"T]\x01R-\xbcu\xe8\xb2\xa4\xc8\xfd\x1dE\xfbW" +
	"o\x13Z\xdcN\xe2j\xaf\xdbA\xf5IO\xe0\xbdA" +
	"U\xe7\x0f\xaaH\x9f\x94\xc5[C< \xdeZ\xdey" +
	"@\x05\x1d\x04\"\xce\xed\xe7\x1b\x83\xb2\xa4\xecP\xb5\x05" +
	"\xae1\xcf\xe4\xbaW\x8a\x19I\xc9\x18\x9cU\xd9;\xca" +
	"\x8c~>\xd5\x8f5\xfe[\x86\x1dkX\xb2\x17\x09\xac" +
	"\xf1\xb7\xf4\xc5\x15\xd3\x83\xdb\x99~\xf5\xe2f{\x9e\xfd" +
	"?\xaa)\xcaz\x94\xf9\x9eue\xb1\x1c\x99\x16\x9e\x8a" +
	"\xf9\x0c#w\xb7h\x93i\xf6\xafeQ`b\xc0\x12" +
	"\xaa\xf1\x12\x92v\x03\xd0=<R%\x90P\x8a\x1d\x0e" +
	"\xf2H\x0d\x0e\x09\xe7\x08Q\x8e\x1dfy\xa4\x07\x98\x10" +
	"\xf1\xb6\x10\x15\xd9\xe1>\x1e\xe9\x11\x0e\xcdl\xbeWI" +
	"\xf5}Q\x06\xbe\xb8\xde\xdf\xce\xfc\xc3\xe6R\x87-\xa5" +
	"\x0e[\xe7,w\x8b\x1d\\\xce\xec,\xd5'w\xf8\xc8" +
	"2b\xcd\x16\xf8\xc5\xbd\x15\xb8\xb0\xde\x9c\x11\xc6t." +
	"2\x8b\x80\x87\x99v\xf2Hogd\x90\x15\xcb\x1a\xed" +
	"\xa9%.\x04z\xb97\xb1\xb8\xfd\x96\xe5\xf0\xb1\xca4" +
	"mB6\xfa=X\x8d\x9f\x98N\x136\xfa4\x8d\x1a" +
	"\xf2>\x7fh\xf4K\x864g\x1c\xdc\xf8l\xf4\xf4\xcc" +
	"\xdb\xbcK\xf7\x88\xd7\"lq\xdc\xc0#\xdd\xc2\xdd\xac" +
	"\xd5\x90\x9f\xef5%f\xc9\x8b\xb3\xe1V\x99&\xa2\xff" +
	"\x87:\xb2\xbd\x0e8\xc2U\xd8-\x11,\x93]<\xd6" +
	"\x13\xcd\x8d\x81\xf7\xd4T\xb6m\xc6\xa0\x9d1\x82\xffg" +
	"v{\xc2\x15\xa8Z\x00HOK\x830\xce;\xfbo" +
	"\x80A\xd6\xdb\xfa\xac\x01\xd1\xe8\xb7Uto\xdeo\xac" +
	"\xff\x06\x00\x00\xff\xff\xa3\x8f\x82V"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_855efed3475f6b26,
		Nodes: []uint64{
			0x8253222fdf37608d,
			0x886d68271d83de4d,
			0x8ab68adabfa134ca,
			0x8f700f81169f2e52,
			0x8f9c2c0a602f27ed,
			0x8fb25d0428898a69,
			0x932d6ee32410e853,
			0x9fb3bdfad147ca3a,
			0x9fb6218427d92e3c,
			0xa232c65d79e97faa,
			0xa4db8c20d9807c15,
			0xaa8d91fab6d01d9f,
			0xb0caf775704690b2,
			0xb64c5d78d2b79d44,
			0xbf018f62ff460d0f,
			0xc1a7daa0dc36cb65,
			0xc541e5764a37d73a,
			0xc78c1529af44abab,
			0xd5e0aac4225e0343,
			0xd9eccdf2dbc48087,
			0xda966d1d252e4d25,
			0xdc5bd1ef982cec13,
			0xe10a5d74d58bd18d,
			0xe6f8966f0f2cbb33,
			0xf43682c2a6e815f8,
			0xf7b8b0867aeef0b6,
			0xfa412bb47f11b488,
			0xfafc816633f98bb9,
			0xfb47810671a05b0d,
			0xfc185f518d220b8c,
			0xfdd799ed60c87723,
		},
		Compressed: true,
	})
}
