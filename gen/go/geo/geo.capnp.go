// Code generated by capnpc-go. DO NOT EDIT.

package geo

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

// Constants defined in geo.capnp.
const (
	EPSG_wgs84  = uint32(4326)
	EPSG_utm21S = uint32(32721)
	EPSG_utm32N = uint32(25832)
	EPSG_gk5    = uint32(31469)
	EPSG_gk4    = uint32(31468)
	EPSG_gk3    = uint32(31467)
)

type CoordType uint16

// CoordType_TypeID is the unique identifier for the type CoordType.
const CoordType_TypeID = 0xe529b4deb322ece8

// Values of CoordType.
const (
	CoordType_gk     CoordType = 0
	CoordType_utm    CoordType = 1
	CoordType_latlon CoordType = 2
)

// String returns the enum's constant name.
func (c CoordType) String() string {
	switch c {
	case CoordType_gk:
		return "gk"
	case CoordType_utm:
		return "utm"
	case CoordType_latlon:
		return "latlon"

	default:
		return ""
	}
}

// CoordTypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func CoordTypeFromString(c string) CoordType {
	switch c {
	case "gk":
		return CoordType_gk
	case "utm":
		return CoordType_utm
	case "latlon":
		return CoordType_latlon

	default:
		return 0
	}
}

type CoordType_List = capnp.EnumList[CoordType]

func NewCoordType_List(s *capnp.Segment, sz int32) (CoordType_List, error) {
	return capnp.NewEnumList[CoordType](s, sz)
}

type EPSG capnp.Struct

// EPSG_TypeID is the unique identifier for the type EPSG.
const EPSG_TypeID = 0xb79427a74eb97fc0

func NewEPSG(s *capnp.Segment) (EPSG, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EPSG(st), err
}

func NewRootEPSG(s *capnp.Segment) (EPSG, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EPSG(st), err
}

func ReadRootEPSG(msg *capnp.Message) (EPSG, error) {
	root, err := msg.Root()
	return EPSG(root.Struct()), err
}

func (s EPSG) String() string {
	str, _ := text.Marshal(0xb79427a74eb97fc0, capnp.Struct(s))
	return str
}

func (s EPSG) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (EPSG) DecodeFromPtr(p capnp.Ptr) EPSG {
	return EPSG(capnp.Struct{}.DecodeFromPtr(p))
}

func (s EPSG) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s EPSG) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s EPSG) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s EPSG) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// EPSG_List is a list of EPSG.
type EPSG_List = capnp.StructList[EPSG]

// NewEPSG creates a new list of EPSG.
func NewEPSG_List(s *capnp.Segment, sz int32) (EPSG_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[EPSG](l), err
}

// EPSG_Future is a wrapper for a EPSG promised by a client call.
type EPSG_Future struct{ *capnp.Future }

func (f EPSG_Future) Struct() (EPSG, error) {
	p, err := f.Future.Ptr()
	return EPSG(p.Struct()), err
}

type UTMCoord capnp.Struct

// UTMCoord_TypeID is the unique identifier for the type UTMCoord.
const UTMCoord_TypeID = 0xeb1acd255e40f049

func NewUTMCoord(s *capnp.Segment) (UTMCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return UTMCoord(st), err
}

func NewRootUTMCoord(s *capnp.Segment) (UTMCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return UTMCoord(st), err
}

func ReadRootUTMCoord(msg *capnp.Message) (UTMCoord, error) {
	root, err := msg.Root()
	return UTMCoord(root.Struct()), err
}

func (s UTMCoord) String() string {
	str, _ := text.Marshal(0xeb1acd255e40f049, capnp.Struct(s))
	return str
}

func (s UTMCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (UTMCoord) DecodeFromPtr(p capnp.Ptr) UTMCoord {
	return UTMCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s UTMCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s UTMCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s UTMCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s UTMCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s UTMCoord) Zone() uint8 {
	return capnp.Struct(s).Uint8(0)
}

func (s UTMCoord) SetZone(v uint8) {
	capnp.Struct(s).SetUint8(0, v)
}

func (s UTMCoord) LatitudeBand() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s UTMCoord) HasLatitudeBand() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s UTMCoord) LatitudeBandBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s UTMCoord) SetLatitudeBand(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s UTMCoord) R() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s UTMCoord) SetR(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s UTMCoord) H() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s UTMCoord) SetH(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// UTMCoord_List is a list of UTMCoord.
type UTMCoord_List = capnp.StructList[UTMCoord]

// NewUTMCoord creates a new list of UTMCoord.
func NewUTMCoord_List(s *capnp.Segment, sz int32) (UTMCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[UTMCoord](l), err
}

// UTMCoord_Future is a wrapper for a UTMCoord promised by a client call.
type UTMCoord_Future struct{ *capnp.Future }

func (f UTMCoord_Future) Struct() (UTMCoord, error) {
	p, err := f.Future.Ptr()
	return UTMCoord(p.Struct()), err
}

type LatLonCoord capnp.Struct

// LatLonCoord_TypeID is the unique identifier for the type LatLonCoord.
const LatLonCoord_TypeID = 0xecf1fc3039cc8ffb

func NewLatLonCoord(s *capnp.Segment) (LatLonCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LatLonCoord(st), err
}

func NewRootLatLonCoord(s *capnp.Segment) (LatLonCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LatLonCoord(st), err
}

func ReadRootLatLonCoord(msg *capnp.Message) (LatLonCoord, error) {
	root, err := msg.Root()
	return LatLonCoord(root.Struct()), err
}

func (s LatLonCoord) String() string {
	str, _ := text.Marshal(0xecf1fc3039cc8ffb, capnp.Struct(s))
	return str
}

func (s LatLonCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LatLonCoord) DecodeFromPtr(p capnp.Ptr) LatLonCoord {
	return LatLonCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LatLonCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LatLonCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LatLonCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LatLonCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LatLonCoord) Lat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s LatLonCoord) SetLat(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s LatLonCoord) Lon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s LatLonCoord) SetLon(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// LatLonCoord_List is a list of LatLonCoord.
type LatLonCoord_List = capnp.StructList[LatLonCoord]

// NewLatLonCoord creates a new list of LatLonCoord.
func NewLatLonCoord_List(s *capnp.Segment, sz int32) (LatLonCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[LatLonCoord](l), err
}

// LatLonCoord_Future is a wrapper for a LatLonCoord promised by a client call.
type LatLonCoord_Future struct{ *capnp.Future }

func (f LatLonCoord_Future) Struct() (LatLonCoord, error) {
	p, err := f.Future.Ptr()
	return LatLonCoord(p.Struct()), err
}

type GKCoord capnp.Struct

// GKCoord_TypeID is the unique identifier for the type GKCoord.
const GKCoord_TypeID = 0x97ff7d61786091ae

func NewGKCoord(s *capnp.Segment) (GKCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return GKCoord(st), err
}

func NewRootGKCoord(s *capnp.Segment) (GKCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return GKCoord(st), err
}

func ReadRootGKCoord(msg *capnp.Message) (GKCoord, error) {
	root, err := msg.Root()
	return GKCoord(root.Struct()), err
}

func (s GKCoord) String() string {
	str, _ := text.Marshal(0x97ff7d61786091ae, capnp.Struct(s))
	return str
}

func (s GKCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GKCoord) DecodeFromPtr(p capnp.Ptr) GKCoord {
	return GKCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GKCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GKCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GKCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GKCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GKCoord) MeridianNo() uint8 {
	return capnp.Struct(s).Uint8(0)
}

func (s GKCoord) SetMeridianNo(v uint8) {
	capnp.Struct(s).SetUint8(0, v)
}

func (s GKCoord) R() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s GKCoord) SetR(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s GKCoord) H() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s GKCoord) SetH(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// GKCoord_List is a list of GKCoord.
type GKCoord_List = capnp.StructList[GKCoord]

// NewGKCoord creates a new list of GKCoord.
func NewGKCoord_List(s *capnp.Segment, sz int32) (GKCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0}, sz)
	return capnp.StructList[GKCoord](l), err
}

// GKCoord_Future is a wrapper for a GKCoord promised by a client call.
type GKCoord_Future struct{ *capnp.Future }

func (f GKCoord_Future) Struct() (GKCoord, error) {
	p, err := f.Future.Ptr()
	return GKCoord(p.Struct()), err
}

type Point2D capnp.Struct

// Point2D_TypeID is the unique identifier for the type Point2D.
const Point2D_TypeID = 0xc88fb91c1e6986e2

func NewPoint2D(s *capnp.Segment) (Point2D, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point2D(st), err
}

func NewRootPoint2D(s *capnp.Segment) (Point2D, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point2D(st), err
}

func ReadRootPoint2D(msg *capnp.Message) (Point2D, error) {
	root, err := msg.Root()
	return Point2D(root.Struct()), err
}

func (s Point2D) String() string {
	str, _ := text.Marshal(0xc88fb91c1e6986e2, capnp.Struct(s))
	return str
}

func (s Point2D) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Point2D) DecodeFromPtr(p capnp.Ptr) Point2D {
	return Point2D(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Point2D) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Point2D) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Point2D) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Point2D) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Point2D) X() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Point2D) SetX(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Point2D) Y() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Point2D) SetY(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Point2D_List is a list of Point2D.
type Point2D_List = capnp.StructList[Point2D]

// NewPoint2D creates a new list of Point2D.
func NewPoint2D_List(s *capnp.Segment, sz int32) (Point2D_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Point2D](l), err
}

// Point2D_Future is a wrapper for a Point2D promised by a client call.
type Point2D_Future struct{ *capnp.Future }

func (f Point2D_Future) Struct() (Point2D, error) {
	p, err := f.Future.Ptr()
	return Point2D(p.Struct()), err
}

type RowCol capnp.Struct

// RowCol_TypeID is the unique identifier for the type RowCol.
const RowCol_TypeID = 0xb0c6993e13e314ad

func NewRowCol(s *capnp.Segment) (RowCol, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return RowCol(st), err
}

func NewRootRowCol(s *capnp.Segment) (RowCol, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return RowCol(st), err
}

func ReadRootRowCol(msg *capnp.Message) (RowCol, error) {
	root, err := msg.Root()
	return RowCol(root.Struct()), err
}

func (s RowCol) String() string {
	str, _ := text.Marshal(0xb0c6993e13e314ad, capnp.Struct(s))
	return str
}

func (s RowCol) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RowCol) DecodeFromPtr(p capnp.Ptr) RowCol {
	return RowCol(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RowCol) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RowCol) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RowCol) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RowCol) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RowCol) Row() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s RowCol) SetRow(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s RowCol) Col() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s RowCol) SetCol(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

// RowCol_List is a list of RowCol.
type RowCol_List = capnp.StructList[RowCol]

// NewRowCol creates a new list of RowCol.
func NewRowCol_List(s *capnp.Segment, sz int32) (RowCol_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[RowCol](l), err
}

// RowCol_Future is a wrapper for a RowCol promised by a client call.
type RowCol_Future struct{ *capnp.Future }

func (f RowCol_Future) Struct() (RowCol, error) {
	p, err := f.Future.Ptr()
	return RowCol(p.Struct()), err
}

type Coord capnp.Struct
type Coord_Which uint16

const (
	Coord_Which_gk     Coord_Which = 0
	Coord_Which_latlon Coord_Which = 1
	Coord_Which_utm    Coord_Which = 2
	Coord_Which_p2D    Coord_Which = 3
	Coord_Which_rowcol Coord_Which = 4
)

func (w Coord_Which) String() string {
	const s = "gklatlonutmp2Drowcol"
	switch w {
	case Coord_Which_gk:
		return s[0:2]
	case Coord_Which_latlon:
		return s[2:8]
	case Coord_Which_utm:
		return s[8:11]
	case Coord_Which_p2D:
		return s[11:14]
	case Coord_Which_rowcol:
		return s[14:20]

	}
	return "Coord_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Coord_TypeID is the unique identifier for the type Coord.
const Coord_TypeID = 0xb8f6a6192a7359f8

func NewCoord(s *capnp.Segment) (Coord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Coord(st), err
}

func NewRootCoord(s *capnp.Segment) (Coord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Coord(st), err
}

func ReadRootCoord(msg *capnp.Message) (Coord, error) {
	root, err := msg.Root()
	return Coord(root.Struct()), err
}

func (s Coord) String() string {
	str, _ := text.Marshal(0xb8f6a6192a7359f8, capnp.Struct(s))
	return str
}

func (s Coord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Coord) DecodeFromPtr(p capnp.Ptr) Coord {
	return Coord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Coord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Coord) Which() Coord_Which {
	return Coord_Which(capnp.Struct(s).Uint16(0))
}
func (s Coord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Coord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Coord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Coord) Gk() (GKCoord, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != gk")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return GKCoord(p.Struct()), err
}

func (s Coord) HasGk() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetGk(v GKCoord) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewGk sets the gk field to a newly
// allocated GKCoord struct, preferring placement in s's segment.
func (s Coord) NewGk() (GKCoord, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewGKCoord(capnp.Struct(s).Segment())
	if err != nil {
		return GKCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Latlon() (LatLonCoord, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != latlon")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return LatLonCoord(p.Struct()), err
}

func (s Coord) HasLatlon() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetLatlon(v LatLonCoord) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLatlon sets the latlon field to a newly
// allocated LatLonCoord struct, preferring placement in s's segment.
func (s Coord) NewLatlon() (LatLonCoord, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewLatLonCoord(capnp.Struct(s).Segment())
	if err != nil {
		return LatLonCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Utm() (UTMCoord, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != utm")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return UTMCoord(p.Struct()), err
}

func (s Coord) HasUtm() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetUtm(v UTMCoord) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewUtm sets the utm field to a newly
// allocated UTMCoord struct, preferring placement in s's segment.
func (s Coord) NewUtm() (UTMCoord, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := NewUTMCoord(capnp.Struct(s).Segment())
	if err != nil {
		return UTMCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) P2D() (Point2D, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != p2D")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Point2D(p.Struct()), err
}

func (s Coord) HasP2D() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetP2D(v Point2D) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewP2D sets the p2D field to a newly
// allocated Point2D struct, preferring placement in s's segment.
func (s Coord) NewP2D() (Point2D, error) {
	capnp.Struct(s).SetUint16(0, 3)
	ss, err := NewPoint2D(capnp.Struct(s).Segment())
	if err != nil {
		return Point2D{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Rowcol() (RowCol, error) {
	if capnp.Struct(s).Uint16(0) != 4 {
		panic("Which() != rowcol")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return RowCol(p.Struct()), err
}

func (s Coord) HasRowcol() bool {
	if capnp.Struct(s).Uint16(0) != 4 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetRowcol(v RowCol) error {
	capnp.Struct(s).SetUint16(0, 4)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRowcol sets the rowcol field to a newly
// allocated RowCol struct, preferring placement in s's segment.
func (s Coord) NewRowcol() (RowCol, error) {
	capnp.Struct(s).SetUint16(0, 4)
	ss, err := NewRowCol(capnp.Struct(s).Segment())
	if err != nil {
		return RowCol{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Coord_List is a list of Coord.
type Coord_List = capnp.StructList[Coord]

// NewCoord creates a new list of Coord.
func NewCoord_List(s *capnp.Segment, sz int32) (Coord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Coord](l), err
}

// Coord_Future is a wrapper for a Coord promised by a client call.
type Coord_Future struct{ *capnp.Future }

func (f Coord_Future) Struct() (Coord, error) {
	p, err := f.Future.Ptr()
	return Coord(p.Struct()), err
}
func (p Coord_Future) Gk() GKCoord_Future {
	return GKCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Latlon() LatLonCoord_Future {
	return LatLonCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Utm() UTMCoord_Future {
	return UTMCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) P2D() Point2D_Future {
	return Point2D_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Rowcol() RowCol_Future {
	return RowCol_Future{Future: p.Future.Field(0, nil)}
}

type RectBounds capnp.Struct

// RectBounds_TypeID is the unique identifier for the type RectBounds.
const RectBounds_TypeID = 0xb952dbe83866da4a

func NewRectBounds(s *capnp.Segment) (RectBounds, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RectBounds(st), err
}

func NewRootRectBounds(s *capnp.Segment) (RectBounds, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RectBounds(st), err
}

func ReadRootRectBounds(msg *capnp.Message) (RectBounds, error) {
	root, err := msg.Root()
	return RectBounds(root.Struct()), err
}

func (s RectBounds) String() string {
	str, _ := text.Marshal(0xb952dbe83866da4a, capnp.Struct(s))
	return str
}

func (s RectBounds) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RectBounds) DecodeFromPtr(p capnp.Ptr) RectBounds {
	return RectBounds(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RectBounds) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RectBounds) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RectBounds) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RectBounds) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RectBounds) Tl() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s RectBounds) HasTl() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s RectBounds) SetTl(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}
func (s RectBounds) Br() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s RectBounds) HasBr() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s RectBounds) SetBr(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// RectBounds_List is a list of RectBounds.
type RectBounds_List = capnp.StructList[RectBounds]

// NewRectBounds creates a new list of RectBounds.
func NewRectBounds_List(s *capnp.Segment, sz int32) (RectBounds_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[RectBounds](l), err
}

// RectBounds_Future is a wrapper for a RectBounds promised by a client call.
type RectBounds_Future struct{ *capnp.Future }

func (f RectBounds_Future) Struct() (RectBounds, error) {
	p, err := f.Future.Ptr()
	return RectBounds(p.Struct()), err
}
func (p RectBounds_Future) Tl() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p RectBounds_Future) Br() *capnp.Future {
	return p.Future.Field(1, nil)
}

const schema_9090542079c7fc24 = "x\xda\x9c\x94oh[e\x14\xc6\xcf\xf3\xbe\xc9n\xeb" +
	"\x925\xb77\x83\xad\xd8\xd5\x85\x0d\xed\xc4\xd9\xa6-\xcc" +
	"~\xb0s\x7f\xa8\xd3\xad\xf6]*\xa8\x88\x18\x97\x98\xc5" +
	"$\xf7\xded\xb7\xa4+\x8e)ls\x83\x8dmP\xa9" +
	"\x0a\"\x0aS\x10fe\x0a\xda~\x92!:\xc6\xf6\xc1" +
	"~t\xae\xe0\xd4\xd9\xb1\x0e,\xa2\x0c\xdaz\xe5\xbd7" +
	"\xffLRD\xc9\x87\xbc\x9c\xfb\xbb\xe7\x9e\xf3\x9c\xe7=" +
	"\x1d\xbbZ\xb7z:\xfd\xca\x0f\xc4\xf6\xde\xe3]a\xff" +
	"8\xfeF\xba\x87\x9d|\x93T\xcdc\x7fuxr\xe0" +
	"\xa3\xfb\xc7\xbe \x82v+3\xa5\xcdg\x14\xa2\xc8\\" +
	"\x86#r7\xc3@d\x7fr\xf6\xc5\x91\xe8!{\x9c" +
	"\xc4*p{\xc3\xe2\xb7\x07\xef\x1b:s\x86<\x0a\x91" +
	"v+s\xc1}C\xbb\x93\x99 \xd8\xe7\x83?i\x8f" +
	"\xbe\xfd\xcd\xa7\x92eU\xec\x09\xfdc\xed\xac.O\xa7" +
	"\xf4<\xa1\xfceu\x15\xaa\xd3\xea\xefh\xf3z\x82\xb8" +
	"}\xf7\xd9\x03\x9b\xd6~\xf8\xe7\x972a\x05\xb5\x13\x8a" +
	"\x97H[m|\xa0\xb5\x1a\x0aQ\xd7Z\xa3\x0d\x04\xfb" +
	"\x89\xef_\xde2{m\xef\xe4?sz\x99\x12\x80\xd6" +
	"n^\xd6zL\x99\xbe\xd3\xcc\x13i\xe7\xcc&\xfb\xc6" +
	"\xb1\xe4\xba{'O_\xaaW\xef\xbb\xe6\x05\xed\x9c\xc3" +
	"\xbfo\xcaz\x8f6\xf4\xaf{+\xb2p\xa9F\xb6%" +
	"sZk\xccJ\xd9<Y\x8eH \xeb\xc8\xf6\xfb\x8d" +
	"\xf1\xb1\x9b3\x89+58\xb2\xd3\x9a\xdf\xc1\x1b$\x1e" +
	"t\xf1C\x0f\xbe7\xf2ul\xe2j\x0d\xee\xcd^\xd6" +
	"T\x07\xf7I|\x8d\x8b\xb7\x8a\x8b3\xd7\xafO\xfc\\" +
	"\x837f\xa7\xea\xe0\xb3s\xa1\xcff>o\xff\x85\xd4" +
	"U\x15m:\xf8E\x17\xd7\xfc\xd9\xa7\x08\xf6\xae\xdf\xb6" +
	"\xbe\xb0\xf1j\xcb\xed\xaaa{!\x91\xf5\xd9)\xad\xdd" +
	"\x817f\x7f%\xd8\x0b\xa7\xaf<\xd2\xb18?WO" +
	"\xbd\xa5\xec\xb4\xd6\x98\x93'oN\xaaw\xec\xfc\x16\xb3" +
	"cv\xf2\x8f\x9a\x82\xa3\xb9)-)\xc1H,\xc7\x11" +
	"1s\x0cd\xff\x8f\xdf5;\x117\x1eN\xc4\x8d\xcd" +
	"\xd8\x175u\xb3w\xe7`_\xa4\x7fs\"\xd53\x08" +
	"\xa0\x81Xg\xc3\x9dQB5\xd5\xffd\xdbv\xc3\xc8" +
	"\xc5\x06\x01\xe1\xe3\x1e\"\x0f\x88\xd4\x9d\xcf\x11\x89\x1d\x1c" +
	"b\x90A\x05\x82\x90\xc1=\xcdD\xe2q\x0e1\xc4\xa0" +
	"2\x16\x04#R\x85\x0c\xee\xe6\x10\xcf0\xd8\x99x." +
	"\x19KFu\xe2\x03\x06V\x10\xc3\x0a\x02rXI\x0c" +
	"+\x09\xd8_<U\x17\xb1\xd7h\xcao7\xd2\xb2\x86" +
	"\x86R\x0d\xed!\"\xb1\x81CtT\xd4\xf0\x90\x0c>" +
	"\xc0!\xba\x19\x94\x9c\x91G#14\x12\x94}F\xba" +
	"x\xae\x15\x82G\xfa\xc5\x1a\xa0\xc2d\xed\xe1\x0a?o" +
	"\xec\xadp\xeb\xfa\xde\x8a\x05\xd1\x1a\xaap\xda\xdaP\xc5" +
	"\x14W\x87\xda\xf2\x89\x03[\xba\xfb\x86\xadL\xb83\"" +
	"\xff\xba\xc2\x03J\"\xd5\xa3$R\xddJ\"\xd5U]" +
	"\xc6vC)\xe8\x1c\xe4\x1e\x9fm;M\x1ej!\x12" +
	"#\x1c\xe2\x08\x83\x1f\x7f\xd9n\x97\xaf\xf7\x12\x89W9" +
	"\xc4q\x06?[\xb2]\xa9\x8f\xca\xde_\xe3\x10'\x19" +
	"\xfc|\xd1\x0e\x82\x13\xa9'd\xf4\x08\x878\xc3\xe0\xf7" +
	",\xd8Ax\x88\xd4S2\xc3q\x0e1\xc6\xc0\x13)" +
	"\x04\xcak\x8c\x80\x00\xa1/\x1d\xb5\xd2\x86\x8e@\xd9\xc5" +
	"\xee\x03e\xd8\xca P\xbe\x08\x85\xa8\x19\xde\x81@y" +
	"_\x14\x92\xe4\x8c\xbc\x14>P^|\xee\x83R\xef\xac" +
	"0\xe0\xf8>k\x9b1\xac\xc7\x0e\x10UM\xb9\xa5\xde" +
	"\x94[\xcaS\xe6V\x1a\xcd\xa8XmDh&\xf0\x97" +
	"r\xf5\xc2\x8fy\xa0b\xd4v,\x9d\xd4\xa3\xd4g\xc5" +
	"\x87\x0e\x9a\xf1\xeaY\x0c\x1amI\xdd\x0a\xef\xa8\xaa\xa5" +
	"\xb9^-\xcd\xe5Z0R\xf2\xf2\xc1\x1a/\xb3\xa2\xdb" +
	"\"\xfd\x9b\x1dS R\xbay\xdf\x1d^\x1e\xec\x0ac" +
	"\xa0\x04\xce\xc6\x96\x01\x1d\xb39\xe2\xb9\xe0\xcd@=\xa3" +
	"\xbb7\xbe\xbbD\xcd\x8d\xd6\xa6s\xb4\x91\xa28\x93\xf0" +
	"9\xd6jm\x91\x83SW\x87\x88\xc0T\x7f/\x11O" +
	"\xa4\xa4\x13\x0a6\xa9\xfe\xd2\xd3C}{Jk#P" +
	"\x120\xba\x89H<\xcf!\xf63\x14\xf5\x8b\xbfB$" +
	"b\x1c\xc2\x94[\x03\xae\x953R\xd4\xfd\x1c\xc2bP" +
	"9s\x9d\x9c\x95\xc14\x87\x18ah\x1a5\xf4xq" +
	"\x85\xd8\xe9\xa8\x95\xb4\x86cqj\xda\x16\xd5c\xf0\x11" +
	"\x83\xef_6K\xa1\xd9\xddQk\xb7\xa1\xcbR\x11\xfb" +
	"\xaf\xeb%\x1d\xb5\x8ai\x15yU\x96Y^E\xd5\xbb" +
	"J\xaa\xdf\x1e%\xfc\x1d\x00\x00\xff\xff\xe3dM\xe2"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_9090542079c7fc24,
		Nodes: []uint64{
			0x958c02356c8797e1,
			0x97ff7d61786091ae,
			0xb0c6993e13e314ad,
			0xb79427a74eb97fc0,
			0xb8f6a6192a7359f8,
			0xb952dbe83866da4a,
			0xc88fb91c1e6986e2,
			0xc8fb53981e470885,
			0xcc67dee69497e2f3,
			0xcdaf64c4789f2b7d,
			0xe4afdddddec2511d,
			0xe529b4deb322ece8,
			0xeb1acd255e40f049,
			0xecf1fc3039cc8ffb,
			0xf5b9e8307038ad86,
		},
		Compressed: true,
	})
}
