// Code generated by capnpc-go. DO NOT EDIT.

package geo

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

// Constants defined in geo.capnp.
const (
	EPSG_wgs84  = uint32(4326)
	EPSG_utm21S = uint32(32721)
	EPSG_utm32N = uint32(25832)
	EPSG_gk5    = uint32(31469)
	EPSG_gk4    = uint32(31468)
	EPSG_gk3    = uint32(31467)
)

type CoordType uint16

// CoordType_TypeID is the unique identifier for the type CoordType.
const CoordType_TypeID = 0xe529b4deb322ece8

// Values of CoordType.
const (
	CoordType_gk     CoordType = 0
	CoordType_utm    CoordType = 1
	CoordType_latlon CoordType = 2
)

// String returns the enum's constant name.
func (c CoordType) String() string {
	switch c {
	case CoordType_gk:
		return "gk"
	case CoordType_utm:
		return "utm"
	case CoordType_latlon:
		return "latlon"

	default:
		return ""
	}
}

// CoordTypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func CoordTypeFromString(c string) CoordType {
	switch c {
	case "gk":
		return CoordType_gk
	case "utm":
		return CoordType_utm
	case "latlon":
		return CoordType_latlon

	default:
		return 0
	}
}

type CoordType_List = capnp.EnumList[CoordType]

func NewCoordType_List(s *capnp.Segment, sz int32) (CoordType_List, error) {
	return capnp.NewEnumList[CoordType](s, sz)
}

type EPSG capnp.Struct

// EPSG_TypeID is the unique identifier for the type EPSG.
const EPSG_TypeID = 0xb79427a74eb97fc0

func NewEPSG(s *capnp.Segment) (EPSG, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EPSG(st), err
}

func NewRootEPSG(s *capnp.Segment) (EPSG, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EPSG(st), err
}

func ReadRootEPSG(msg *capnp.Message) (EPSG, error) {
	root, err := msg.Root()
	return EPSG(root.Struct()), err
}

func (s EPSG) String() string {
	str, _ := text.Marshal(0xb79427a74eb97fc0, capnp.Struct(s))
	return str
}

func (s EPSG) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (EPSG) DecodeFromPtr(p capnp.Ptr) EPSG {
	return EPSG(capnp.Struct{}.DecodeFromPtr(p))
}

func (s EPSG) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s EPSG) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s EPSG) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s EPSG) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// EPSG_List is a list of EPSG.
type EPSG_List = capnp.StructList[EPSG]

// NewEPSG creates a new list of EPSG.
func NewEPSG_List(s *capnp.Segment, sz int32) (EPSG_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[EPSG](l), err
}

// EPSG_Future is a wrapper for a EPSG promised by a client call.
type EPSG_Future struct{ *capnp.Future }

func (f EPSG_Future) Struct() (EPSG, error) {
	p, err := f.Future.Ptr()
	return EPSG(p.Struct()), err
}

type UTMCoord capnp.Struct

// UTMCoord_TypeID is the unique identifier for the type UTMCoord.
const UTMCoord_TypeID = 0xeb1acd255e40f049

func NewUTMCoord(s *capnp.Segment) (UTMCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return UTMCoord(st), err
}

func NewRootUTMCoord(s *capnp.Segment) (UTMCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return UTMCoord(st), err
}

func ReadRootUTMCoord(msg *capnp.Message) (UTMCoord, error) {
	root, err := msg.Root()
	return UTMCoord(root.Struct()), err
}

func (s UTMCoord) String() string {
	str, _ := text.Marshal(0xeb1acd255e40f049, capnp.Struct(s))
	return str
}

func (s UTMCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (UTMCoord) DecodeFromPtr(p capnp.Ptr) UTMCoord {
	return UTMCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s UTMCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s UTMCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s UTMCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s UTMCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s UTMCoord) Zone() uint8 {
	return capnp.Struct(s).Uint8(0)
}

func (s UTMCoord) SetZone(v uint8) {
	capnp.Struct(s).SetUint8(0, v)
}

func (s UTMCoord) LatitudeBand() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s UTMCoord) HasLatitudeBand() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s UTMCoord) LatitudeBandBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s UTMCoord) SetLatitudeBand(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s UTMCoord) R() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s UTMCoord) SetR(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s UTMCoord) H() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s UTMCoord) SetH(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// UTMCoord_List is a list of UTMCoord.
type UTMCoord_List = capnp.StructList[UTMCoord]

// NewUTMCoord creates a new list of UTMCoord.
func NewUTMCoord_List(s *capnp.Segment, sz int32) (UTMCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[UTMCoord](l), err
}

// UTMCoord_Future is a wrapper for a UTMCoord promised by a client call.
type UTMCoord_Future struct{ *capnp.Future }

func (f UTMCoord_Future) Struct() (UTMCoord, error) {
	p, err := f.Future.Ptr()
	return UTMCoord(p.Struct()), err
}

type LatLonCoord capnp.Struct

// LatLonCoord_TypeID is the unique identifier for the type LatLonCoord.
const LatLonCoord_TypeID = 0xecf1fc3039cc8ffb

func NewLatLonCoord(s *capnp.Segment) (LatLonCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LatLonCoord(st), err
}

func NewRootLatLonCoord(s *capnp.Segment) (LatLonCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LatLonCoord(st), err
}

func ReadRootLatLonCoord(msg *capnp.Message) (LatLonCoord, error) {
	root, err := msg.Root()
	return LatLonCoord(root.Struct()), err
}

func (s LatLonCoord) String() string {
	str, _ := text.Marshal(0xecf1fc3039cc8ffb, capnp.Struct(s))
	return str
}

func (s LatLonCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LatLonCoord) DecodeFromPtr(p capnp.Ptr) LatLonCoord {
	return LatLonCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LatLonCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LatLonCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LatLonCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LatLonCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LatLonCoord) Lat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s LatLonCoord) SetLat(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s LatLonCoord) Lon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s LatLonCoord) SetLon(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// LatLonCoord_List is a list of LatLonCoord.
type LatLonCoord_List = capnp.StructList[LatLonCoord]

// NewLatLonCoord creates a new list of LatLonCoord.
func NewLatLonCoord_List(s *capnp.Segment, sz int32) (LatLonCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[LatLonCoord](l), err
}

// LatLonCoord_Future is a wrapper for a LatLonCoord promised by a client call.
type LatLonCoord_Future struct{ *capnp.Future }

func (f LatLonCoord_Future) Struct() (LatLonCoord, error) {
	p, err := f.Future.Ptr()
	return LatLonCoord(p.Struct()), err
}

type GKCoord capnp.Struct

// GKCoord_TypeID is the unique identifier for the type GKCoord.
const GKCoord_TypeID = 0x97ff7d61786091ae

func NewGKCoord(s *capnp.Segment) (GKCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return GKCoord(st), err
}

func NewRootGKCoord(s *capnp.Segment) (GKCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return GKCoord(st), err
}

func ReadRootGKCoord(msg *capnp.Message) (GKCoord, error) {
	root, err := msg.Root()
	return GKCoord(root.Struct()), err
}

func (s GKCoord) String() string {
	str, _ := text.Marshal(0x97ff7d61786091ae, capnp.Struct(s))
	return str
}

func (s GKCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GKCoord) DecodeFromPtr(p capnp.Ptr) GKCoord {
	return GKCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GKCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GKCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GKCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GKCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GKCoord) MeridianNo() uint8 {
	return capnp.Struct(s).Uint8(0)
}

func (s GKCoord) SetMeridianNo(v uint8) {
	capnp.Struct(s).SetUint8(0, v)
}

func (s GKCoord) R() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s GKCoord) SetR(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s GKCoord) H() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s GKCoord) SetH(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// GKCoord_List is a list of GKCoord.
type GKCoord_List = capnp.StructList[GKCoord]

// NewGKCoord creates a new list of GKCoord.
func NewGKCoord_List(s *capnp.Segment, sz int32) (GKCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0}, sz)
	return capnp.StructList[GKCoord](l), err
}

// GKCoord_Future is a wrapper for a GKCoord promised by a client call.
type GKCoord_Future struct{ *capnp.Future }

func (f GKCoord_Future) Struct() (GKCoord, error) {
	p, err := f.Future.Ptr()
	return GKCoord(p.Struct()), err
}

type Point2D capnp.Struct

// Point2D_TypeID is the unique identifier for the type Point2D.
const Point2D_TypeID = 0xc88fb91c1e6986e2

func NewPoint2D(s *capnp.Segment) (Point2D, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point2D(st), err
}

func NewRootPoint2D(s *capnp.Segment) (Point2D, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point2D(st), err
}

func ReadRootPoint2D(msg *capnp.Message) (Point2D, error) {
	root, err := msg.Root()
	return Point2D(root.Struct()), err
}

func (s Point2D) String() string {
	str, _ := text.Marshal(0xc88fb91c1e6986e2, capnp.Struct(s))
	return str
}

func (s Point2D) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Point2D) DecodeFromPtr(p capnp.Ptr) Point2D {
	return Point2D(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Point2D) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Point2D) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Point2D) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Point2D) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Point2D) X() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Point2D) SetX(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Point2D) Y() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Point2D) SetY(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Point2D_List is a list of Point2D.
type Point2D_List = capnp.StructList[Point2D]

// NewPoint2D creates a new list of Point2D.
func NewPoint2D_List(s *capnp.Segment, sz int32) (Point2D_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Point2D](l), err
}

// Point2D_Future is a wrapper for a Point2D promised by a client call.
type Point2D_Future struct{ *capnp.Future }

func (f Point2D_Future) Struct() (Point2D, error) {
	p, err := f.Future.Ptr()
	return Point2D(p.Struct()), err
}

type RowCol capnp.Struct

// RowCol_TypeID is the unique identifier for the type RowCol.
const RowCol_TypeID = 0xb0c6993e13e314ad

func NewRowCol(s *capnp.Segment) (RowCol, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return RowCol(st), err
}

func NewRootRowCol(s *capnp.Segment) (RowCol, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return RowCol(st), err
}

func ReadRootRowCol(msg *capnp.Message) (RowCol, error) {
	root, err := msg.Root()
	return RowCol(root.Struct()), err
}

func (s RowCol) String() string {
	str, _ := text.Marshal(0xb0c6993e13e314ad, capnp.Struct(s))
	return str
}

func (s RowCol) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RowCol) DecodeFromPtr(p capnp.Ptr) RowCol {
	return RowCol(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RowCol) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RowCol) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RowCol) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RowCol) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RowCol) Row() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s RowCol) SetRow(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s RowCol) Col() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s RowCol) SetCol(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

// RowCol_List is a list of RowCol.
type RowCol_List = capnp.StructList[RowCol]

// NewRowCol creates a new list of RowCol.
func NewRowCol_List(s *capnp.Segment, sz int32) (RowCol_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[RowCol](l), err
}

// RowCol_Future is a wrapper for a RowCol promised by a client call.
type RowCol_Future struct{ *capnp.Future }

func (f RowCol_Future) Struct() (RowCol, error) {
	p, err := f.Future.Ptr()
	return RowCol(p.Struct()), err
}

type Coord capnp.Struct
type Coord_Which uint16

const (
	Coord_Which_gk     Coord_Which = 0
	Coord_Which_latlon Coord_Which = 1
	Coord_Which_utm    Coord_Which = 2
	Coord_Which_p2D    Coord_Which = 3
	Coord_Which_rowcol Coord_Which = 4
)

func (w Coord_Which) String() string {
	const s = "gklatlonutmp2Drowcol"
	switch w {
	case Coord_Which_gk:
		return s[0:2]
	case Coord_Which_latlon:
		return s[2:8]
	case Coord_Which_utm:
		return s[8:11]
	case Coord_Which_p2D:
		return s[11:14]
	case Coord_Which_rowcol:
		return s[14:20]

	}
	return "Coord_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Coord_TypeID is the unique identifier for the type Coord.
const Coord_TypeID = 0xb8f6a6192a7359f8

func NewCoord(s *capnp.Segment) (Coord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Coord(st), err
}

func NewRootCoord(s *capnp.Segment) (Coord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Coord(st), err
}

func ReadRootCoord(msg *capnp.Message) (Coord, error) {
	root, err := msg.Root()
	return Coord(root.Struct()), err
}

func (s Coord) String() string {
	str, _ := text.Marshal(0xb8f6a6192a7359f8, capnp.Struct(s))
	return str
}

func (s Coord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Coord) DecodeFromPtr(p capnp.Ptr) Coord {
	return Coord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Coord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Coord) Which() Coord_Which {
	return Coord_Which(capnp.Struct(s).Uint16(0))
}
func (s Coord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Coord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Coord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Coord) Gk() (GKCoord, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != gk")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return GKCoord(p.Struct()), err
}

func (s Coord) HasGk() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetGk(v GKCoord) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewGk sets the gk field to a newly
// allocated GKCoord struct, preferring placement in s's segment.
func (s Coord) NewGk() (GKCoord, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewGKCoord(capnp.Struct(s).Segment())
	if err != nil {
		return GKCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Latlon() (LatLonCoord, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != latlon")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return LatLonCoord(p.Struct()), err
}

func (s Coord) HasLatlon() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetLatlon(v LatLonCoord) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLatlon sets the latlon field to a newly
// allocated LatLonCoord struct, preferring placement in s's segment.
func (s Coord) NewLatlon() (LatLonCoord, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewLatLonCoord(capnp.Struct(s).Segment())
	if err != nil {
		return LatLonCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Utm() (UTMCoord, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != utm")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return UTMCoord(p.Struct()), err
}

func (s Coord) HasUtm() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetUtm(v UTMCoord) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewUtm sets the utm field to a newly
// allocated UTMCoord struct, preferring placement in s's segment.
func (s Coord) NewUtm() (UTMCoord, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := NewUTMCoord(capnp.Struct(s).Segment())
	if err != nil {
		return UTMCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) P2D() (Point2D, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != p2D")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Point2D(p.Struct()), err
}

func (s Coord) HasP2D() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetP2D(v Point2D) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewP2D sets the p2D field to a newly
// allocated Point2D struct, preferring placement in s's segment.
func (s Coord) NewP2D() (Point2D, error) {
	capnp.Struct(s).SetUint16(0, 3)
	ss, err := NewPoint2D(capnp.Struct(s).Segment())
	if err != nil {
		return Point2D{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Rowcol() (RowCol, error) {
	if capnp.Struct(s).Uint16(0) != 4 {
		panic("Which() != rowcol")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return RowCol(p.Struct()), err
}

func (s Coord) HasRowcol() bool {
	if capnp.Struct(s).Uint16(0) != 4 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetRowcol(v RowCol) error {
	capnp.Struct(s).SetUint16(0, 4)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRowcol sets the rowcol field to a newly
// allocated RowCol struct, preferring placement in s's segment.
func (s Coord) NewRowcol() (RowCol, error) {
	capnp.Struct(s).SetUint16(0, 4)
	ss, err := NewRowCol(capnp.Struct(s).Segment())
	if err != nil {
		return RowCol{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Coord_List is a list of Coord.
type Coord_List = capnp.StructList[Coord]

// NewCoord creates a new list of Coord.
func NewCoord_List(s *capnp.Segment, sz int32) (Coord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Coord](l), err
}

// Coord_Future is a wrapper for a Coord promised by a client call.
type Coord_Future struct{ *capnp.Future }

func (f Coord_Future) Struct() (Coord, error) {
	p, err := f.Future.Ptr()
	return Coord(p.Struct()), err
}
func (p Coord_Future) Gk() GKCoord_Future {
	return GKCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Latlon() LatLonCoord_Future {
	return LatLonCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Utm() UTMCoord_Future {
	return UTMCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) P2D() Point2D_Future {
	return Point2D_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Rowcol() RowCol_Future {
	return RowCol_Future{Future: p.Future.Field(0, nil)}
}

type RectBounds capnp.Struct

// RectBounds_TypeID is the unique identifier for the type RectBounds.
const RectBounds_TypeID = 0xb952dbe83866da4a

func NewRectBounds(s *capnp.Segment) (RectBounds, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RectBounds(st), err
}

func NewRootRectBounds(s *capnp.Segment) (RectBounds, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RectBounds(st), err
}

func ReadRootRectBounds(msg *capnp.Message) (RectBounds, error) {
	root, err := msg.Root()
	return RectBounds(root.Struct()), err
}

func (s RectBounds) String() string {
	str, _ := text.Marshal(0xb952dbe83866da4a, capnp.Struct(s))
	return str
}

func (s RectBounds) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RectBounds) DecodeFromPtr(p capnp.Ptr) RectBounds {
	return RectBounds(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RectBounds) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RectBounds) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RectBounds) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RectBounds) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RectBounds) Tl() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s RectBounds) HasTl() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s RectBounds) SetTl(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}
func (s RectBounds) Br() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s RectBounds) HasBr() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s RectBounds) SetBr(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// RectBounds_List is a list of RectBounds.
type RectBounds_List = capnp.StructList[RectBounds]

// NewRectBounds creates a new list of RectBounds.
func NewRectBounds_List(s *capnp.Segment, sz int32) (RectBounds_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[RectBounds](l), err
}

// RectBounds_Future is a wrapper for a RectBounds promised by a client call.
type RectBounds_Future struct{ *capnp.Future }

func (f RectBounds_Future) Struct() (RectBounds, error) {
	p, err := f.Future.Ptr()
	return RectBounds(p.Struct()), err
}
func (p RectBounds_Future) Tl() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p RectBounds_Future) Br() *capnp.Future {
	return p.Future.Field(1, nil)
}

const schema_9090542079c7fc24 = "x\xda\x9c\x94_L\x1c\xd5\x17\xc7\xcf\xb9w\xe9\xd0\x94" +
	"\x85\x1df\x9b\xfcJ~\x14\xdd\xb4QjDX \x01" +
	"\xa2R\x0a\x84\xaa\x80\xdc\x0e$\xc5\xb4\xa6+\xbb.\xeb" +
	"\xee\xfc\xd9e\xc8\x02\x91\xd4&\xa5\xd6\xa4\xa6\x98`P" +
	"_L|\xb0\x89IEk\x13\x85\xa7\xa61\xda4\xed" +
	"\x83\xbcY\x03I\xabV\x92\xd2\xa4\x8d\xc1\x98\x80^s" +
	"g\xf6\x9f\xbbK\x8c\x86\x07&g>{\xe6{\xbf\xe7" +
	"{O}u\xf5AW\x83\xfb\xc2- \xea\x83\x9d%" +
	";\xf8\xed\xf97c\xcd\xe4\xdc\xbb +.~\xe5\xe4" +
	"b\xff\x85\xc7\xe6\xbe\x04@\xa5U[R:4\x09@" +
	"}Z\xa3\xa8\x1e\xd6\x08\x02\xf0O\xdf91\x11\x98\xe6" +
	"\xf3\xc0\xca\x91\xf2}[\xdfN>28;\x0b.\x09" +
	"@i\xd5.9\xbfP\x9e\xd1\x16\x00\xf9E\xef\x8f\xca" +
	"\xb3\xef\x7f\xf3\x99`I\x1e\xfb\xbd\xf6\x89r\xdbfW" +
	"\xb4$`\xf6\xcbr9\xe6\xb7\xd5?P:\xf40P" +
	"\xfe\xfb\xf0\xd8\x81=\x1f\xff\xf6\x95h\x98Cu\xa3T" +
	"\x02\xa0\x84\xf4\x8f\x14M\x97\x00\x1a#z\x0d\x02\xf2\xe7" +
	"o\xbd\xda\xb2\xf6\xc3\x91\xc5\xbf\xf7,!\x92\x07\x95I" +
	"\xe3\xba2c\x88\xf6\xa7\x8c$\x80\xb2aT\xf0;g" +
	"\"{\xff\xbfx\xfeZ1\xbd\xf7\x8dK\xca\x86\xcd?" +
	"4\x84\xde\x99\xd2\x9e\xbd\xef\xa9\x9b\xd7\x0al\xeb3\x97" +
	"\x95aS\xd86hRTO\x98\xb6m\xbf\xde\x99\x9f" +
	"\xbb\xbb\x1a\xbeQ\x803sY9n\xe3G\x05\x1et" +
	"\xf0\xe9'>\x9c\xf8:\xb8p\xb3\x00\x1f2\xaf+\x01" +
	"\x1b?&\xf0Q\x07\xaffWWWV\x16~*\xc0" +
	"\x87\xcd\xa5\"\xf8\xda\xba\xef\x8b\xd5\xcb\xb5?\x83\\\x9e" +
	"sL\x1b\xbf\xea\xe0\xcaq\xf3E@\xfe\xdc\x83\x83/" +
	"\xef\xbfYu/o\xd8%(\x90\xb8\xb9\xa4L\xda\xf0" +
	"\xb8\xf9\x0b \xdf<\x7f\xa3\xb5~\xeb\xe1z1\xf7\xfa" +
	"\xe2\xcb\xcap\\<\x0d\xc5\x85{g.\xb6\x98\xf5k" +
	"\x8b\x1b\x05\x82?\x8f/)\x8b\x02T/\xc7)\xaaW" +
	"\xe2\x04\x81\xff\x87\xbf\x05\x1e\x0e\x19O\x85CF\x1d\x8e" +
	"\x04L\xddl\xeb\x1ehW{\xea\xc2\xd1\xe6\x01D," +
	"\x05\xd2Pz\x7f\x0a0\x9f\xeay\xa1\xa6\xd30\x12\xc1" +
	"\x01DVF]\x00.\x04\x90\xbb_\x02`]\x14\xd9" +
	"\x00A\x19\xd1\x8b\xa2\xd8W\x09\xc0\x0eSd\x83\x04e" +
	"B\xbcH\x00d&\x8a\xbd\x14\xd9Q\x82\\\x0b%\"" +
	"\xc1H@\x07\xdao\xe0\x0e \xb8\x03\x10\x13\xb8\x0b\x08" +
	"\xee\x02\xc4\xd1\xf4S\xbe\x88#FE\xb2\xd3\x88\x09\x0d" +
	"\xa5\x19\x0d\xb5>\x00\xb6\x8f\"\xab\xcf\xd1\xf0\xa4(>" +
	"N\x915\x11\x94\x12F\x12w\x02\xc1\x9d\x80\xd2\x88\x11" +
	"K?\x17\x1aA\xd5\x1e\xf6?\xc4\x9c\x90\xd5\xfas\xf2" +
	"\xbc\xbf-'\xad\x8f\xb6\xe5,\x88j_N\xd2\xf6\xf8" +
	"r\xa6\xb8\xdbW\x93\x0c\x8f\xb54\xb5\x8f[\x9a\xbfA" +
	"\x15\xff\x1a\xfd\xfdR8\xda,\x85\xa3MR8\xda\x98" +
	"/\xa3\xd3\x90R>{\xa9\xab\x8cs\xfb\x90\xd3U\x00" +
	"l\x82\";M\xd0\x8d\x7fr\xe7\x94\xa7\xda\x00\xd8\xeb" +
	"\x14\xd9Y\x82n\xf2\x07w\xac\x9e\x11g\x7f\x83\";" +
	"G\xd0M\xb7\xb8\x17)\x80\xfc\x96\xa8\x9e\xa6\xc8f\x09" +
	"\xba]\x9b\xdc\x8b.\x00\xf9m\xd1\xe1,E6G\x90" +
	"\x86\xa3\xe8\xc9\xae1@\xf4\x00\xb6\xc7\x02V\xcc\xd0\xd1" +
	"\x93M\xb1\xf3B\x1a\xb74\xf4d/B\xaaj\xfa\xbb" +
	"\xd0\x93\xdd\x17\xa9&\x09#)\x8c\xf7d\x17\x9f\xf3\"" +
	"sv\x92\x1aph\xc4:d\x8c\xeb\xc11\x80\xbc)" +
	"W\x15\x9brUv\xca\xd4\x8aa%\xe6\xac6\x00\xac" +
	"\x04\xa4\xaf$\x8a\x95;\\(\xe3\x14\xb7#\x1d\xd1\x03" +
	"\xd0n\x85\x06'\xcdP\xfe,\x06\x8c\x9a\x88n\xf9\xbb" +
	"\xf2\xb4T\x16\xd3R\x99\xd5\x82\x13\x99,O\x16d\x99" +
	"\xa4\xd3\xa6\xf6\xd4\xd9\xa1@5s\xf3\xbe;\xb9=\xd8" +
	"\xe8\xc7\xfe\x0c\xb8\x16\xdc\x06\xb4\xc3f\x9b\xe7\x80w=" +
	"\xc5\x82\xee\xdc\xf8\xa6\x0c\xb5>U\xd8\xce\xf6F\x98b" +
	"O\xa2\xcc\x8eVu\x95\x18\x9c\xbc\xdb\x07\x80Dv\xb7" +
	"\x01\xd0pT$!\x15\x93\xfc/\x0d\x0d\xb6\xf7e\xd6" +
	"\x86'c`\xe0\x00\x00;F\x91\x8d\x12L\xfb\x17z" +
	"\x0d\x80\x05)2Sl\x0dt\xa2\xac\x09SG)2" +
	"\x8b\xa0L\x89\x93\xe4\xb8(\xc6(\xb2\x09\x82\x15S\x86" +
	"\x1eJ\xaf\x10\x1e\x0bX\x11k<\x18\x82\x8aC\x01=" +
	"\x88e@\xb0\xec\x1f6K\xea\xb0\xbd\x01\xab\xd7\xd0\x85" +
	"T\x0c\xfe\xdb\xf5\x12\x0bX\xe9\xb6\x92\xb8*\xdb,\xaf" +
	"\xb4\xeb\x8d\x19\xd7\xefM\x01\xfe\x15\x00\x00\xff\xffe\x06" +
	"S\xe0"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_9090542079c7fc24,
		Nodes: []uint64{
			0x958c02356c8797e1,
			0x97ff7d61786091ae,
			0xb0c6993e13e314ad,
			0xb79427a74eb97fc0,
			0xb8f6a6192a7359f8,
			0xb952dbe83866da4a,
			0xc88fb91c1e6986e2,
			0xc8fb53981e470885,
			0xcc67dee69497e2f3,
			0xcdaf64c4789f2b7d,
			0xe4afdddddec2511d,
			0xe529b4deb322ece8,
			0xeb1acd255e40f049,
			0xecf1fc3039cc8ffb,
			0xf5b9e8307038ad86,
		},
		Compressed: true,
	})
}
