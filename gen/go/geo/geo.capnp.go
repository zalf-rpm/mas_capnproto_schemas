// Code generated by capnpc-go. DO NOT EDIT.

package geo

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

// Constants defined in geo.capnp.
const (
	EPSG_wgs84  = uint32(4326)
	EPSG_utm21S = uint32(32721)
	EPSG_utm32N = uint32(25832)
	EPSG_gk5    = uint32(31469)
	EPSG_gk4    = uint32(31468)
	EPSG_gk3    = uint32(31467)
)

type CoordType uint16

// CoordType_TypeID is the unique identifier for the type CoordType.
const CoordType_TypeID = 0xe529b4deb322ece8

// Values of CoordType.
const (
	CoordType_gk     CoordType = 0
	CoordType_utm    CoordType = 1
	CoordType_latlon CoordType = 2
)

// String returns the enum's constant name.
func (c CoordType) String() string {
	switch c {
	case CoordType_gk:
		return "gk"
	case CoordType_utm:
		return "utm"
	case CoordType_latlon:
		return "latlon"

	default:
		return ""
	}
}

// CoordTypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func CoordTypeFromString(c string) CoordType {
	switch c {
	case "gk":
		return CoordType_gk
	case "utm":
		return CoordType_utm
	case "latlon":
		return CoordType_latlon

	default:
		return 0
	}
}

type CoordType_List = capnp.EnumList[CoordType]

func NewCoordType_List(s *capnp.Segment, sz int32) (CoordType_List, error) {
	return capnp.NewEnumList[CoordType](s, sz)
}

type EPSG capnp.Struct

// EPSG_TypeID is the unique identifier for the type EPSG.
const EPSG_TypeID = 0xb79427a74eb97fc0

func NewEPSG(s *capnp.Segment) (EPSG, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EPSG(st), err
}

func NewRootEPSG(s *capnp.Segment) (EPSG, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EPSG(st), err
}

func ReadRootEPSG(msg *capnp.Message) (EPSG, error) {
	root, err := msg.Root()
	return EPSG(root.Struct()), err
}

func (s EPSG) String() string {
	str, _ := text.Marshal(0xb79427a74eb97fc0, capnp.Struct(s))
	return str
}

func (s EPSG) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (EPSG) DecodeFromPtr(p capnp.Ptr) EPSG {
	return EPSG(capnp.Struct{}.DecodeFromPtr(p))
}

func (s EPSG) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s EPSG) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s EPSG) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s EPSG) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// EPSG_List is a list of EPSG.
type EPSG_List = capnp.StructList[EPSG]

// NewEPSG creates a new list of EPSG.
func NewEPSG_List(s *capnp.Segment, sz int32) (EPSG_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[EPSG](l), err
}

// EPSG_Future is a wrapper for a EPSG promised by a client call.
type EPSG_Future struct{ *capnp.Future }

func (f EPSG_Future) Struct() (EPSG, error) {
	p, err := f.Future.Ptr()
	return EPSG(p.Struct()), err
}

type UTMCoord capnp.Struct

// UTMCoord_TypeID is the unique identifier for the type UTMCoord.
const UTMCoord_TypeID = 0xeb1acd255e40f049

func NewUTMCoord(s *capnp.Segment) (UTMCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return UTMCoord(st), err
}

func NewRootUTMCoord(s *capnp.Segment) (UTMCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return UTMCoord(st), err
}

func ReadRootUTMCoord(msg *capnp.Message) (UTMCoord, error) {
	root, err := msg.Root()
	return UTMCoord(root.Struct()), err
}

func (s UTMCoord) String() string {
	str, _ := text.Marshal(0xeb1acd255e40f049, capnp.Struct(s))
	return str
}

func (s UTMCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (UTMCoord) DecodeFromPtr(p capnp.Ptr) UTMCoord {
	return UTMCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s UTMCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s UTMCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s UTMCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s UTMCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s UTMCoord) Zone() uint8 {
	return capnp.Struct(s).Uint8(0)
}

func (s UTMCoord) SetZone(v uint8) {
	capnp.Struct(s).SetUint8(0, v)
}

func (s UTMCoord) LatitudeBand() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s UTMCoord) HasLatitudeBand() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s UTMCoord) LatitudeBandBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s UTMCoord) SetLatitudeBand(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s UTMCoord) R() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s UTMCoord) SetR(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s UTMCoord) H() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s UTMCoord) SetH(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// UTMCoord_List is a list of UTMCoord.
type UTMCoord_List = capnp.StructList[UTMCoord]

// NewUTMCoord creates a new list of UTMCoord.
func NewUTMCoord_List(s *capnp.Segment, sz int32) (UTMCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[UTMCoord](l), err
}

// UTMCoord_Future is a wrapper for a UTMCoord promised by a client call.
type UTMCoord_Future struct{ *capnp.Future }

func (f UTMCoord_Future) Struct() (UTMCoord, error) {
	p, err := f.Future.Ptr()
	return UTMCoord(p.Struct()), err
}

type LatLonCoord capnp.Struct

// LatLonCoord_TypeID is the unique identifier for the type LatLonCoord.
const LatLonCoord_TypeID = 0xecf1fc3039cc8ffb

func NewLatLonCoord(s *capnp.Segment) (LatLonCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LatLonCoord(st), err
}

func NewRootLatLonCoord(s *capnp.Segment) (LatLonCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LatLonCoord(st), err
}

func ReadRootLatLonCoord(msg *capnp.Message) (LatLonCoord, error) {
	root, err := msg.Root()
	return LatLonCoord(root.Struct()), err
}

func (s LatLonCoord) String() string {
	str, _ := text.Marshal(0xecf1fc3039cc8ffb, capnp.Struct(s))
	return str
}

func (s LatLonCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LatLonCoord) DecodeFromPtr(p capnp.Ptr) LatLonCoord {
	return LatLonCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LatLonCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LatLonCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LatLonCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LatLonCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LatLonCoord) Lat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s LatLonCoord) SetLat(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s LatLonCoord) Lon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s LatLonCoord) SetLon(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// LatLonCoord_List is a list of LatLonCoord.
type LatLonCoord_List = capnp.StructList[LatLonCoord]

// NewLatLonCoord creates a new list of LatLonCoord.
func NewLatLonCoord_List(s *capnp.Segment, sz int32) (LatLonCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[LatLonCoord](l), err
}

// LatLonCoord_Future is a wrapper for a LatLonCoord promised by a client call.
type LatLonCoord_Future struct{ *capnp.Future }

func (f LatLonCoord_Future) Struct() (LatLonCoord, error) {
	p, err := f.Future.Ptr()
	return LatLonCoord(p.Struct()), err
}

type GKCoord capnp.Struct

// GKCoord_TypeID is the unique identifier for the type GKCoord.
const GKCoord_TypeID = 0x97ff7d61786091ae

func NewGKCoord(s *capnp.Segment) (GKCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return GKCoord(st), err
}

func NewRootGKCoord(s *capnp.Segment) (GKCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return GKCoord(st), err
}

func ReadRootGKCoord(msg *capnp.Message) (GKCoord, error) {
	root, err := msg.Root()
	return GKCoord(root.Struct()), err
}

func (s GKCoord) String() string {
	str, _ := text.Marshal(0x97ff7d61786091ae, capnp.Struct(s))
	return str
}

func (s GKCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GKCoord) DecodeFromPtr(p capnp.Ptr) GKCoord {
	return GKCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GKCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GKCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GKCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GKCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GKCoord) MeridianNo() uint8 {
	return capnp.Struct(s).Uint8(0)
}

func (s GKCoord) SetMeridianNo(v uint8) {
	capnp.Struct(s).SetUint8(0, v)
}

func (s GKCoord) R() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s GKCoord) SetR(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s GKCoord) H() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s GKCoord) SetH(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// GKCoord_List is a list of GKCoord.
type GKCoord_List = capnp.StructList[GKCoord]

// NewGKCoord creates a new list of GKCoord.
func NewGKCoord_List(s *capnp.Segment, sz int32) (GKCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0}, sz)
	return capnp.StructList[GKCoord](l), err
}

// GKCoord_Future is a wrapper for a GKCoord promised by a client call.
type GKCoord_Future struct{ *capnp.Future }

func (f GKCoord_Future) Struct() (GKCoord, error) {
	p, err := f.Future.Ptr()
	return GKCoord(p.Struct()), err
}

type Point2D capnp.Struct

// Point2D_TypeID is the unique identifier for the type Point2D.
const Point2D_TypeID = 0xc88fb91c1e6986e2

func NewPoint2D(s *capnp.Segment) (Point2D, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point2D(st), err
}

func NewRootPoint2D(s *capnp.Segment) (Point2D, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point2D(st), err
}

func ReadRootPoint2D(msg *capnp.Message) (Point2D, error) {
	root, err := msg.Root()
	return Point2D(root.Struct()), err
}

func (s Point2D) String() string {
	str, _ := text.Marshal(0xc88fb91c1e6986e2, capnp.Struct(s))
	return str
}

func (s Point2D) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Point2D) DecodeFromPtr(p capnp.Ptr) Point2D {
	return Point2D(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Point2D) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Point2D) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Point2D) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Point2D) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Point2D) X() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Point2D) SetX(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Point2D) Y() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Point2D) SetY(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Point2D_List is a list of Point2D.
type Point2D_List = capnp.StructList[Point2D]

// NewPoint2D creates a new list of Point2D.
func NewPoint2D_List(s *capnp.Segment, sz int32) (Point2D_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Point2D](l), err
}

// Point2D_Future is a wrapper for a Point2D promised by a client call.
type Point2D_Future struct{ *capnp.Future }

func (f Point2D_Future) Struct() (Point2D, error) {
	p, err := f.Future.Ptr()
	return Point2D(p.Struct()), err
}

type RowCol capnp.Struct

// RowCol_TypeID is the unique identifier for the type RowCol.
const RowCol_TypeID = 0xb0c6993e13e314ad

func NewRowCol(s *capnp.Segment) (RowCol, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return RowCol(st), err
}

func NewRootRowCol(s *capnp.Segment) (RowCol, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return RowCol(st), err
}

func ReadRootRowCol(msg *capnp.Message) (RowCol, error) {
	root, err := msg.Root()
	return RowCol(root.Struct()), err
}

func (s RowCol) String() string {
	str, _ := text.Marshal(0xb0c6993e13e314ad, capnp.Struct(s))
	return str
}

func (s RowCol) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RowCol) DecodeFromPtr(p capnp.Ptr) RowCol {
	return RowCol(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RowCol) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RowCol) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RowCol) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RowCol) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RowCol) Row() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s RowCol) SetRow(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s RowCol) Col() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s RowCol) SetCol(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

// RowCol_List is a list of RowCol.
type RowCol_List = capnp.StructList[RowCol]

// NewRowCol creates a new list of RowCol.
func NewRowCol_List(s *capnp.Segment, sz int32) (RowCol_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[RowCol](l), err
}

// RowCol_Future is a wrapper for a RowCol promised by a client call.
type RowCol_Future struct{ *capnp.Future }

func (f RowCol_Future) Struct() (RowCol, error) {
	p, err := f.Future.Ptr()
	return RowCol(p.Struct()), err
}

type Coord capnp.Struct
type Coord_Which uint16

const (
	Coord_Which_gk     Coord_Which = 0
	Coord_Which_latlon Coord_Which = 1
	Coord_Which_utm    Coord_Which = 2
	Coord_Which_p2D    Coord_Which = 3
	Coord_Which_rowcol Coord_Which = 4
)

func (w Coord_Which) String() string {
	const s = "gklatlonutmp2Drowcol"
	switch w {
	case Coord_Which_gk:
		return s[0:2]
	case Coord_Which_latlon:
		return s[2:8]
	case Coord_Which_utm:
		return s[8:11]
	case Coord_Which_p2D:
		return s[11:14]
	case Coord_Which_rowcol:
		return s[14:20]

	}
	return "Coord_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Coord_TypeID is the unique identifier for the type Coord.
const Coord_TypeID = 0xb8f6a6192a7359f8

func NewCoord(s *capnp.Segment) (Coord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Coord(st), err
}

func NewRootCoord(s *capnp.Segment) (Coord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Coord(st), err
}

func ReadRootCoord(msg *capnp.Message) (Coord, error) {
	root, err := msg.Root()
	return Coord(root.Struct()), err
}

func (s Coord) String() string {
	str, _ := text.Marshal(0xb8f6a6192a7359f8, capnp.Struct(s))
	return str
}

func (s Coord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Coord) DecodeFromPtr(p capnp.Ptr) Coord {
	return Coord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Coord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Coord) Which() Coord_Which {
	return Coord_Which(capnp.Struct(s).Uint16(0))
}
func (s Coord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Coord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Coord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Coord) Gk() (GKCoord, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != gk")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return GKCoord(p.Struct()), err
}

func (s Coord) HasGk() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetGk(v GKCoord) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewGk sets the gk field to a newly
// allocated GKCoord struct, preferring placement in s's segment.
func (s Coord) NewGk() (GKCoord, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewGKCoord(capnp.Struct(s).Segment())
	if err != nil {
		return GKCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Latlon() (LatLonCoord, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != latlon")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return LatLonCoord(p.Struct()), err
}

func (s Coord) HasLatlon() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetLatlon(v LatLonCoord) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLatlon sets the latlon field to a newly
// allocated LatLonCoord struct, preferring placement in s's segment.
func (s Coord) NewLatlon() (LatLonCoord, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewLatLonCoord(capnp.Struct(s).Segment())
	if err != nil {
		return LatLonCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Utm() (UTMCoord, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != utm")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return UTMCoord(p.Struct()), err
}

func (s Coord) HasUtm() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetUtm(v UTMCoord) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewUtm sets the utm field to a newly
// allocated UTMCoord struct, preferring placement in s's segment.
func (s Coord) NewUtm() (UTMCoord, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := NewUTMCoord(capnp.Struct(s).Segment())
	if err != nil {
		return UTMCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) P2D() (Point2D, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != p2D")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Point2D(p.Struct()), err
}

func (s Coord) HasP2D() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetP2D(v Point2D) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewP2D sets the p2D field to a newly
// allocated Point2D struct, preferring placement in s's segment.
func (s Coord) NewP2D() (Point2D, error) {
	capnp.Struct(s).SetUint16(0, 3)
	ss, err := NewPoint2D(capnp.Struct(s).Segment())
	if err != nil {
		return Point2D{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Rowcol() (RowCol, error) {
	if capnp.Struct(s).Uint16(0) != 4 {
		panic("Which() != rowcol")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return RowCol(p.Struct()), err
}

func (s Coord) HasRowcol() bool {
	if capnp.Struct(s).Uint16(0) != 4 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetRowcol(v RowCol) error {
	capnp.Struct(s).SetUint16(0, 4)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRowcol sets the rowcol field to a newly
// allocated RowCol struct, preferring placement in s's segment.
func (s Coord) NewRowcol() (RowCol, error) {
	capnp.Struct(s).SetUint16(0, 4)
	ss, err := NewRowCol(capnp.Struct(s).Segment())
	if err != nil {
		return RowCol{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Coord_List is a list of Coord.
type Coord_List = capnp.StructList[Coord]

// NewCoord creates a new list of Coord.
func NewCoord_List(s *capnp.Segment, sz int32) (Coord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Coord](l), err
}

// Coord_Future is a wrapper for a Coord promised by a client call.
type Coord_Future struct{ *capnp.Future }

func (f Coord_Future) Struct() (Coord, error) {
	p, err := f.Future.Ptr()
	return Coord(p.Struct()), err
}
func (p Coord_Future) Gk() GKCoord_Future {
	return GKCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Latlon() LatLonCoord_Future {
	return LatLonCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Utm() UTMCoord_Future {
	return UTMCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) P2D() Point2D_Future {
	return Point2D_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Rowcol() RowCol_Future {
	return RowCol_Future{Future: p.Future.Field(0, nil)}
}

type RectBounds capnp.Struct

// RectBounds_TypeID is the unique identifier for the type RectBounds.
const RectBounds_TypeID = 0xb952dbe83866da4a

func NewRectBounds(s *capnp.Segment) (RectBounds, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RectBounds(st), err
}

func NewRootRectBounds(s *capnp.Segment) (RectBounds, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RectBounds(st), err
}

func ReadRootRectBounds(msg *capnp.Message) (RectBounds, error) {
	root, err := msg.Root()
	return RectBounds(root.Struct()), err
}

func (s RectBounds) String() string {
	str, _ := text.Marshal(0xb952dbe83866da4a, capnp.Struct(s))
	return str
}

func (s RectBounds) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RectBounds) DecodeFromPtr(p capnp.Ptr) RectBounds {
	return RectBounds(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RectBounds) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RectBounds) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RectBounds) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RectBounds) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RectBounds) Tl() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s RectBounds) HasTl() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s RectBounds) SetTl(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}
func (s RectBounds) Br() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s RectBounds) HasBr() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s RectBounds) SetBr(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// RectBounds_List is a list of RectBounds.
type RectBounds_List = capnp.StructList[RectBounds]

// NewRectBounds creates a new list of RectBounds.
func NewRectBounds_List(s *capnp.Segment, sz int32) (RectBounds_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[RectBounds](l), err
}

// RectBounds_Future is a wrapper for a RectBounds promised by a client call.
type RectBounds_Future struct{ *capnp.Future }

func (f RectBounds_Future) Struct() (RectBounds, error) {
	p, err := f.Future.Ptr()
	return RectBounds(p.Struct()), err
}
func (p RectBounds_Future) Tl() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p RectBounds_Future) Br() *capnp.Future {
	return p.Future.Field(1, nil)
}

const schema_9090542079c7fc24 = "x\xda\x9c\x94_L\x1cU\x14\xc6\xcf\xb9wa\xa8e" +
	"a\x87\xd9&\x96H\xd1M\x1b\xa5F\x84\x05\x12\xe4A" +
	"J\x81 Jqo\x07\x12kZ\xed\xc8\xae\xcb\xba\xcb" +
	"\xfcc\xc8\x02\x91T\x92\xb6\xb6I\x9bb\x82A}1" +
	"\xf1A\x13\x93\x8a\xa9&\x15\xe2\x836FI\xd3>\xc8" +
	"\xa3Z\x92V[1\xc5\xc4\xc6\xd4h\x00\xc7\xdc\x99\xfd" +
	"\xe7\xee\x12c\xc3\x03\x933\xbf=\xf3\xdd\xef|\xf74" +
	"\xbcX\xb3\xcf\xd3\xe8\xbd\xf8\x03\x10\xb9\xec\xbe\x92R\xfb" +
	"\xfa\xdc\xeb\x89\x16r\xe6M\x10%\x8f\xfd\xc5\xb1\x85\xfe" +
	"\x0f\x1e\x9e\xbd\x08\x80R\x87\xba(\xf5\xaa\x02\x80\xdc\xa5" +
	"R\x94C*A\x00\xfb\xa37\x8e\x8e+S\xf6\x1c\xb0" +
	"\x0a\xa4\xf6\xee\x8do&\x1e\x1c\x98\x99\x01\x8f\x00 u" +
	"\xa8\x17\xdc_H\xdd\xea<\xa0}\xde\xff\xa3\xf4\xe4\xdb" +
	"_\x7f\xccY\x92\xc7^W?\x94~q\xd8\x9bj\x12" +
	"0\xfbe\xb1\x02\xf3\xdbj\xefH\xbdZ\x14\xa8\xfd\xe7" +
	"\xa1\xd1\xbd;\xdf\xff\xe33\xde0\x87\xeaF\xa1\x04@" +
	"\x1a\xd1\xde\x93\xc64\x01\xa0\xc9\xd0j\x11\xd0~\xfa\xbb" +
	"\x97[W\xbf?\xb8\xf0\xef\x9e%D\xf0\xa14\xad_" +
	"\x96\xce\xea\xbc\xfdi=\x09 m\xea\x95\xf6\x8d\x93\xb1" +
	"]\x0f,\x9c[*\xa6\xf7\xae~A\xdat\xf8\xbft" +
	"\xae\xf7DY\xcf\xae\xb7\xe4\xf5\xa5\x02\xdb\x06\x8deI" +
	"1\xb8m\x87\x0d\x8a\xf2\xb0\xe1\xd8\xf6\xfb\x8d\xb9\xd9[" +
	"+\xd1+\x05\xf8!cY\x8a8\xf8Q\x8e'\\|" +
	"\xea\xd1w\xc7\xbf\x0a\xcf_-\xc0\x8f\x18\x97\xa5\x98\x83" +
	"\x879\xae\xbbx\x0d\xbb\xb4r\xed\xda\xfcO\x05\xb8b" +
	",\x16\xc1W\xd7\x02\x9f\xac|Zw\x13\xc4\x8a\x9cc" +
	":\xf8%\x17\x97\"\xc6\xb3\x80v\xefo\xfb^\xd8s" +
	"\xb5\xfav\xde\xb0K\x90#\x13\xc6\xa24\xed\xc0S\xc6" +
	"\xcf\x80\xf6\xfa\xb9+O4l\xdcY+\xe6\xde\xa0\xb9" +
	",)&\x7f:br\xf7N\x9eo\xd5\x1bV\x17\xee" +
	"\x16\x08^0\x17\xa5/9(\x7fnR\x94\x97L\x82" +
	"`\xdf\xc3\xdf\x1d;\x1a\xd1\x1e\x8fF\xb4z\x1cRt" +
	"Uo\xeb\x0e\xb5\xcb=\xf5\xd1xK\x08\x11\xcb\x804" +
	"\x96\xfd:\x09\x98O\xf5<S\xdb\xa9if8\x84\xc8" +
	"\xca\xa9\x07\xc0\x83\x00b\xf7\xf3\x00\xac\x8b\"\x0b\x11\x14" +
	"\x11\xfd\xc8\x8b\x07\xaa\x00\xd8S\x14\xd9\x00A\x91\x10?" +
	"\x12\x00\x91\xf1b\x1fE\xf6\x1cA{$b\xc6\xc21" +
	"E\x05\xda\xafa)\x10,\x05D\x13\xb7\x03\xc1\xed\x80" +
	"8\x9c~\xca\x17qP\xabLvj\x09\xae\xa1,\xa3" +
	"\xa1.\x00\xc0vSd\x0d9\x1a\x1e\xe3\xc5G(\xb2" +
	"f\x82\x82\xa9%q\x1b\x10\xdc\x06(\x0ci\x89\xf4s" +
	"\xa1\x11T\xeea\xf7#\xe6\x84\xac.\x98\x93\xe7=m" +
	"9i}\xa8-gA\xd4\x04r\x92\xb63\x903\xc5" +
	"\x1d\x81\xdadt\xb4\xb5\xb9}\xcc\x1a\x096\xca\xfc_" +
	"S\xb0_\x88\xc6[\x84h\xbcY\x88\xc6\x9b\xf2et" +
	"jB\xcag?\xf5\x94\xdb\xb6s\xc8\xa9j\x006N" +
	"\x91\x1d'\xe8\xc5\xbfm\xf7\x94\xd3m\x00\xecU\x8a\xec" +
	"\x14A/\xd9\xb4]\xabO\xf0\xb3\xbfF\x91\x9d!\xe8" +
	"\xa5\x1b\xb6\x1f)\x80x\x9aW\x8fSd3\x04\xbd\x9e" +
	"u\xdb\x8f\x1e\x00\xf1,\xefp\x8a\"\x9b%H\xa3q" +
	"\xf4e\xd7\x18 \xfa\x00\xdb\x13\x8a\x95\xd0T\xf4eS" +
	"\xec\xbe\x10\xc6\xac\x11\xf4e/B\xaa\xaa\x07\xbb\xd0\x97" +
	"\xdd\x17\xa9&\xa6\x96\xe4\xc6\xfb\xb2\x8b\xcf}\x919;" +
	"I\x0d82d\xed\xd7\xc6\xd4\xf0(@\xde\x94\xab\x8b" +
	"M\xb9:;ej%\xb0\x0asV\x1b\x00V\x01\xd2" +
	"\x97\xccb\xe5\x0e\x0f\x8a8i;\x91\x8e\xa9\x0a\xb4[" +
	"\x91\x81\x09=\x92?\x8b\x90V\x1bS\xad`W\x9e\x96" +
	"\xaabZ\xaa\xb2Zp<\x93\xe5\x89\x82,\x93t\xda" +
	"\xe4\x9ez'\x14(gn\xde\xb7\xc7\xb6\x06\x9b\x82\xd8" +
	"\x9f\x01W\xc3[\x80N\xd8\x1c\xf3\\\xf0\x96\xafX\xd0" +
	"\xdd\x1b\xdf\x9c\xa1\xd6&\x0b\xdb9\xdepS\x9cI\x94" +
	";\xd1\xaa\xa9\xe6\x83\x13w\x04\x00\x90\x88\xde6\x00\x1a" +
	"\x8d\xf3$\xa4b\x92\xff\xa5\xc1\x81\xf6\x03\x99\xb5\xe1\xcb" +
	"\x18\xa8\xec\x05`\x87)\xb2a\x82i\xff\"\xaf\x00\xb0" +
	"0E\xa6\xf3\xad\x81n\x94G\xb8\xa9\xc3\x14\x99EP" +
	"\xa4\xc4M\xb2\xc1\x8b\x09\x8al\x9c`\xe5\xa4\xa6F\xd2" +
	"+\xc4N(V\xcc\x1a\x0bG\xa0r\xbf\xa2\x86\xb1\x1c" +
	"\x08\x96\xff\xc7fI\x1d\xb6O\xb1\xfa4\x95K\xc5\xf0" +
	"\xff]/\x09\xc5J\xb7\x15\xf8U\xd9by\xa5]o" +
	"\xca\xb8~{\x12\xf0\x9f\x00\x00\x00\xff\xff\x95\xc9UZ"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_9090542079c7fc24,
		Nodes: []uint64{
			0x958c02356c8797e1,
			0x97ff7d61786091ae,
			0xb0c6993e13e314ad,
			0xb79427a74eb97fc0,
			0xb8f6a6192a7359f8,
			0xb952dbe83866da4a,
			0xc88fb91c1e6986e2,
			0xc8fb53981e470885,
			0xcc67dee69497e2f3,
			0xcdaf64c4789f2b7d,
			0xe4afdddddec2511d,
			0xe529b4deb322ece8,
			0xeb1acd255e40f049,
			0xecf1fc3039cc8ffb,
			0xf5b9e8307038ad86,
		},
		Compressed: true,
	})
}
