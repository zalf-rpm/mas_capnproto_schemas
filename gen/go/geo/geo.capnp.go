// Code generated by capnpc-go. DO NOT EDIT.

package geo

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

// Constants defined in geo.capnp.
const (
	EPSG_wgs84  = uint32(4326)
	EPSG_utm21S = uint32(32721)
	EPSG_utm32N = uint32(25832)
	EPSG_gk5    = uint32(31469)
	EPSG_gk4    = uint32(31468)
	EPSG_gk3    = uint32(31467)
)

type CoordType uint16

// CoordType_TypeID is the unique identifier for the type CoordType.
const CoordType_TypeID = 0xe529b4deb322ece8

// Values of CoordType.
const (
	CoordType_gk     CoordType = 0
	CoordType_utm    CoordType = 1
	CoordType_latlon CoordType = 2
)

// String returns the enum's constant name.
func (c CoordType) String() string {
	switch c {
	case CoordType_gk:
		return "gk"
	case CoordType_utm:
		return "utm"
	case CoordType_latlon:
		return "latlon"

	default:
		return ""
	}
}

// CoordTypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func CoordTypeFromString(c string) CoordType {
	switch c {
	case "gk":
		return CoordType_gk
	case "utm":
		return CoordType_utm
	case "latlon":
		return CoordType_latlon

	default:
		return 0
	}
}

type CoordType_List = capnp.EnumList[CoordType]

func NewCoordType_List(s *capnp.Segment, sz int32) (CoordType_List, error) {
	return capnp.NewEnumList[CoordType](s, sz)
}

type EPSG capnp.Struct

// EPSG_TypeID is the unique identifier for the type EPSG.
const EPSG_TypeID = 0xb79427a74eb97fc0

func NewEPSG(s *capnp.Segment) (EPSG, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EPSG(st), err
}

func NewRootEPSG(s *capnp.Segment) (EPSG, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EPSG(st), err
}

func ReadRootEPSG(msg *capnp.Message) (EPSG, error) {
	root, err := msg.Root()
	return EPSG(root.Struct()), err
}

func (s EPSG) String() string {
	str, _ := text.Marshal(0xb79427a74eb97fc0, capnp.Struct(s))
	return str
}

func (s EPSG) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (EPSG) DecodeFromPtr(p capnp.Ptr) EPSG {
	return EPSG(capnp.Struct{}.DecodeFromPtr(p))
}

func (s EPSG) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s EPSG) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s EPSG) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s EPSG) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// EPSG_List is a list of EPSG.
type EPSG_List = capnp.StructList[EPSG]

// NewEPSG creates a new list of EPSG.
func NewEPSG_List(s *capnp.Segment, sz int32) (EPSG_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[EPSG](l), err
}

// EPSG_Future is a wrapper for a EPSG promised by a client call.
type EPSG_Future struct{ *capnp.Future }

func (f EPSG_Future) Struct() (EPSG, error) {
	p, err := f.Future.Ptr()
	return EPSG(p.Struct()), err
}

type UTMCoord capnp.Struct

// UTMCoord_TypeID is the unique identifier for the type UTMCoord.
const UTMCoord_TypeID = 0xeb1acd255e40f049

func NewUTMCoord(s *capnp.Segment) (UTMCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return UTMCoord(st), err
}

func NewRootUTMCoord(s *capnp.Segment) (UTMCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return UTMCoord(st), err
}

func ReadRootUTMCoord(msg *capnp.Message) (UTMCoord, error) {
	root, err := msg.Root()
	return UTMCoord(root.Struct()), err
}

func (s UTMCoord) String() string {
	str, _ := text.Marshal(0xeb1acd255e40f049, capnp.Struct(s))
	return str
}

func (s UTMCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (UTMCoord) DecodeFromPtr(p capnp.Ptr) UTMCoord {
	return UTMCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s UTMCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s UTMCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s UTMCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s UTMCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s UTMCoord) Zone() uint8 {
	return capnp.Struct(s).Uint8(0)
}

func (s UTMCoord) SetZone(v uint8) {
	capnp.Struct(s).SetUint8(0, v)
}

func (s UTMCoord) LatitudeBand() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s UTMCoord) HasLatitudeBand() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s UTMCoord) LatitudeBandBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s UTMCoord) SetLatitudeBand(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s UTMCoord) R() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s UTMCoord) SetR(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s UTMCoord) H() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s UTMCoord) SetH(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// UTMCoord_List is a list of UTMCoord.
type UTMCoord_List = capnp.StructList[UTMCoord]

// NewUTMCoord creates a new list of UTMCoord.
func NewUTMCoord_List(s *capnp.Segment, sz int32) (UTMCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[UTMCoord](l), err
}

// UTMCoord_Future is a wrapper for a UTMCoord promised by a client call.
type UTMCoord_Future struct{ *capnp.Future }

func (f UTMCoord_Future) Struct() (UTMCoord, error) {
	p, err := f.Future.Ptr()
	return UTMCoord(p.Struct()), err
}

type LatLonCoord capnp.Struct

// LatLonCoord_TypeID is the unique identifier for the type LatLonCoord.
const LatLonCoord_TypeID = 0xecf1fc3039cc8ffb

func NewLatLonCoord(s *capnp.Segment) (LatLonCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LatLonCoord(st), err
}

func NewRootLatLonCoord(s *capnp.Segment) (LatLonCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LatLonCoord(st), err
}

func ReadRootLatLonCoord(msg *capnp.Message) (LatLonCoord, error) {
	root, err := msg.Root()
	return LatLonCoord(root.Struct()), err
}

func (s LatLonCoord) String() string {
	str, _ := text.Marshal(0xecf1fc3039cc8ffb, capnp.Struct(s))
	return str
}

func (s LatLonCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LatLonCoord) DecodeFromPtr(p capnp.Ptr) LatLonCoord {
	return LatLonCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LatLonCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LatLonCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LatLonCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LatLonCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LatLonCoord) Lat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s LatLonCoord) SetLat(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s LatLonCoord) Lon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s LatLonCoord) SetLon(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// LatLonCoord_List is a list of LatLonCoord.
type LatLonCoord_List = capnp.StructList[LatLonCoord]

// NewLatLonCoord creates a new list of LatLonCoord.
func NewLatLonCoord_List(s *capnp.Segment, sz int32) (LatLonCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[LatLonCoord](l), err
}

// LatLonCoord_Future is a wrapper for a LatLonCoord promised by a client call.
type LatLonCoord_Future struct{ *capnp.Future }

func (f LatLonCoord_Future) Struct() (LatLonCoord, error) {
	p, err := f.Future.Ptr()
	return LatLonCoord(p.Struct()), err
}

type GKCoord capnp.Struct

// GKCoord_TypeID is the unique identifier for the type GKCoord.
const GKCoord_TypeID = 0x97ff7d61786091ae

func NewGKCoord(s *capnp.Segment) (GKCoord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return GKCoord(st), err
}

func NewRootGKCoord(s *capnp.Segment) (GKCoord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return GKCoord(st), err
}

func ReadRootGKCoord(msg *capnp.Message) (GKCoord, error) {
	root, err := msg.Root()
	return GKCoord(root.Struct()), err
}

func (s GKCoord) String() string {
	str, _ := text.Marshal(0x97ff7d61786091ae, capnp.Struct(s))
	return str
}

func (s GKCoord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GKCoord) DecodeFromPtr(p capnp.Ptr) GKCoord {
	return GKCoord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GKCoord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GKCoord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GKCoord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GKCoord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GKCoord) MeridianNo() uint8 {
	return capnp.Struct(s).Uint8(0)
}

func (s GKCoord) SetMeridianNo(v uint8) {
	capnp.Struct(s).SetUint8(0, v)
}

func (s GKCoord) R() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s GKCoord) SetR(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s GKCoord) H() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s GKCoord) SetH(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// GKCoord_List is a list of GKCoord.
type GKCoord_List = capnp.StructList[GKCoord]

// NewGKCoord creates a new list of GKCoord.
func NewGKCoord_List(s *capnp.Segment, sz int32) (GKCoord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0}, sz)
	return capnp.StructList[GKCoord](l), err
}

// GKCoord_Future is a wrapper for a GKCoord promised by a client call.
type GKCoord_Future struct{ *capnp.Future }

func (f GKCoord_Future) Struct() (GKCoord, error) {
	p, err := f.Future.Ptr()
	return GKCoord(p.Struct()), err
}

type Point2D capnp.Struct

// Point2D_TypeID is the unique identifier for the type Point2D.
const Point2D_TypeID = 0xc88fb91c1e6986e2

func NewPoint2D(s *capnp.Segment) (Point2D, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point2D(st), err
}

func NewRootPoint2D(s *capnp.Segment) (Point2D, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point2D(st), err
}

func ReadRootPoint2D(msg *capnp.Message) (Point2D, error) {
	root, err := msg.Root()
	return Point2D(root.Struct()), err
}

func (s Point2D) String() string {
	str, _ := text.Marshal(0xc88fb91c1e6986e2, capnp.Struct(s))
	return str
}

func (s Point2D) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Point2D) DecodeFromPtr(p capnp.Ptr) Point2D {
	return Point2D(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Point2D) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Point2D) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Point2D) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Point2D) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Point2D) X() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Point2D) SetX(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Point2D) Y() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Point2D) SetY(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Point2D_List is a list of Point2D.
type Point2D_List = capnp.StructList[Point2D]

// NewPoint2D creates a new list of Point2D.
func NewPoint2D_List(s *capnp.Segment, sz int32) (Point2D_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Point2D](l), err
}

// Point2D_Future is a wrapper for a Point2D promised by a client call.
type Point2D_Future struct{ *capnp.Future }

func (f Point2D_Future) Struct() (Point2D, error) {
	p, err := f.Future.Ptr()
	return Point2D(p.Struct()), err
}

type RowCol capnp.Struct

// RowCol_TypeID is the unique identifier for the type RowCol.
const RowCol_TypeID = 0xb0c6993e13e314ad

func NewRowCol(s *capnp.Segment) (RowCol, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return RowCol(st), err
}

func NewRootRowCol(s *capnp.Segment) (RowCol, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return RowCol(st), err
}

func ReadRootRowCol(msg *capnp.Message) (RowCol, error) {
	root, err := msg.Root()
	return RowCol(root.Struct()), err
}

func (s RowCol) String() string {
	str, _ := text.Marshal(0xb0c6993e13e314ad, capnp.Struct(s))
	return str
}

func (s RowCol) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RowCol) DecodeFromPtr(p capnp.Ptr) RowCol {
	return RowCol(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RowCol) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RowCol) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RowCol) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RowCol) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RowCol) Row() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s RowCol) SetRow(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s RowCol) Col() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s RowCol) SetCol(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

// RowCol_List is a list of RowCol.
type RowCol_List = capnp.StructList[RowCol]

// NewRowCol creates a new list of RowCol.
func NewRowCol_List(s *capnp.Segment, sz int32) (RowCol_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[RowCol](l), err
}

// RowCol_Future is a wrapper for a RowCol promised by a client call.
type RowCol_Future struct{ *capnp.Future }

func (f RowCol_Future) Struct() (RowCol, error) {
	p, err := f.Future.Ptr()
	return RowCol(p.Struct()), err
}

type Coord capnp.Struct
type Coord_Which uint16

const (
	Coord_Which_gk     Coord_Which = 0
	Coord_Which_latlon Coord_Which = 1
	Coord_Which_utm    Coord_Which = 2
	Coord_Which_p2D    Coord_Which = 3
	Coord_Which_rowcol Coord_Which = 4
)

func (w Coord_Which) String() string {
	const s = "gklatlonutmp2Drowcol"
	switch w {
	case Coord_Which_gk:
		return s[0:2]
	case Coord_Which_latlon:
		return s[2:8]
	case Coord_Which_utm:
		return s[8:11]
	case Coord_Which_p2D:
		return s[11:14]
	case Coord_Which_rowcol:
		return s[14:20]

	}
	return "Coord_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Coord_TypeID is the unique identifier for the type Coord.
const Coord_TypeID = 0xb8f6a6192a7359f8

func NewCoord(s *capnp.Segment) (Coord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Coord(st), err
}

func NewRootCoord(s *capnp.Segment) (Coord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Coord(st), err
}

func ReadRootCoord(msg *capnp.Message) (Coord, error) {
	root, err := msg.Root()
	return Coord(root.Struct()), err
}

func (s Coord) String() string {
	str, _ := text.Marshal(0xb8f6a6192a7359f8, capnp.Struct(s))
	return str
}

func (s Coord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Coord) DecodeFromPtr(p capnp.Ptr) Coord {
	return Coord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Coord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Coord) Which() Coord_Which {
	return Coord_Which(capnp.Struct(s).Uint16(0))
}
func (s Coord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Coord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Coord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Coord) Gk() (GKCoord, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != gk")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return GKCoord(p.Struct()), err
}

func (s Coord) HasGk() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetGk(v GKCoord) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewGk sets the gk field to a newly
// allocated GKCoord struct, preferring placement in s's segment.
func (s Coord) NewGk() (GKCoord, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewGKCoord(capnp.Struct(s).Segment())
	if err != nil {
		return GKCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Latlon() (LatLonCoord, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != latlon")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return LatLonCoord(p.Struct()), err
}

func (s Coord) HasLatlon() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetLatlon(v LatLonCoord) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLatlon sets the latlon field to a newly
// allocated LatLonCoord struct, preferring placement in s's segment.
func (s Coord) NewLatlon() (LatLonCoord, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewLatLonCoord(capnp.Struct(s).Segment())
	if err != nil {
		return LatLonCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Utm() (UTMCoord, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != utm")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return UTMCoord(p.Struct()), err
}

func (s Coord) HasUtm() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetUtm(v UTMCoord) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewUtm sets the utm field to a newly
// allocated UTMCoord struct, preferring placement in s's segment.
func (s Coord) NewUtm() (UTMCoord, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := NewUTMCoord(capnp.Struct(s).Segment())
	if err != nil {
		return UTMCoord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) P2D() (Point2D, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != p2D")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Point2D(p.Struct()), err
}

func (s Coord) HasP2D() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetP2D(v Point2D) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewP2D sets the p2D field to a newly
// allocated Point2D struct, preferring placement in s's segment.
func (s Coord) NewP2D() (Point2D, error) {
	capnp.Struct(s).SetUint16(0, 3)
	ss, err := NewPoint2D(capnp.Struct(s).Segment())
	if err != nil {
		return Point2D{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Coord) Rowcol() (RowCol, error) {
	if capnp.Struct(s).Uint16(0) != 4 {
		panic("Which() != rowcol")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return RowCol(p.Struct()), err
}

func (s Coord) HasRowcol() bool {
	if capnp.Struct(s).Uint16(0) != 4 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Coord) SetRowcol(v RowCol) error {
	capnp.Struct(s).SetUint16(0, 4)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRowcol sets the rowcol field to a newly
// allocated RowCol struct, preferring placement in s's segment.
func (s Coord) NewRowcol() (RowCol, error) {
	capnp.Struct(s).SetUint16(0, 4)
	ss, err := NewRowCol(capnp.Struct(s).Segment())
	if err != nil {
		return RowCol{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Coord_List is a list of Coord.
type Coord_List = capnp.StructList[Coord]

// NewCoord creates a new list of Coord.
func NewCoord_List(s *capnp.Segment, sz int32) (Coord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Coord](l), err
}

// Coord_Future is a wrapper for a Coord promised by a client call.
type Coord_Future struct{ *capnp.Future }

func (f Coord_Future) Struct() (Coord, error) {
	p, err := f.Future.Ptr()
	return Coord(p.Struct()), err
}
func (p Coord_Future) Gk() GKCoord_Future {
	return GKCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Latlon() LatLonCoord_Future {
	return LatLonCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Utm() UTMCoord_Future {
	return UTMCoord_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) P2D() Point2D_Future {
	return Point2D_Future{Future: p.Future.Field(0, nil)}
}
func (p Coord_Future) Rowcol() RowCol_Future {
	return RowCol_Future{Future: p.Future.Field(0, nil)}
}

type RectBounds capnp.Struct

// RectBounds_TypeID is the unique identifier for the type RectBounds.
const RectBounds_TypeID = 0xb952dbe83866da4a

func NewRectBounds(s *capnp.Segment) (RectBounds, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RectBounds(st), err
}

func NewRootRectBounds(s *capnp.Segment) (RectBounds, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RectBounds(st), err
}

func ReadRootRectBounds(msg *capnp.Message) (RectBounds, error) {
	root, err := msg.Root()
	return RectBounds(root.Struct()), err
}

func (s RectBounds) String() string {
	str, _ := text.Marshal(0xb952dbe83866da4a, capnp.Struct(s))
	return str
}

func (s RectBounds) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RectBounds) DecodeFromPtr(p capnp.Ptr) RectBounds {
	return RectBounds(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RectBounds) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RectBounds) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RectBounds) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RectBounds) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RectBounds) Tl() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s RectBounds) HasTl() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s RectBounds) SetTl(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}
func (s RectBounds) Br() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s RectBounds) HasBr() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s RectBounds) SetBr(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// RectBounds_List is a list of RectBounds.
type RectBounds_List = capnp.StructList[RectBounds]

// NewRectBounds creates a new list of RectBounds.
func NewRectBounds_List(s *capnp.Segment, sz int32) (RectBounds_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[RectBounds](l), err
}

// RectBounds_Future is a wrapper for a RectBounds promised by a client call.
type RectBounds_Future struct{ *capnp.Future }

func (f RectBounds_Future) Struct() (RectBounds, error) {
	p, err := f.Future.Ptr()
	return RectBounds(p.Struct()), err
}
func (p RectBounds_Future) Tl() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p RectBounds_Future) Br() *capnp.Future {
	return p.Future.Field(1, nil)
}

const schema_9090542079c7fc24 = "x\xda\x9c\x94_h\x1c\xd5\x17\xc7\xcf\xb9w\xd3Ii" +
	"6\xd9\xc9l\xe1\xd7\xd04?\x97\x16M\xc5\x98l\x12" +
	"H\xf2`b\x93\x10\xabI\xdc\xdbI\xa0\x95*]\xb3" +
	"\xebf\xdd\x99\xb9\x93\xcd\x84M\x82\xa1\x0am\xadPi" +
	"\x84H\xd4\x17\xc1\x07E\xb1F\xab`\x93')\xa2\xa5" +
	"\xb4\x0f\x0d\x08\xd5\xd2\x80\xd5\xd6H\x13PD\x11\x12\x1d" +
	"\xb93\xfb\xcf\xdd\x0d\xa2\xe4!\xc3\x99\xcf\x9e\xf9\xde\xef" +
	"\xf9\xde\xd3xcw\x97\xa7\xc9;\x7f\x1d\x88z}{" +
	"\xd96\xfb\xdb\xf9\x17\xb5Vr\xe6U\x90\x15\x8f\xfd\xd9" +
	"\xf1\xc5\xc1w\xee\x9d\xfb\x14\x00\x95&mIi\xd7$" +
	"\x00\xb5E\xa3\xa8vi\x04\x01\xec\x0f^96\x19\x9e" +
	"\xb1\xe7\x81U\"\xb5\xf7n~9\xf5\xff\xa1\xd9Y\xf0" +
	"H\x00J\x93v\xde\xfd\x85\xd2\xaa-\x00\xda\xe7\xfc\xdf" +
	")\x0f\xbd\xfe\xc5\x87\x82%\x05\xec5\xed=\xe5k\x87" +
	"\xfdJK\x01\xe6\xbe,Wba[\xfd\x0d\xa5]\x8f" +
	"\x01\xb5\x7f?2\xbe\x7f\xd7\xdb\xbf]\x10\x0d\xf3\xa8^" +
	"\x94\xca\x00\x94'\xf5\xb7\x94\xa8.\x014\x87\xf5:\x04" +
	"\xb4\x1f\xfd\xe6\x99\xb6\xd5\x1b\x87\x16\xff\xde\xb3\x8cH>" +
	"T\xc6\x8c\xcb\xca\x8c!\xdaO\x19)\x00e\xdd\xa8\xb2" +
	"o\x9d\x8a\xef\xd9\xbdx\xf6R)\xbd\xb7\x8d\xf3\xca\xba" +
	"\xc3\xffh\x08\xbd'\xcb\xfb\xf6\xbc\xa6n\\*\xb2\xad" +
	"\x97/+\x8c\x0b\xdb\xfa9E\xf50wl\xfb\xe5\xd6" +
	"\xfc\xdc\x9d\x95\xd8\x95\"\xfc _V\x86\x1d<$\xf0" +
	"\xa3.>s\xff\x9b\x93\x9fG\x16\xae\x16\xe1\x03\xfc\xb2" +
	"r\xc4\xc1\x87\x04~\xcc\xc5k\xd9\xc5\x95\x9b7\x17\xbe" +
	"/\xc2\x19_*\x81\xaf\xae\x05>^\xf9\xa4\xfe6\xc8" +
	"\x95y\xc7t\xf0\x8b.\xae\x0c\xf3\xc7\x01\xed\x83?u" +
	"=\xb5\xefj\xcd\xdd\x82a\x97\xa1@\xe2|I\x19s" +
	"`\x9d\xff\x00ho\x9c\xbd\xd2\xde\xb8\xf9\xf3Z)\xf7" +
	"z\xcde\x85\x99\xe2i\xc0\x14\xee\x9d:\xd7f6\xae" +
	".\xfeZ$\xf8]sI\xf9H\x80\xea\xfb&E\xf5" +
	"\x82I\x10\xec\xff\xf0\xa7\xdb\xb1(\x7f0\x16\xe5\x0d8" +
	"\x126\x0d\xb3\xa37\xd4\xa9\xf65\xc4\x12\xad!D," +
	"\x07\xd2T\xbe>\x0dXH\xf5=V\xd7\xcdy2\x12" +
	"Bd\x15\xd4\x03\xe0A\x00\xb9\xf7\x09\x00\xd6C\x91\x85" +
	"\x08\xca\x88~\x14\xc5\x81j\x00\xf6\x08E6DP&" +
	"\xc4\x8f\x04@f\xa2\xd8O\x91\x1d&h\xeb\xd1d<" +
	"\x12\x0f\x1b@\x079n\x03\x82\xdb\x001\x89;\x80\xe0" +
	"\x0e@\x1c\xcd<\x15\x8a8\xc4\xabR\xdd\\\x13\x1a\xca" +
	"\xb3\x1a\xea\x03\x00l/E\xd6\x98\xa7\xe1\x01Q\xbc\x8f" +
	"\"k!(%y\x0a\xb7\x03\xc1\xed\x80\xd2\x08\xd72" +
	"\xcf\xc5FP\xb5\x8f\xfd\x0f1/d\xf5\xc1\xbc<\xef" +
	"\xeb\xc8K\xeb=\x1dy\x0b\xa26\x90\x97\xb4]\x81\xbc" +
	")\xee\x0c\xd4\xa5b\xe3m-\x9d\x13\x96\x1elR\xc5" +
	"\xbf\xe6\xe0\xa0\x14K\xb4J\xb1D\x8b\x14K4\x17\xca" +
	"\xe8\xe6R\xdag?\xf5T\xd8\xb6s\xc8\x99\x1a\x006" +
	"I\x91\x9d \xe8\xc5?m\xf7\x94/t\x00\xb0\xe7(" +
	"\xb2\xd3\x04\xbd\xe4\x0f\xdb\xb5\xfa\xa48\xfb\xf3\x14\xd9\x19" +
	"\x82^\xbai\xfb\x91\x02\xc8/\x89\xea\x09\x8al\x96\xa0" +
	"\xd7\xb3a\xfb\xd1\x03 \xbf,:\x9c\xa6\xc8\xe6\x08\xd2" +
	"X\x02}\xb95\x06\x88>\xc0N-li\xdc@_" +
	".\xc5\xee\x0bi\xc2\xd2\xd1\x97\xbb\x08\xe9\xaa\x19\xecA" +
	"_n_\xa4\x9b$yJ\x18\xef\xcb->\xf7E\xf6" +
	"\xec$=\xe0\xe8\x88u\x80O\x18\x91q\x80\x82)\xd7" +
	"\x94\x9arMn\xca\xd4\xd2\xb0\x1a\xf3V\x1b\x00V\x03" +
	"\xd2\xa7\x93\xa5\xca\x0f{P\xc6i\xdb\x89t\xdc\x08C" +
	"\xa7\x15\x1d\x9a2\xa3\x85\xb3\x08\xf1\xba\xb8a\x05{\x0a" +
	"\xb4T\x97\xd2R\x9d\xd3\x82\x93\xd9,O\x15e\x99d" +
	"\xd2\xa6\xf658\xa1@5{\xf3\xae\x1d\xdf\x1al\x0e" +
	"\xe2`\x16\\\x8dl\x01:as\xccs\xc1;\xbeR" +
	"Awo|K\x96Z\x9b.n\xe7x#Lq&" +
	"Q\xe1D\xab\xb6F\x0cN\xde\x19\x00@\"{;\x00" +
	"h,!\x92\x90\x8eI\xe1\x97\x86\x87:\x07\xb2k\xc3" +
	"\x9750\xbc\x1f\x80\x1d\xa5\xc8F\x09f\xfc\x8b>\x0b" +
	"\xc0\"\x14\x99)\xb6\x06\xbaQ\xd6\x85\xa9\xa3\x14\x99E" +
	"P\xa6\xc4M\xf2\x98(j\x14\xd9$\xc1\xaainD" +
	"3+\xc4\xd6\xc2V\xdc\x9a\x88D\xa1\xea@\xd8\x88`" +
	"\x05\x10\xac\xf8\x87\xcd\x92>l\x7f\xd8\xea\xe7\x86\x90\x8a" +
	"\x91\x7f\xbb^\xb4\xb0\x95i+\x89\xab\xb2\xc5\xf2\xca\xb8" +
	"\xde\x9cu\xfd\xee4\xe0_\x01\x00\x00\xff\xff?8R" +
	"f"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_9090542079c7fc24,
		Nodes: []uint64{
			0x958c02356c8797e1,
			0x97ff7d61786091ae,
			0xb0c6993e13e314ad,
			0xb79427a74eb97fc0,
			0xb8f6a6192a7359f8,
			0xb952dbe83866da4a,
			0xc88fb91c1e6986e2,
			0xc8fb53981e470885,
			0xcc67dee69497e2f3,
			0xcdaf64c4789f2b7d,
			0xe4afdddddec2511d,
			0xe529b4deb322ece8,
			0xeb1acd255e40f049,
			0xecf1fc3039cc8ffb,
			0xf5b9e8307038ad86,
		},
		Compressed: true,
	})
}
