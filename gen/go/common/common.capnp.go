// Code generated by capnpc-go. DO NOT EDIT.

package common

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	math "math"
	strconv "strconv"
)

type IdInformation capnp.Struct

// IdInformation_TypeID is the unique identifier for the type IdInformation.
const IdInformation_TypeID = 0xd4cb7ecbfe03dad3

func NewIdInformation(s *capnp.Segment) (IdInformation, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return IdInformation(st), err
}

func NewRootIdInformation(s *capnp.Segment) (IdInformation, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return IdInformation(st), err
}

func ReadRootIdInformation(msg *capnp.Message) (IdInformation, error) {
	root, err := msg.Root()
	return IdInformation(root.Struct()), err
}

func (s IdInformation) String() string {
	str, _ := text.Marshal(0xd4cb7ecbfe03dad3, capnp.Struct(s))
	return str
}

func (s IdInformation) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IdInformation) DecodeFromPtr(p capnp.Ptr) IdInformation {
	return IdInformation(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IdInformation) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IdInformation) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IdInformation) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IdInformation) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IdInformation) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IdInformation) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IdInformation) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IdInformation) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s IdInformation) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s IdInformation) HasName() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s IdInformation) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s IdInformation) SetName(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s IdInformation) Description() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s IdInformation) HasDescription() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s IdInformation) DescriptionBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s IdInformation) SetDescription(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

// IdInformation_List is a list of IdInformation.
type IdInformation_List = capnp.StructList[IdInformation]

// NewIdInformation creates a new list of IdInformation.
func NewIdInformation_List(s *capnp.Segment, sz int32) (IdInformation_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[IdInformation](l), err
}

// IdInformation_Future is a wrapper for a IdInformation promised by a client call.
type IdInformation_Future struct{ *capnp.Future }

func (f IdInformation_Future) Struct() (IdInformation, error) {
	p, err := f.Future.Ptr()
	return IdInformation(p.Struct()), err
}

type Identifiable capnp.Client

// Identifiable_TypeID is the unique identifier for the type Identifiable.
const Identifiable_TypeID = 0xb2afd1cb599c48d5

func (c Identifiable) Info(ctx context.Context, params func(Identifiable_info_Params) error) (IdInformation_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Identifiable_info_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IdInformation_Future{Future: ans.Future()}, release

}

func (c Identifiable) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Identifiable) String() string {
	return "Identifiable(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Identifiable) AddRef() Identifiable {
	return Identifiable(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Identifiable) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Identifiable) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Identifiable) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Identifiable) DecodeFromPtr(p capnp.Ptr) Identifiable {
	return Identifiable(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Identifiable) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Identifiable) IsSame(other Identifiable) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Identifiable) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Identifiable) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Identifiable_Server is a Identifiable with a local implementation.
type Identifiable_Server interface {
	Info(context.Context, Identifiable_info) error
}

// Identifiable_NewServer creates a new Server from an implementation of Identifiable_Server.
func Identifiable_NewServer(s Identifiable_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Identifiable_Methods(nil, s), s, c)
}

// Identifiable_ServerToClient creates a new Client from an implementation of Identifiable_Server.
// The caller is responsible for calling Release on the returned Client.
func Identifiable_ServerToClient(s Identifiable_Server) Identifiable {
	return Identifiable(capnp.NewClient(Identifiable_NewServer(s)))
}

// Identifiable_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Identifiable_Methods(methods []server.Method, s Identifiable_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Info(ctx, Identifiable_info{call})
		},
	})

	return methods
}

// Identifiable_info holds the state for a server call to Identifiable.info.
// See server.Call for documentation.
type Identifiable_info struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Identifiable_info) Args() Identifiable_info_Params {
	return Identifiable_info_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Identifiable_info) AllocResults() (IdInformation, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return IdInformation(r), err
}

// Identifiable_List is a list of Identifiable.
type Identifiable_List = capnp.CapList[Identifiable]

// NewIdentifiable_List creates a new list of Identifiable.
func NewIdentifiable_List(s *capnp.Segment, sz int32) (Identifiable_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Identifiable](l), err
}

type Identifiable_info_Params capnp.Struct

// Identifiable_info_Params_TypeID is the unique identifier for the type Identifiable_info_Params.
const Identifiable_info_Params_TypeID = 0x9d8aa1cf1e49deb1

func NewIdentifiable_info_Params(s *capnp.Segment) (Identifiable_info_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Identifiable_info_Params(st), err
}

func NewRootIdentifiable_info_Params(s *capnp.Segment) (Identifiable_info_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Identifiable_info_Params(st), err
}

func ReadRootIdentifiable_info_Params(msg *capnp.Message) (Identifiable_info_Params, error) {
	root, err := msg.Root()
	return Identifiable_info_Params(root.Struct()), err
}

func (s Identifiable_info_Params) String() string {
	str, _ := text.Marshal(0x9d8aa1cf1e49deb1, capnp.Struct(s))
	return str
}

func (s Identifiable_info_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Identifiable_info_Params) DecodeFromPtr(p capnp.Ptr) Identifiable_info_Params {
	return Identifiable_info_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Identifiable_info_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Identifiable_info_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Identifiable_info_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Identifiable_info_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Identifiable_info_Params_List is a list of Identifiable_info_Params.
type Identifiable_info_Params_List = capnp.StructList[Identifiable_info_Params]

// NewIdentifiable_info_Params creates a new list of Identifiable_info_Params.
func NewIdentifiable_info_Params_List(s *capnp.Segment, sz int32) (Identifiable_info_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Identifiable_info_Params](l), err
}

// Identifiable_info_Params_Future is a wrapper for a Identifiable_info_Params promised by a client call.
type Identifiable_info_Params_Future struct{ *capnp.Future }

func (f Identifiable_info_Params_Future) Struct() (Identifiable_info_Params, error) {
	p, err := f.Future.Ptr()
	return Identifiable_info_Params(p.Struct()), err
}

type StructuredText capnp.Struct
type StructuredText_structure StructuredText
type StructuredText_structure_Which uint16

const (
	StructuredText_structure_Which_none StructuredText_structure_Which = 0
	StructuredText_structure_Which_json StructuredText_structure_Which = 1
	StructuredText_structure_Which_xml  StructuredText_structure_Which = 2
	StructuredText_structure_Which_toml StructuredText_structure_Which = 3
)

func (w StructuredText_structure_Which) String() string {
	const s = "nonejsonxmltoml"
	switch w {
	case StructuredText_structure_Which_none:
		return s[0:4]
	case StructuredText_structure_Which_json:
		return s[4:8]
	case StructuredText_structure_Which_xml:
		return s[8:11]
	case StructuredText_structure_Which_toml:
		return s[11:15]

	}
	return "StructuredText_structure_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// StructuredText_TypeID is the unique identifier for the type StructuredText.
const StructuredText_TypeID = 0xed6c098b67cad454

func NewStructuredText(s *capnp.Segment) (StructuredText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return StructuredText(st), err
}

func NewRootStructuredText(s *capnp.Segment) (StructuredText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return StructuredText(st), err
}

func ReadRootStructuredText(msg *capnp.Message) (StructuredText, error) {
	root, err := msg.Root()
	return StructuredText(root.Struct()), err
}

func (s StructuredText) String() string {
	str, _ := text.Marshal(0xed6c098b67cad454, capnp.Struct(s))
	return str
}

func (s StructuredText) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (StructuredText) DecodeFromPtr(p capnp.Ptr) StructuredText {
	return StructuredText(capnp.Struct{}.DecodeFromPtr(p))
}

func (s StructuredText) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s StructuredText) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s StructuredText) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s StructuredText) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s StructuredText) Value() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s StructuredText) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s StructuredText) ValueBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s StructuredText) SetValue(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s StructuredText) Type() StructuredText_Type {
	return StructuredText_Type(capnp.Struct(s).Uint16(2))
}

func (s StructuredText) SetType(v StructuredText_Type) {
	capnp.Struct(s).SetUint16(2, uint16(v))
}

func (s StructuredText) Structure() StructuredText_structure { return StructuredText_structure(s) }

func (s StructuredText_structure) Which() StructuredText_structure_Which {
	return StructuredText_structure_Which(capnp.Struct(s).Uint16(0))
}
func (s StructuredText_structure) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s StructuredText_structure) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s StructuredText_structure) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s StructuredText_structure) SetNone() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s StructuredText_structure) SetJson() {
	capnp.Struct(s).SetUint16(0, 1)

}

func (s StructuredText_structure) SetXml() {
	capnp.Struct(s).SetUint16(0, 2)

}

func (s StructuredText_structure) SetToml() {
	capnp.Struct(s).SetUint16(0, 3)

}

// StructuredText_List is a list of StructuredText.
type StructuredText_List = capnp.StructList[StructuredText]

// NewStructuredText creates a new list of StructuredText.
func NewStructuredText_List(s *capnp.Segment, sz int32) (StructuredText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[StructuredText](l), err
}

// StructuredText_Future is a wrapper for a StructuredText promised by a client call.
type StructuredText_Future struct{ *capnp.Future }

func (f StructuredText_Future) Struct() (StructuredText, error) {
	p, err := f.Future.Ptr()
	return StructuredText(p.Struct()), err
}
func (p StructuredText_Future) Structure() StructuredText_structure_Future {
	return StructuredText_structure_Future{p.Future}
}

// StructuredText_structure_Future is a wrapper for a StructuredText_structure promised by a client call.
type StructuredText_structure_Future struct{ *capnp.Future }

func (f StructuredText_structure_Future) Struct() (StructuredText_structure, error) {
	p, err := f.Future.Ptr()
	return StructuredText_structure(p.Struct()), err
}

type StructuredText_Type uint16

// StructuredText_Type_TypeID is the unique identifier for the type StructuredText_Type.
const StructuredText_Type_TypeID = 0x9eebc43e17b5974f

// Values of StructuredText_Type.
const (
	StructuredText_Type_unstructured StructuredText_Type = 0
	StructuredText_Type_json         StructuredText_Type = 1
	StructuredText_Type_xml          StructuredText_Type = 2
	StructuredText_Type_toml         StructuredText_Type = 3
	StructuredText_Type_sturdyRef    StructuredText_Type = 4
)

// String returns the enum's constant name.
func (c StructuredText_Type) String() string {
	switch c {
	case StructuredText_Type_unstructured:
		return "unstructured"
	case StructuredText_Type_json:
		return "json"
	case StructuredText_Type_xml:
		return "xml"
	case StructuredText_Type_toml:
		return "toml"
	case StructuredText_Type_sturdyRef:
		return "sturdyRef"

	default:
		return ""
	}
}

// StructuredText_TypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func StructuredText_TypeFromString(c string) StructuredText_Type {
	switch c {
	case "unstructured":
		return StructuredText_Type_unstructured
	case "json":
		return StructuredText_Type_json
	case "xml":
		return StructuredText_Type_xml
	case "toml":
		return StructuredText_Type_toml
	case "sturdyRef":
		return StructuredText_Type_sturdyRef

	default:
		return 0
	}
}

type StructuredText_Type_List = capnp.EnumList[StructuredText_Type]

func NewStructuredText_Type_List(s *capnp.Segment, sz int32) (StructuredText_Type_List, error) {
	return capnp.NewEnumList[StructuredText_Type](s, sz)
}

type Value capnp.Struct
type Value_Which uint16

const (
	Value_Which_f64   Value_Which = 0
	Value_Which_f32   Value_Which = 1
	Value_Which_i64   Value_Which = 2
	Value_Which_i32   Value_Which = 3
	Value_Which_i16   Value_Which = 4
	Value_Which_i8    Value_Which = 5
	Value_Which_ui64  Value_Which = 6
	Value_Which_ui32  Value_Which = 7
	Value_Which_ui16  Value_Which = 8
	Value_Which_ui8   Value_Which = 9
	Value_Which_b     Value_Which = 10
	Value_Which_t     Value_Which = 11
	Value_Which_d     Value_Which = 12
	Value_Which_p     Value_Which = 13
	Value_Which_cap   Value_Which = 14
	Value_Which_lf64  Value_Which = 15
	Value_Which_lf32  Value_Which = 16
	Value_Which_li64  Value_Which = 17
	Value_Which_li32  Value_Which = 18
	Value_Which_li16  Value_Which = 19
	Value_Which_li8   Value_Which = 20
	Value_Which_lui64 Value_Which = 21
	Value_Which_lui32 Value_Which = 22
	Value_Which_lui16 Value_Which = 23
	Value_Which_lui8  Value_Which = 24
	Value_Which_lb    Value_Which = 25
	Value_Which_lt    Value_Which = 26
	Value_Which_ld    Value_Which = 27
	Value_Which_lcap  Value_Which = 28
	Value_Which_lpair Value_Which = 29
)

func (w Value_Which) String() string {
	const s = "f64f32i64i32i16i8ui64ui32ui16ui8btdpcaplf64lf32li64li32li16li8lui64lui32lui16lui8lbltldlcaplpair"
	switch w {
	case Value_Which_f64:
		return s[0:3]
	case Value_Which_f32:
		return s[3:6]
	case Value_Which_i64:
		return s[6:9]
	case Value_Which_i32:
		return s[9:12]
	case Value_Which_i16:
		return s[12:15]
	case Value_Which_i8:
		return s[15:17]
	case Value_Which_ui64:
		return s[17:21]
	case Value_Which_ui32:
		return s[21:25]
	case Value_Which_ui16:
		return s[25:29]
	case Value_Which_ui8:
		return s[29:32]
	case Value_Which_b:
		return s[32:33]
	case Value_Which_t:
		return s[33:34]
	case Value_Which_d:
		return s[34:35]
	case Value_Which_p:
		return s[35:36]
	case Value_Which_cap:
		return s[36:39]
	case Value_Which_lf64:
		return s[39:43]
	case Value_Which_lf32:
		return s[43:47]
	case Value_Which_li64:
		return s[47:51]
	case Value_Which_li32:
		return s[51:55]
	case Value_Which_li16:
		return s[55:59]
	case Value_Which_li8:
		return s[59:62]
	case Value_Which_lui64:
		return s[62:67]
	case Value_Which_lui32:
		return s[67:72]
	case Value_Which_lui16:
		return s[72:77]
	case Value_Which_lui8:
		return s[77:81]
	case Value_Which_lb:
		return s[81:83]
	case Value_Which_lt:
		return s[83:85]
	case Value_Which_ld:
		return s[85:87]
	case Value_Which_lcap:
		return s[87:91]
	case Value_Which_lpair:
		return s[91:96]

	}
	return "Value_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Value_TypeID is the unique identifier for the type Value.
const Value_TypeID = 0xe17592335373b246

func NewValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Value(st), err
}

func NewRootValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Value(st), err
}

func ReadRootValue(msg *capnp.Message) (Value, error) {
	root, err := msg.Root()
	return Value(root.Struct()), err
}

func (s Value) String() string {
	str, _ := text.Marshal(0xe17592335373b246, capnp.Struct(s))
	return str
}

func (s Value) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Value) DecodeFromPtr(p capnp.Ptr) Value {
	return Value(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Value) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Value) Which() Value_Which {
	return Value_Which(capnp.Struct(s).Uint16(8))
}
func (s Value) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Value) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Value) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Value) F64() float64 {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != f64")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Value) SetF64(v float64) {
	capnp.Struct(s).SetUint16(8, 0)
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Value) F32() float32 {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != f32")
	}
	return math.Float32frombits(capnp.Struct(s).Uint32(0))
}

func (s Value) SetF32(v float32) {
	capnp.Struct(s).SetUint16(8, 1)
	capnp.Struct(s).SetUint32(0, math.Float32bits(v))
}

func (s Value) I64() int64 {
	if capnp.Struct(s).Uint16(8) != 2 {
		panic("Which() != i64")
	}
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Value) SetI64(v int64) {
	capnp.Struct(s).SetUint16(8, 2)
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Value) I32() int32 {
	if capnp.Struct(s).Uint16(8) != 3 {
		panic("Which() != i32")
	}
	return int32(capnp.Struct(s).Uint32(0))
}

func (s Value) SetI32(v int32) {
	capnp.Struct(s).SetUint16(8, 3)
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s Value) I16() int16 {
	if capnp.Struct(s).Uint16(8) != 4 {
		panic("Which() != i16")
	}
	return int16(capnp.Struct(s).Uint16(0))
}

func (s Value) SetI16(v int16) {
	capnp.Struct(s).SetUint16(8, 4)
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Value) I8() int8 {
	if capnp.Struct(s).Uint16(8) != 5 {
		panic("Which() != i8")
	}
	return int8(capnp.Struct(s).Uint8(0))
}

func (s Value) SetI8(v int8) {
	capnp.Struct(s).SetUint16(8, 5)
	capnp.Struct(s).SetUint8(0, uint8(v))
}

func (s Value) Ui64() uint64 {
	if capnp.Struct(s).Uint16(8) != 6 {
		panic("Which() != ui64")
	}
	return capnp.Struct(s).Uint64(0)
}

func (s Value) SetUi64(v uint64) {
	capnp.Struct(s).SetUint16(8, 6)
	capnp.Struct(s).SetUint64(0, v)
}

func (s Value) Ui32() uint32 {
	if capnp.Struct(s).Uint16(8) != 7 {
		panic("Which() != ui32")
	}
	return capnp.Struct(s).Uint32(0)
}

func (s Value) SetUi32(v uint32) {
	capnp.Struct(s).SetUint16(8, 7)
	capnp.Struct(s).SetUint32(0, v)
}

func (s Value) Ui16() uint16 {
	if capnp.Struct(s).Uint16(8) != 8 {
		panic("Which() != ui16")
	}
	return capnp.Struct(s).Uint16(0)
}

func (s Value) SetUi16(v uint16) {
	capnp.Struct(s).SetUint16(8, 8)
	capnp.Struct(s).SetUint16(0, v)
}

func (s Value) Ui8() uint8 {
	if capnp.Struct(s).Uint16(8) != 9 {
		panic("Which() != ui8")
	}
	return capnp.Struct(s).Uint8(0)
}

func (s Value) SetUi8(v uint8) {
	capnp.Struct(s).SetUint16(8, 9)
	capnp.Struct(s).SetUint8(0, v)
}

func (s Value) B() bool {
	if capnp.Struct(s).Uint16(8) != 10 {
		panic("Which() != b")
	}
	return capnp.Struct(s).Bit(0)
}

func (s Value) SetB(v bool) {
	capnp.Struct(s).SetUint16(8, 10)
	capnp.Struct(s).SetBit(0, v)
}

func (s Value) T() (string, error) {
	if capnp.Struct(s).Uint16(8) != 11 {
		panic("Which() != t")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Value) HasT() bool {
	if capnp.Struct(s).Uint16(8) != 11 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) TBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Value) SetT(v string) error {
	capnp.Struct(s).SetUint16(8, 11)
	return capnp.Struct(s).SetText(0, v)
}

func (s Value) D() ([]byte, error) {
	if capnp.Struct(s).Uint16(8) != 12 {
		panic("Which() != d")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Value) HasD() bool {
	if capnp.Struct(s).Uint16(8) != 12 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetD(v []byte) error {
	capnp.Struct(s).SetUint16(8, 12)
	return capnp.Struct(s).SetData(0, v)
}

func (s Value) P() (capnp.Ptr, error) {
	if capnp.Struct(s).Uint16(8) != 13 {
		panic("Which() != p")
	}
	return capnp.Struct(s).Ptr(0)
}

func (s Value) HasP() bool {
	if capnp.Struct(s).Uint16(8) != 13 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetP(v capnp.Ptr) error {
	capnp.Struct(s).SetUint16(8, 13)
	return capnp.Struct(s).SetPtr(0, v)
}
func (s Value) Cap() capnp.Client {
	if capnp.Struct(s).Uint16(8) != 14 {
		panic("Which() != cap")
	}
	p, _ := capnp.Struct(s).Ptr(0)
	return p.Interface().Client()
}

func (s Value) HasCap() bool {
	if capnp.Struct(s).Uint16(8) != 14 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetCap(c capnp.Client) error {
	capnp.Struct(s).SetUint16(8, 14)
	if !c.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(c))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}
func (s Value) Lf64() (capnp.Float64List, error) {
	if capnp.Struct(s).Uint16(8) != 15 {
		panic("Which() != lf64")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Float64List(p.List()), err
}

func (s Value) HasLf64() bool {
	if capnp.Struct(s).Uint16(8) != 15 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLf64(v capnp.Float64List) error {
	capnp.Struct(s).SetUint16(8, 15)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLf64 sets the lf64 field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Value) NewLf64(n int32) (capnp.Float64List, error) {
	capnp.Struct(s).SetUint16(8, 15)
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Lf32() (capnp.Float32List, error) {
	if capnp.Struct(s).Uint16(8) != 16 {
		panic("Which() != lf32")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Float32List(p.List()), err
}

func (s Value) HasLf32() bool {
	if capnp.Struct(s).Uint16(8) != 16 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLf32(v capnp.Float32List) error {
	capnp.Struct(s).SetUint16(8, 16)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLf32 sets the lf32 field to a newly
// allocated capnp.Float32List, preferring placement in s's segment.
func (s Value) NewLf32(n int32) (capnp.Float32List, error) {
	capnp.Struct(s).SetUint16(8, 16)
	l, err := capnp.NewFloat32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float32List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Li64() (capnp.Int64List, error) {
	if capnp.Struct(s).Uint16(8) != 17 {
		panic("Which() != li64")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Int64List(p.List()), err
}

func (s Value) HasLi64() bool {
	if capnp.Struct(s).Uint16(8) != 17 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLi64(v capnp.Int64List) error {
	capnp.Struct(s).SetUint16(8, 17)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLi64 sets the li64 field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Value) NewLi64(n int32) (capnp.Int64List, error) {
	capnp.Struct(s).SetUint16(8, 17)
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Li32() (capnp.Int32List, error) {
	if capnp.Struct(s).Uint16(8) != 18 {
		panic("Which() != li32")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Int32List(p.List()), err
}

func (s Value) HasLi32() bool {
	if capnp.Struct(s).Uint16(8) != 18 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLi32(v capnp.Int32List) error {
	capnp.Struct(s).SetUint16(8, 18)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLi32 sets the li32 field to a newly
// allocated capnp.Int32List, preferring placement in s's segment.
func (s Value) NewLi32(n int32) (capnp.Int32List, error) {
	capnp.Struct(s).SetUint16(8, 18)
	l, err := capnp.NewInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int32List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Li16() (capnp.Int16List, error) {
	if capnp.Struct(s).Uint16(8) != 19 {
		panic("Which() != li16")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Int16List(p.List()), err
}

func (s Value) HasLi16() bool {
	if capnp.Struct(s).Uint16(8) != 19 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLi16(v capnp.Int16List) error {
	capnp.Struct(s).SetUint16(8, 19)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLi16 sets the li16 field to a newly
// allocated capnp.Int16List, preferring placement in s's segment.
func (s Value) NewLi16(n int32) (capnp.Int16List, error) {
	capnp.Struct(s).SetUint16(8, 19)
	l, err := capnp.NewInt16List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int16List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Li8() (capnp.Int8List, error) {
	if capnp.Struct(s).Uint16(8) != 20 {
		panic("Which() != li8")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Int8List(p.List()), err
}

func (s Value) HasLi8() bool {
	if capnp.Struct(s).Uint16(8) != 20 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLi8(v capnp.Int8List) error {
	capnp.Struct(s).SetUint16(8, 20)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLi8 sets the li8 field to a newly
// allocated capnp.Int8List, preferring placement in s's segment.
func (s Value) NewLi8(n int32) (capnp.Int8List, error) {
	capnp.Struct(s).SetUint16(8, 20)
	l, err := capnp.NewInt8List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int8List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Lui64() (capnp.UInt64List, error) {
	if capnp.Struct(s).Uint16(8) != 21 {
		panic("Which() != lui64")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt64List(p.List()), err
}

func (s Value) HasLui64() bool {
	if capnp.Struct(s).Uint16(8) != 21 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLui64(v capnp.UInt64List) error {
	capnp.Struct(s).SetUint16(8, 21)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLui64 sets the lui64 field to a newly
// allocated capnp.UInt64List, preferring placement in s's segment.
func (s Value) NewLui64(n int32) (capnp.UInt64List, error) {
	capnp.Struct(s).SetUint16(8, 21)
	l, err := capnp.NewUInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt64List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Lui32() (capnp.UInt32List, error) {
	if capnp.Struct(s).Uint16(8) != 22 {
		panic("Which() != lui32")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt32List(p.List()), err
}

func (s Value) HasLui32() bool {
	if capnp.Struct(s).Uint16(8) != 22 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLui32(v capnp.UInt32List) error {
	capnp.Struct(s).SetUint16(8, 22)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLui32 sets the lui32 field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s Value) NewLui32(n int32) (capnp.UInt32List, error) {
	capnp.Struct(s).SetUint16(8, 22)
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Lui16() (capnp.UInt16List, error) {
	if capnp.Struct(s).Uint16(8) != 23 {
		panic("Which() != lui16")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt16List(p.List()), err
}

func (s Value) HasLui16() bool {
	if capnp.Struct(s).Uint16(8) != 23 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLui16(v capnp.UInt16List) error {
	capnp.Struct(s).SetUint16(8, 23)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLui16 sets the lui16 field to a newly
// allocated capnp.UInt16List, preferring placement in s's segment.
func (s Value) NewLui16(n int32) (capnp.UInt16List, error) {
	capnp.Struct(s).SetUint16(8, 23)
	l, err := capnp.NewUInt16List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt16List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Lui8() (capnp.UInt8List, error) {
	if capnp.Struct(s).Uint16(8) != 24 {
		panic("Which() != lui8")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt8List(p.List()), err
}

func (s Value) HasLui8() bool {
	if capnp.Struct(s).Uint16(8) != 24 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLui8(v capnp.UInt8List) error {
	capnp.Struct(s).SetUint16(8, 24)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLui8 sets the lui8 field to a newly
// allocated capnp.UInt8List, preferring placement in s's segment.
func (s Value) NewLui8(n int32) (capnp.UInt8List, error) {
	capnp.Struct(s).SetUint16(8, 24)
	l, err := capnp.NewUInt8List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt8List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Lb() (capnp.BitList, error) {
	if capnp.Struct(s).Uint16(8) != 25 {
		panic("Which() != lb")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.BitList(p.List()), err
}

func (s Value) HasLb() bool {
	if capnp.Struct(s).Uint16(8) != 25 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLb(v capnp.BitList) error {
	capnp.Struct(s).SetUint16(8, 25)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLb sets the lb field to a newly
// allocated capnp.BitList, preferring placement in s's segment.
func (s Value) NewLb(n int32) (capnp.BitList, error) {
	capnp.Struct(s).SetUint16(8, 25)
	l, err := capnp.NewBitList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.BitList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Lt() (capnp.TextList, error) {
	if capnp.Struct(s).Uint16(8) != 26 {
		panic("Which() != lt")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s Value) HasLt() bool {
	if capnp.Struct(s).Uint16(8) != 26 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLt(v capnp.TextList) error {
	capnp.Struct(s).SetUint16(8, 26)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLt sets the lt field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Value) NewLt(n int32) (capnp.TextList, error) {
	capnp.Struct(s).SetUint16(8, 26)
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Ld() (capnp.DataList, error) {
	if capnp.Struct(s).Uint16(8) != 27 {
		panic("Which() != ld")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.DataList(p.List()), err
}

func (s Value) HasLd() bool {
	if capnp.Struct(s).Uint16(8) != 27 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLd(v capnp.DataList) error {
	capnp.Struct(s).SetUint16(8, 27)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLd sets the ld field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s Value) NewLd(n int32) (capnp.DataList, error) {
	capnp.Struct(s).SetUint16(8, 27)
	l, err := capnp.NewDataList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Lcap() (capnp.PointerList, error) {
	if capnp.Struct(s).Uint16(8) != 28 {
		panic("Which() != lcap")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.PointerList(p.List()), err
}

func (s Value) HasLcap() bool {
	if capnp.Struct(s).Uint16(8) != 28 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLcap(v capnp.PointerList) error {
	capnp.Struct(s).SetUint16(8, 28)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLcap sets the lcap field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s Value) NewLcap(n int32) (capnp.PointerList, error) {
	capnp.Struct(s).SetUint16(8, 28)
	l, err := capnp.NewPointerList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value) Lpair() (Pair_List, error) {
	if capnp.Struct(s).Uint16(8) != 29 {
		panic("Which() != lpair")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Pair_List(p.List()), err
}

func (s Value) HasLpair() bool {
	if capnp.Struct(s).Uint16(8) != 29 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetLpair(v Pair_List) error {
	capnp.Struct(s).SetUint16(8, 29)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLpair sets the lpair field to a newly
// allocated Pair_List, preferring placement in s's segment.
func (s Value) NewLpair(n int32) (Pair_List, error) {
	capnp.Struct(s).SetUint16(8, 29)
	l, err := NewPair_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Pair_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Value_List is a list of Value.
type Value_List = capnp.StructList[Value]

// NewValue creates a new list of Value.
func NewValue_List(s *capnp.Segment, sz int32) (Value_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[Value](l), err
}

// Value_Future is a wrapper for a Value promised by a client call.
type Value_Future struct{ *capnp.Future }

func (f Value_Future) Struct() (Value, error) {
	p, err := f.Future.Ptr()
	return Value(p.Struct()), err
}
func (p Value_Future) P() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p Value_Future) Cap() capnp.Client {
	return p.Future.Field(0, nil).Client()
}

type Factory capnp.Client

// Factory_TypeID is the unique identifier for the type Factory.
const Factory_TypeID = 0xa869f50b8c586ed9

func (c Factory) Create(ctx context.Context, params func(Factory_create_Params) error) (Factory_create_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xa869f50b8c586ed9,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Factory",
			MethodName:    "create",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Factory_create_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Factory_create_Results_Future{Future: ans.Future()}, release

}

func (c Factory) Info(ctx context.Context, params func(Identifiable_info_Params) error) (IdInformation_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Identifiable_info_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IdInformation_Future{Future: ans.Future()}, release

}

func (c Factory) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Factory) String() string {
	return "Factory(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Factory) AddRef() Factory {
	return Factory(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Factory) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Factory) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Factory) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Factory) DecodeFromPtr(p capnp.Ptr) Factory {
	return Factory(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Factory) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Factory) IsSame(other Factory) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Factory) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Factory) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Factory_Server is a Factory with a local implementation.
type Factory_Server interface {
	Create(context.Context, Factory_create) error

	Info(context.Context, Identifiable_info) error
}

// Factory_NewServer creates a new Server from an implementation of Factory_Server.
func Factory_NewServer(s Factory_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Factory_Methods(nil, s), s, c)
}

// Factory_ServerToClient creates a new Client from an implementation of Factory_Server.
// The caller is responsible for calling Release on the returned Client.
func Factory_ServerToClient(s Factory_Server) Factory {
	return Factory(capnp.NewClient(Factory_NewServer(s)))
}

// Factory_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Factory_Methods(methods []server.Method, s Factory_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xa869f50b8c586ed9,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Factory",
			MethodName:    "create",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Create(ctx, Factory_create{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Info(ctx, Identifiable_info{call})
		},
	})

	return methods
}

// Factory_create holds the state for a server call to Factory.create.
// See server.Call for documentation.
type Factory_create struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Factory_create) Args() Factory_create_Params {
	return Factory_create_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Factory_create) AllocResults() (Factory_create_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Factory_create_Results(r), err
}

// Factory_List is a list of Factory.
type Factory_List = capnp.CapList[Factory]

// NewFactory_List creates a new list of Factory.
func NewFactory_List(s *capnp.Segment, sz int32) (Factory_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Factory](l), err
}

type Factory_create_Params capnp.Struct

// Factory_create_Params_TypeID is the unique identifier for the type Factory_create_Params.
const Factory_create_Params_TypeID = 0xfd058bbd1f9508cd

func NewFactory_create_Params(s *capnp.Segment) (Factory_create_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Factory_create_Params(st), err
}

func NewRootFactory_create_Params(s *capnp.Segment) (Factory_create_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Factory_create_Params(st), err
}

func ReadRootFactory_create_Params(msg *capnp.Message) (Factory_create_Params, error) {
	root, err := msg.Root()
	return Factory_create_Params(root.Struct()), err
}

func (s Factory_create_Params) String() string {
	str, _ := text.Marshal(0xfd058bbd1f9508cd, capnp.Struct(s))
	return str
}

func (s Factory_create_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Factory_create_Params) DecodeFromPtr(p capnp.Ptr) Factory_create_Params {
	return Factory_create_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Factory_create_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Factory_create_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Factory_create_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Factory_create_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Factory_create_Params_List is a list of Factory_create_Params.
type Factory_create_Params_List = capnp.StructList[Factory_create_Params]

// NewFactory_create_Params creates a new list of Factory_create_Params.
func NewFactory_create_Params_List(s *capnp.Segment, sz int32) (Factory_create_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Factory_create_Params](l), err
}

// Factory_create_Params_Future is a wrapper for a Factory_create_Params promised by a client call.
type Factory_create_Params_Future struct{ *capnp.Future }

func (f Factory_create_Params_Future) Struct() (Factory_create_Params, error) {
	p, err := f.Future.Ptr()
	return Factory_create_Params(p.Struct()), err
}

type Factory_create_Results capnp.Struct

// Factory_create_Results_TypeID is the unique identifier for the type Factory_create_Results.
const Factory_create_Results_TypeID = 0xd010f77f1bdf0522

func NewFactory_create_Results(s *capnp.Segment) (Factory_create_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Factory_create_Results(st), err
}

func NewRootFactory_create_Results(s *capnp.Segment) (Factory_create_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Factory_create_Results(st), err
}

func ReadRootFactory_create_Results(msg *capnp.Message) (Factory_create_Results, error) {
	root, err := msg.Root()
	return Factory_create_Results(root.Struct()), err
}

func (s Factory_create_Results) String() string {
	str, _ := text.Marshal(0xd010f77f1bdf0522, capnp.Struct(s))
	return str
}

func (s Factory_create_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Factory_create_Results) DecodeFromPtr(p capnp.Ptr) Factory_create_Results {
	return Factory_create_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Factory_create_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Factory_create_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Factory_create_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Factory_create_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Factory_create_Results) Out() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Factory_create_Results) HasOut() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Factory_create_Results) SetOut(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// Factory_create_Results_List is a list of Factory_create_Results.
type Factory_create_Results_List = capnp.StructList[Factory_create_Results]

// NewFactory_create_Results creates a new list of Factory_create_Results.
func NewFactory_create_Results_List(s *capnp.Segment, sz int32) (Factory_create_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Factory_create_Results](l), err
}

// Factory_create_Results_Future is a wrapper for a Factory_create_Results promised by a client call.
type Factory_create_Results_Future struct{ *capnp.Future }

func (f Factory_create_Results_Future) Struct() (Factory_create_Results, error) {
	p, err := f.Future.Ptr()
	return Factory_create_Results(p.Struct()), err
}
func (p Factory_create_Results_Future) Out() *capnp.Future {
	return p.Future.Field(0, nil)
}

type IOFactory capnp.Client

// IOFactory_TypeID is the unique identifier for the type IOFactory.
const IOFactory_TypeID = 0x9771e5b5c6a27b68

func (c IOFactory) Produce(ctx context.Context, params func(IOFactory_produce_Params) error) (IOFactory_produce_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9771e5b5c6a27b68,
			MethodID:      0,
			InterfaceName: "common/common.capnp:IOFactory",
			MethodName:    "produce",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IOFactory_produce_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IOFactory_produce_Results_Future{Future: ans.Future()}, release

}

func (c IOFactory) Info(ctx context.Context, params func(Identifiable_info_Params) error) (IdInformation_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Identifiable_info_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IdInformation_Future{Future: ans.Future()}, release

}

func (c IOFactory) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c IOFactory) String() string {
	return "IOFactory(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c IOFactory) AddRef() IOFactory {
	return IOFactory(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c IOFactory) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c IOFactory) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c IOFactory) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (IOFactory) DecodeFromPtr(p capnp.Ptr) IOFactory {
	return IOFactory(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c IOFactory) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c IOFactory) IsSame(other IOFactory) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c IOFactory) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c IOFactory) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A IOFactory_Server is a IOFactory with a local implementation.
type IOFactory_Server interface {
	Produce(context.Context, IOFactory_produce) error

	Info(context.Context, Identifiable_info) error
}

// IOFactory_NewServer creates a new Server from an implementation of IOFactory_Server.
func IOFactory_NewServer(s IOFactory_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(IOFactory_Methods(nil, s), s, c)
}

// IOFactory_ServerToClient creates a new Client from an implementation of IOFactory_Server.
// The caller is responsible for calling Release on the returned Client.
func IOFactory_ServerToClient(s IOFactory_Server) IOFactory {
	return IOFactory(capnp.NewClient(IOFactory_NewServer(s)))
}

// IOFactory_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func IOFactory_Methods(methods []server.Method, s IOFactory_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9771e5b5c6a27b68,
			MethodID:      0,
			InterfaceName: "common/common.capnp:IOFactory",
			MethodName:    "produce",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Produce(ctx, IOFactory_produce{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Info(ctx, Identifiable_info{call})
		},
	})

	return methods
}

// IOFactory_produce holds the state for a server call to IOFactory.produce.
// See server.Call for documentation.
type IOFactory_produce struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IOFactory_produce) Args() IOFactory_produce_Params {
	return IOFactory_produce_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IOFactory_produce) AllocResults() (IOFactory_produce_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IOFactory_produce_Results(r), err
}

// IOFactory_List is a list of IOFactory.
type IOFactory_List = capnp.CapList[IOFactory]

// NewIOFactory_List creates a new list of IOFactory.
func NewIOFactory_List(s *capnp.Segment, sz int32) (IOFactory_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[IOFactory](l), err
}

type IOFactory_produce_Params capnp.Struct

// IOFactory_produce_Params_TypeID is the unique identifier for the type IOFactory_produce_Params.
const IOFactory_produce_Params_TypeID = 0x9b38b2f4ce5b565d

func NewIOFactory_produce_Params(s *capnp.Segment) (IOFactory_produce_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IOFactory_produce_Params(st), err
}

func NewRootIOFactory_produce_Params(s *capnp.Segment) (IOFactory_produce_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IOFactory_produce_Params(st), err
}

func ReadRootIOFactory_produce_Params(msg *capnp.Message) (IOFactory_produce_Params, error) {
	root, err := msg.Root()
	return IOFactory_produce_Params(root.Struct()), err
}

func (s IOFactory_produce_Params) String() string {
	str, _ := text.Marshal(0x9b38b2f4ce5b565d, capnp.Struct(s))
	return str
}

func (s IOFactory_produce_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IOFactory_produce_Params) DecodeFromPtr(p capnp.Ptr) IOFactory_produce_Params {
	return IOFactory_produce_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IOFactory_produce_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IOFactory_produce_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IOFactory_produce_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IOFactory_produce_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IOFactory_produce_Params) In() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s IOFactory_produce_Params) HasIn() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IOFactory_produce_Params) SetIn(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// IOFactory_produce_Params_List is a list of IOFactory_produce_Params.
type IOFactory_produce_Params_List = capnp.StructList[IOFactory_produce_Params]

// NewIOFactory_produce_Params creates a new list of IOFactory_produce_Params.
func NewIOFactory_produce_Params_List(s *capnp.Segment, sz int32) (IOFactory_produce_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IOFactory_produce_Params](l), err
}

// IOFactory_produce_Params_Future is a wrapper for a IOFactory_produce_Params promised by a client call.
type IOFactory_produce_Params_Future struct{ *capnp.Future }

func (f IOFactory_produce_Params_Future) Struct() (IOFactory_produce_Params, error) {
	p, err := f.Future.Ptr()
	return IOFactory_produce_Params(p.Struct()), err
}
func (p IOFactory_produce_Params_Future) In() *capnp.Future {
	return p.Future.Field(0, nil)
}

type IOFactory_produce_Results capnp.Struct

// IOFactory_produce_Results_TypeID is the unique identifier for the type IOFactory_produce_Results.
const IOFactory_produce_Results_TypeID = 0x8417f479600047f0

func NewIOFactory_produce_Results(s *capnp.Segment) (IOFactory_produce_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IOFactory_produce_Results(st), err
}

func NewRootIOFactory_produce_Results(s *capnp.Segment) (IOFactory_produce_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IOFactory_produce_Results(st), err
}

func ReadRootIOFactory_produce_Results(msg *capnp.Message) (IOFactory_produce_Results, error) {
	root, err := msg.Root()
	return IOFactory_produce_Results(root.Struct()), err
}

func (s IOFactory_produce_Results) String() string {
	str, _ := text.Marshal(0x8417f479600047f0, capnp.Struct(s))
	return str
}

func (s IOFactory_produce_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IOFactory_produce_Results) DecodeFromPtr(p capnp.Ptr) IOFactory_produce_Results {
	return IOFactory_produce_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IOFactory_produce_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IOFactory_produce_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IOFactory_produce_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IOFactory_produce_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IOFactory_produce_Results) Out() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s IOFactory_produce_Results) HasOut() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IOFactory_produce_Results) SetOut(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// IOFactory_produce_Results_List is a list of IOFactory_produce_Results.
type IOFactory_produce_Results_List = capnp.StructList[IOFactory_produce_Results]

// NewIOFactory_produce_Results creates a new list of IOFactory_produce_Results.
func NewIOFactory_produce_Results_List(s *capnp.Segment, sz int32) (IOFactory_produce_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IOFactory_produce_Results](l), err
}

// IOFactory_produce_Results_Future is a wrapper for a IOFactory_produce_Results promised by a client call.
type IOFactory_produce_Results_Future struct{ *capnp.Future }

func (f IOFactory_produce_Results_Future) Struct() (IOFactory_produce_Results, error) {
	p, err := f.Future.Ptr()
	return IOFactory_produce_Results(p.Struct()), err
}
func (p IOFactory_produce_Results_Future) Out() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Pair capnp.Struct

// Pair_TypeID is the unique identifier for the type Pair.
const Pair_TypeID = 0xb9d4864725174733

func NewPair(s *capnp.Segment) (Pair, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pair(st), err
}

func NewRootPair(s *capnp.Segment) (Pair, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pair(st), err
}

func ReadRootPair(msg *capnp.Message) (Pair, error) {
	root, err := msg.Root()
	return Pair(root.Struct()), err
}

func (s Pair) String() string {
	str, _ := text.Marshal(0xb9d4864725174733, capnp.Struct(s))
	return str
}

func (s Pair) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Pair) DecodeFromPtr(p capnp.Ptr) Pair {
	return Pair(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Pair) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Pair) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Pair) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Pair) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Pair) Fst() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Pair) HasFst() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Pair) SetFst(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}
func (s Pair) Snd() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s Pair) HasSnd() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Pair) SetSnd(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// Pair_List is a list of Pair.
type Pair_List = capnp.StructList[Pair]

// NewPair creates a new list of Pair.
func NewPair_List(s *capnp.Segment, sz int32) (Pair_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Pair](l), err
}

// Pair_Future is a wrapper for a Pair promised by a client call.
type Pair_Future struct{ *capnp.Future }

func (f Pair_Future) Struct() (Pair, error) {
	p, err := f.Future.Ptr()
	return Pair(p.Struct()), err
}
func (p Pair_Future) Fst() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p Pair_Future) Snd() *capnp.Future {
	return p.Future.Field(1, nil)
}

type Holder capnp.Client

// Holder_TypeID is the unique identifier for the type Holder.
const Holder_TypeID = 0xc83045ccbb0b6ac5

func (c Holder) Value(ctx context.Context, params func(Holder_value_Params) error) (Holder_value_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc83045ccbb0b6ac5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Holder",
			MethodName:    "value",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Holder_value_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Holder_value_Results_Future{Future: ans.Future()}, release

}

func (c Holder) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Holder) String() string {
	return "Holder(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Holder) AddRef() Holder {
	return Holder(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Holder) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Holder) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Holder) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Holder) DecodeFromPtr(p capnp.Ptr) Holder {
	return Holder(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Holder) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Holder) IsSame(other Holder) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Holder) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Holder) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Holder_Server is a Holder with a local implementation.
type Holder_Server interface {
	Value(context.Context, Holder_value) error
}

// Holder_NewServer creates a new Server from an implementation of Holder_Server.
func Holder_NewServer(s Holder_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Holder_Methods(nil, s), s, c)
}

// Holder_ServerToClient creates a new Client from an implementation of Holder_Server.
// The caller is responsible for calling Release on the returned Client.
func Holder_ServerToClient(s Holder_Server) Holder {
	return Holder(capnp.NewClient(Holder_NewServer(s)))
}

// Holder_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Holder_Methods(methods []server.Method, s Holder_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc83045ccbb0b6ac5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Holder",
			MethodName:    "value",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Value(ctx, Holder_value{call})
		},
	})

	return methods
}

// Holder_value holds the state for a server call to Holder.value.
// See server.Call for documentation.
type Holder_value struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Holder_value) Args() Holder_value_Params {
	return Holder_value_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Holder_value) AllocResults() (Holder_value_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Holder_value_Results(r), err
}

// Holder_List is a list of Holder.
type Holder_List = capnp.CapList[Holder]

// NewHolder_List creates a new list of Holder.
func NewHolder_List(s *capnp.Segment, sz int32) (Holder_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Holder](l), err
}

type Holder_value_Params capnp.Struct

// Holder_value_Params_TypeID is the unique identifier for the type Holder_value_Params.
const Holder_value_Params_TypeID = 0x966d054acf5f578d

func NewHolder_value_Params(s *capnp.Segment) (Holder_value_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Holder_value_Params(st), err
}

func NewRootHolder_value_Params(s *capnp.Segment) (Holder_value_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Holder_value_Params(st), err
}

func ReadRootHolder_value_Params(msg *capnp.Message) (Holder_value_Params, error) {
	root, err := msg.Root()
	return Holder_value_Params(root.Struct()), err
}

func (s Holder_value_Params) String() string {
	str, _ := text.Marshal(0x966d054acf5f578d, capnp.Struct(s))
	return str
}

func (s Holder_value_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Holder_value_Params) DecodeFromPtr(p capnp.Ptr) Holder_value_Params {
	return Holder_value_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Holder_value_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Holder_value_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Holder_value_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Holder_value_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Holder_value_Params_List is a list of Holder_value_Params.
type Holder_value_Params_List = capnp.StructList[Holder_value_Params]

// NewHolder_value_Params creates a new list of Holder_value_Params.
func NewHolder_value_Params_List(s *capnp.Segment, sz int32) (Holder_value_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Holder_value_Params](l), err
}

// Holder_value_Params_Future is a wrapper for a Holder_value_Params promised by a client call.
type Holder_value_Params_Future struct{ *capnp.Future }

func (f Holder_value_Params_Future) Struct() (Holder_value_Params, error) {
	p, err := f.Future.Ptr()
	return Holder_value_Params(p.Struct()), err
}

type Holder_value_Results capnp.Struct

// Holder_value_Results_TypeID is the unique identifier for the type Holder_value_Results.
const Holder_value_Results_TypeID = 0xa18bd34aee32cc89

func NewHolder_value_Results(s *capnp.Segment) (Holder_value_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Holder_value_Results(st), err
}

func NewRootHolder_value_Results(s *capnp.Segment) (Holder_value_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Holder_value_Results(st), err
}

func ReadRootHolder_value_Results(msg *capnp.Message) (Holder_value_Results, error) {
	root, err := msg.Root()
	return Holder_value_Results(root.Struct()), err
}

func (s Holder_value_Results) String() string {
	str, _ := text.Marshal(0xa18bd34aee32cc89, capnp.Struct(s))
	return str
}

func (s Holder_value_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Holder_value_Results) DecodeFromPtr(p capnp.Ptr) Holder_value_Results {
	return Holder_value_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Holder_value_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Holder_value_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Holder_value_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Holder_value_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Holder_value_Results) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Holder_value_Results) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Holder_value_Results) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// Holder_value_Results_List is a list of Holder_value_Results.
type Holder_value_Results_List = capnp.StructList[Holder_value_Results]

// NewHolder_value_Results creates a new list of Holder_value_Results.
func NewHolder_value_Results_List(s *capnp.Segment, sz int32) (Holder_value_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Holder_value_Results](l), err
}

// Holder_value_Results_Future is a wrapper for a Holder_value_Results promised by a client call.
type Holder_value_Results_Future struct{ *capnp.Future }

func (f Holder_value_Results_Future) Struct() (Holder_value_Results, error) {
	p, err := f.Future.Ptr()
	return Holder_value_Results(p.Struct()), err
}
func (p Holder_value_Results_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type IdentifiableHolder capnp.Client

// IdentifiableHolder_TypeID is the unique identifier for the type IdentifiableHolder.
const IdentifiableHolder_TypeID = 0xee543d7c305d56f6

func (c IdentifiableHolder) Info(ctx context.Context, params func(Identifiable_info_Params) error) (IdInformation_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Identifiable_info_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IdInformation_Future{Future: ans.Future()}, release

}

func (c IdentifiableHolder) Value(ctx context.Context, params func(Holder_value_Params) error) (Holder_value_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc83045ccbb0b6ac5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Holder",
			MethodName:    "value",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Holder_value_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Holder_value_Results_Future{Future: ans.Future()}, release

}

func (c IdentifiableHolder) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c IdentifiableHolder) String() string {
	return "IdentifiableHolder(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c IdentifiableHolder) AddRef() IdentifiableHolder {
	return IdentifiableHolder(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c IdentifiableHolder) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c IdentifiableHolder) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c IdentifiableHolder) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (IdentifiableHolder) DecodeFromPtr(p capnp.Ptr) IdentifiableHolder {
	return IdentifiableHolder(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c IdentifiableHolder) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c IdentifiableHolder) IsSame(other IdentifiableHolder) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c IdentifiableHolder) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c IdentifiableHolder) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A IdentifiableHolder_Server is a IdentifiableHolder with a local implementation.
type IdentifiableHolder_Server interface {
	Info(context.Context, Identifiable_info) error

	Value(context.Context, Holder_value) error
}

// IdentifiableHolder_NewServer creates a new Server from an implementation of IdentifiableHolder_Server.
func IdentifiableHolder_NewServer(s IdentifiableHolder_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(IdentifiableHolder_Methods(nil, s), s, c)
}

// IdentifiableHolder_ServerToClient creates a new Client from an implementation of IdentifiableHolder_Server.
// The caller is responsible for calling Release on the returned Client.
func IdentifiableHolder_ServerToClient(s IdentifiableHolder_Server) IdentifiableHolder {
	return IdentifiableHolder(capnp.NewClient(IdentifiableHolder_NewServer(s)))
}

// IdentifiableHolder_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func IdentifiableHolder_Methods(methods []server.Method, s IdentifiableHolder_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Identifiable",
			MethodName:    "info",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Info(ctx, Identifiable_info{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc83045ccbb0b6ac5,
			MethodID:      0,
			InterfaceName: "common/common.capnp:Holder",
			MethodName:    "value",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Value(ctx, Holder_value{call})
		},
	})

	return methods
}

// IdentifiableHolder_List is a list of IdentifiableHolder.
type IdentifiableHolder_List = capnp.CapList[IdentifiableHolder]

// NewIdentifiableHolder_List creates a new list of IdentifiableHolder.
func NewIdentifiableHolder_List(s *capnp.Segment, sz int32) (IdentifiableHolder_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[IdentifiableHolder](l), err
}

const schema_99f1c9a775a88ac9 = "x\xda\x9c\x97\x7f\x8cTW\x15\xc7\xcf\xf7\xdd7\xfb\xf6" +
	"'\xb3o\xee\xa3[\x16\xda\x0d\x94F\xbbZdw(" +
	"Y7\xad,\x04X\x96@\xd8\xb7\xbb U\x88\x0c;" +
	"\xb3\xee\x90\x99\xf7\x1e3o\x94]\x1a\x89Ic\xa4\x94" +
	"DM*\x1a\xad\x11cb\xffh\xd2\x80\xf2\x87\x1a\x13" +
	"Qk\xda\x82V-\xfd\x83\xa6\xd1P\xa5\xa5\xad [" +
	"Yjm\xe1\x9asg\xdf\xcc\xecvQb\xf6\x8f\x9d" +
	"w>\xf7\x9d{\xee9\xe7\x9es\xde\xca\xe3\x1d}f" +
	"W\x8b\xf5*\x19C\x8d\xb1\xba\xf7\xaf\xf6\xef\x99\xb8\xd6" +
	"\xf6\xa8}7\x88b\xb0Z\x91|3_\x00AN\xe7" +
	"\xd7\x10\xd4\xd1O\x7f\xee\xc5\xcd\xb1\xfc7\xc9^\x0c\"" +
	"\x93\xf9Bo\x1d\xc8T\xe3\x07\x7f\xf0\xdbS\x17\xf7\x1f" +
	"#\xdb\x11\xea\xf9\xc7\x9e*\xfd\xe8\xf9\xa9o\x13Q+" +
	"\xe4\x8d\xfc;\xb2\xc1\xb3\x88d\xcc\xeb\x97\xdb\xbd6\xb9" +
	"\xdbkSG\xede\xe2\xe9\x9b\xaf\x1f#7\x01\xa8\xce" +
	"\xeb\xd6\x91_\x7f\xec\xadKd\xf2\xba\x87\xbd\x9f\xc9\x94" +
	"~c\xb7\xf7\x0cA\xed\xde\xf1\xd9\xdf_;\xd9\xf3\x1d" +
	"\xaa\xb1k\xda\xdb\xc7v\xc1g\xbbN\xfcy\xe0\xee\x17" +
	"\x8f?\xf6$\xd9K\xb5]D\xc9\xa5\xfe>\xb6k\xdb" +
	"\xb1Sm\x9f\xfa\xcd\xdb\xdf#\xfb\x1eC\x8d\x9c{\xe1" +
	"\xf3G\x1ar\x97\x89\x90l\xf1\xd7A\xde\xe5\xf3&\x8b" +
	"\xfcC\x04u\xf8l\xf7\x95\xcd/\x1d9^>[y" +
	"\x93\xed\xfef\xde$\xa579\xef\xed|\xbci:\xfb" +
	"\xd4<G\xfc\xb2\xff\x9a<\xaau\x1d\xf6\xfb\xe5y\xbf" +
	"M^\xf0\xe3\xea\xe5M\xdf}\xf8\xcc\x1f\x9f99\xe7" +
	"\x05$_\xf6\x1b!/\xea\xf5\x17\xfc~\xd9\x10XD" +
	"*\xd9\xdfvo\xffW\xce\xfd\x94l\x07\xd5\xd51\xc3" +
	"j\x85\x9c\xf2_\x907\xf4\xfa\xf7\xfc/\x12\xc9|\xd0" +
	"\xa6\x9e\xdd\xd7\xf4\xf3\xb3\x1bV>7\x8f9\xd9\xe0\x15" +
	"Yb\xa5r\x7f\xd0/O\x07\x96<\x1d\xc4\xd5\xb2\xd8" +
	"_\x16\x1fz\xb7\xf5\x0fd/\xa9\x1c\xf0T\xf0\x19>" +
	"\xe0\xe9\x80\x0f\xf8\xd2+\xe2\xe6\x99/\x9d97\xc7\x02" +
	"\xc1\xee\xbc\x10$ \xa7\xb4\xce\xcb\x01\xc7d\xe3\xc9\xe2" +
	"p\xf2\x1b\xa5\x0b\xe4:0\xaa\xab7\xc0\xba\x1b\xa6<" +
	"\xbc\xffO\xf2\x89\xfd\xfc\xe2\xd7\xf7\x1f\xab#\xa8\xb3{" +
	"\x7fubh\xfa\xcc%r\xef\x01\xaa\x81\xd8\x0e\x0b&" +
	"Q2?\xa1\xa391\xf1\x06\xd5P\xd7A\xad!`" +
	"}['\xdb!wO\xb6\x11\xc9\xcc$\x1br}\xc7" +
	"\xee\x95\x8f<4r\xe5\xc3~H^\x9c\xec\x85\x9c\x9e" +
	"d\xa3\xa7&-95\xf9\x11\xd9u0\xae~W\xff" +
	"D\xc7/\x8e\xc4n\x94\x1d\xa1\xb3\xf8\xde\x83C \xf5" +
	"\x7f\xfc\xfdX\x8d\xfa\xf9\xbc\xef}b\xd4\xd4\xffW\x8c" +
	"\xa6\x02/\xe8\x1d\xd8\xb615\x1a\xfa\x85\x89\x15A\xc1" +
	"O\x97F3\xcb\x872\x1d\xc5R.,\xba\xa60\x89" +
	"L\x10\xd9-\xcb\x88\xdcz\x01\xd71`\xf9\xa5\x10\x89" +
	"\x18P\xbdIDH\x10*\xfa\xadZ\xfd\x9b\xfc\\:" +
	"SX\xf1\x85T\xae\x94Y>\x98*\xa4\xf2E\x8a\x16" +
	"\xce\xb5\xa3C\x1b2\x08\xb8\xa6\x88\x11Un\x13\xae\xf6" +
	"S\xf9\xb6\xdb\xeb\x88\xd66c\xed\x12\xd8\xf7[\x87f" +
	",\xb6\xd1\xe1\x9aF\x8d=`\x9b\xe7\x13\xf6\xc15\x81" +
	"j\xba\x13\xad\xad\x87\x1d\xeb\xb6c\xbd\x1d\x03^P\x0a" +
	"\xd7l+\x85A)\x8c\x8e\x92F*\xcch\x03\xd7\x04" +
	"\xbd\xebSa\x86mk\xae\xb8eC'\x91\xdb'\xe0" +
	"n1`\xc3p\xf4\xbe\x03\xddD\xeez\x01w\xd0\x80" +
	"m\x08\x07\x06\x91\xbd\x95\x1d\xb8I\xc0\x1d1\x10\x9f\xc8" +
	"\xa4\x0a\x10d@\x10:\xf2\xbe\x17\x8e\xa3\x8e\x0c\xd4\x11" +
	"\xactj\"\xfa}\xbb\xe1\x1aL\xc5\xd9\xa9\xb5\xd1j" +
	"\xafFKd=$\xfeK\xacf+Og\xbc0;" +
	"\x96M\xed\xcdeVd\xbd1?R>\xff\xf2\xe1\xb0" +
	"P\x1a\x0dK\x85Lz$s \\12\x11d\x88" +
	"\x1dT>\xf2\x03\xfb\x88\x00\xbb\xab\x93\x08\x86}\xdf2" +
	"\"\x08{)?\x99\xf6\xa2!\"U\xf2\x8aZ\x01\xc5" +
	"YE|_\xd1\xf7\xac\x03\xf9\\<\xf4\xf39U\x0c" +
	"K\x85\xf4\xc4P\x8606\xff\xe6\xb3\xf2j(\xa33" +
	"\x96\xa8\xd6\x0b\xddU/t\xe8e\xda\x11\x95b4\xc7" +
	"\x11F\xadr\xf6\xb15+\x15\xa3\x9b\x88\xa86\xd9v" +
	"oM*\xae\x19-dRa%\x13+\x05\xb86\x13" +
	"g\x09\xe7\xc9D\x136z\xe7$\xe0\xa8\xb8U|\x88" +
	"\xaa\xc6EM\x05Q]\xb4\xedN2\xec\x98\x15\xe7 " +
	"\xf6a\x10\xb78\xe7`*[(+\xaa\xaf\xf8\x8d#" +
	"\xe5.\x17pWrR\xa3\x9c\xd4\xf7\xb3\xf0\xa3\x02\xee" +
	"*\x03\xd6X1\xd4\xae\xac\xf4\x81\xb2+\xad\xa2\x97." +
	"\x17\x869@\xdf\xb1\x84\x1dK`#\x86\xe77\x84\xa3" +
	")2\x85\xea\x91\xa2\xfe\x8d\xa8\xd9\xd9vw\x8d\xbf\xcb" +
	"\x01\x8d<[\x89i\xad\xbbg\x09\xb5\x0f\xb4\x87\x13\x18" +
	"\x99?\xa1\xa2{U\x8ed9\xa5\xc4\xff\xa8\x82\xa8\x89" +
	"\xea\x9c|\x9a\x13\xb8\x01o\xcc/\xe4Sa\xd6\x877" +
	"\xa7\x88\xb4\xd7\x16\x91\x19\x7f\x0ft\xd6\x16\x11c\xa6\x88" +
	"\xec%r\xb7\x08\xb8;\xf9^\xa7\xd1L\x06\x9a\x09q" +
	"/\x95\xcfD\x0f*\x9d)\x8e\x16\xb2AHV\xd6\xf7" +
	"*\xd2y\x9d\xbe#\x95+A\x97\xb4\x03\xc2lV\x8a" +
	"\xcd\x91\x9f\x14\xcb\x88\x86W\x09\x81\xe1>a\xa0\x057" +
	"\x956I>\xa4A\x0f\x83\xf5\x0c\x8c\x1bJ\x9b%\xd7" +
	"j\xf0 \x83M\x0c\xc4\x07\xca\x81 \x92\x1b4\xe8c" +
	"\xb0\x85\x81\xf9\xber\xb8\x87\xca\x01\x0d\xd63\x18d\x10" +
	"\xfb\xb7r\x10#\x92[E;\xd1\xf0&\x06#\x0c\xea" +
	"\xdeS\x0e\xea\x88\xa4+:\x89\x86\xb70\xd8\xc9\xc0\xfa" +
	"\x97r\xb8\xc9\xca\xed\x1a\x0c2\xd8\xc5\xa0\xfe]\xe5\xa0" +
	"\x9e'3\x0dF\x18\xeca\xd0p]9h\xe0AM" +
	"o\xbe\x93A\x9aA\xe3\xb4r\xd0H$S\"A4" +
	"\xbc\x8b\xc18\x83\xa6k\xcaA\x13wo\x0d\xf60\xc8" +
	"1h\xfe\xa7r\xd0L$\xb3\x1a\xa4\x19\x04\x0cZ\xde" +
	"Q\x0eZx\xea\xd1`\x9cA\xc8`\xc1\x94r\xb0\x80" +
	"\xa7\x1c\xbdy\x8e\xc1\x01\x06\xf1\xab\xcaA\x9cH\x96\xb4" +
	"\xb9\x01\x83\xc7\x19\xb4\xfeC9h\xe51M\x83G\x19" +
	"|\x9f\x81}E9\xb0\x89\xe4\x93\x1a|\x8b\xc1O\x18" +
	"$.+\x07\x09\"yB\x83\xa7\x19<\xc7@\xfe]" +
	"9\x90D\xf2Y\x0d~\xc9\xe0U\x06\xce\xdb\xca\x81C" +
	"$\xcfk\xab\xce1\xb8\xca`\xe1[\xca\xc1B\x1e\xa0" +
	"D7\xd1\xf0%\x06\xa6i\xa0\xe5\x8e7\x95\x83;\x88" +
	"$L\x06\x1f0\xb8\x93A\xdb%\xe5\x80'\x9d\x85\x1a" +
	"\xb4\x9a\x02\xc3\x1fgp\xe7\x1b\xca\xc1\x9dD\xf2>\x93" +
	"7_\xce\xa0\x8f\xc1\xa2\xd7\x95\x83E\x9cW&\xc7\xbc" +
	"\x87\xc1\x08\x83\xf6\x8b\xcaA;\xc7\\\x83-\x0c\xc6\x19" +
	",\xfe\x9br\xb0\x98\xe3\xa1\xc1\x1e\x06\x8f0X\xf2W" +
	"\xe5`\x09\x91\x9c\xd0{\x84\x0c\xbe\xc6\xe0\xae\xd7\x94\x83" +
	"\xbb\x88\xe4Qm\xd5W\x19\xfc\xd0\xe4\x0a\xb6z\x15\x9a" +
	"\xc8@\x13\xc1\x1aKv\xa3\x91\x0c4\x12\xac\xec\xeaU" +
	"\x88\x91\x81\x18\xffNv\xc3$\x03&\xff\xeeZ\x1d5" +
	"l\x91\xed\x81A\x06\x0cB\xbc\xc4\xeb\x1b\xc8@\x83~" +
	"Hv\xa3\x9e\x0c\xd4\xeb\x87\xae\xd5\xb0\xc8\x80E\xb0J" +
	"\xd9\x9e\xa8\xa9c/@\x06@@\x18]N\xa4\xd1B" +
	"\x06Z\x08\x08\x90 C\xd7\xd2\xd1T\x80\x84)\x08\xfc" +
	"\x14\xcf\xb1\xc1\x0b\x08\x83\x02\xda\xee\x05Z\x96\xec\x8ed" +
	"\x8d\x91,[]\x17\xab\xc8\xaa\xeb\xcc\x8a\xacku$" +
	"\x13e\x99\x95\xcb\xf6D\"\xa3,\xea\xc8\x95j\xf45" +
	"T\x85U\x85\xf5UaU\xa3\x15\xedR\xaa\xaa\xac+" +
	"\xcbDno$A$\x09#Is$IG\x92\x96" +
	"H\x13\xbbcFV\xf6\x8a\xde4He\x0b\x91\xb8\xb5" +
	"\xa6\xebh|[3\x8b\x9e@\xe2\xfc\xec\xb6\xea\x1aX" +
	".\xbf).\xbf\xbb\x04\xdc\xf1\xa8\x02r\xfd\xcd\xb0t" +
	"\x8f\x80\x9b\x8b\xca\x9f \xb2\xb3\xdc\x15\xd2\x02n\x10\xd5" +
	">\x93\xc8\xce\xf3\xdaq\x0174\x10\xf7|/Cu" +
	"z\xc2\xa1:\x9eq\xa8NO9T7\x7f\xbb\xa85" +
	"R\x1c\x08\xf5\xa4P\xfd<Dg\x9cG\xad\xda\x16\xd2" +
	"]m!0P\xf3\x0dc\x0f\x0c\x91\xa1\xbbJ\x0c\xb0" +
	"\x1f`\xa3V\x0a\xb8\x0fVF\xa2\xa8A\x14g\xb6$" +
	"d\xe2\xe1D\x90A\xbc\xba#\x01\xf1[w\xb6\xeaH" +
	"\xb2\xa6<\x93\x0d\x02\x83\"\xe6\xd6\xcf\x1eo\xaa\xfd\xb8" +
	"\x0f\x1fj\xd1\xdc\xb5\xdb\xf8\x98(\x87\x185\x1fK3" +
	"\x93\xd1\xed\xf6m\xfd\x89\x81\xe2\x7f\x02\x00\x00\xff\xff*" +
	"\xd2\x0c3"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_99f1c9a775a88ac9,
		Nodes: []uint64{
			0x8417f479600047f0,
			0x966d054acf5f578d,
			0x9771e5b5c6a27b68,
			0x97e6feac0322118d,
			0x9b38b2f4ce5b565d,
			0x9d8aa1cf1e49deb1,
			0x9eebc43e17b5974f,
			0xa18bd34aee32cc89,
			0xa869f50b8c586ed9,
			0xb2afd1cb599c48d5,
			0xb9d4864725174733,
			0xc83045ccbb0b6ac5,
			0xd010f77f1bdf0522,
			0xd4cb7ecbfe03dad3,
			0xe17592335373b246,
			0xe8cbf552b1c262cc,
			0xed6c098b67cad454,
			0xee543d7c305d56f6,
			0xfd058bbd1f9508cd,
		},
		Compressed: true,
	})
}
