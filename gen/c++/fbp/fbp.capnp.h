// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: fbp.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1002000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"
#include "persistence.capnp.h"
#include "service.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(af0a1dc4709a5ccf);
CAPNP_DECLARE_SCHEMA(9e9e5391e0c499e6);
CAPNP_DECLARE_SCHEMA(f684cae29bdc484e);
enum class Type_f684cae29bdc484e: uint16_t {
  STANDARD,
  OPEN_BRACKET,
  CLOSE_BRACKET,
};
CAPNP_DECLARE_ENUM(Type, f684cae29bdc484e);
CAPNP_DECLARE_SCHEMA(f3705fb36d44a21f);
CAPNP_DECLARE_SCHEMA(9c62c32b2ff2b1e8);
CAPNP_DECLARE_SCHEMA(a8d787cae7e0b243);
enum class CloseSemantics_a8d787cae7e0b243: uint16_t {
  FBP,
  NO,
};
CAPNP_DECLARE_ENUM(CloseSemantics, a8d787cae7e0b243);
CAPNP_DECLARE_SCHEMA(d5b512f4bcd0aa2e);
CAPNP_DECLARE_SCHEMA(e3d7a3237f175028);
CAPNP_DECLARE_SCHEMA(8bc69192f3bc97cc);
CAPNP_DECLARE_SCHEMA(c0335d99db8b2ba5);
CAPNP_DECLARE_SCHEMA(9428ea64f18c41c8);
CAPNP_DECLARE_SCHEMA(b3fe08a1bf53821a);
CAPNP_DECLARE_SCHEMA(89e521a99fcc4044);
CAPNP_DECLARE_SCHEMA(f7fec613b4a8c79f);
CAPNP_DECLARE_SCHEMA(ce9f24b8ec149524);
CAPNP_DECLARE_SCHEMA(badc988dda3d1e50);
CAPNP_DECLARE_SCHEMA(cb02dc91e18e58c9);
CAPNP_DECLARE_SCHEMA(c61c438f89d10281);
CAPNP_DECLARE_SCHEMA(92101e3b7a761333);
CAPNP_DECLARE_SCHEMA(fe6a08d5e0712c23);
CAPNP_DECLARE_SCHEMA(e607c9dd64da04c4);
CAPNP_DECLARE_SCHEMA(b135ffc9ccc9eca6);
CAPNP_DECLARE_SCHEMA(be611d34e368e109);
CAPNP_DECLARE_SCHEMA(b47b53679e985c7e);
CAPNP_DECLARE_SCHEMA(d23f817e914373d8);
CAPNP_DECLARE_SCHEMA(f37401d21f8d97bb);
CAPNP_DECLARE_SCHEMA(b49836b545583add);
CAPNP_DECLARE_SCHEMA(c0fc6e5a3fcb3206);
CAPNP_DECLARE_SCHEMA(95d8ad01c1113d9c);
CAPNP_DECLARE_SCHEMA(cc079ad60f1363b7);
CAPNP_DECLARE_SCHEMA(d0cd6d829b810229);
CAPNP_DECLARE_SCHEMA(9576b9a98d58fba2);
CAPNP_DECLARE_SCHEMA(de5975c83de2b10c);
CAPNP_DECLARE_SCHEMA(ece0efa9a922d4a8);
CAPNP_DECLARE_SCHEMA(8a4d34c4b5eb1545);
CAPNP_DECLARE_SCHEMA(d717ff7d6815a6b0);
CAPNP_DECLARE_SCHEMA(c6976ac75246b450);
enum class ComponentType_c6976ac75246b450: uint16_t {
  STANDARD,
  IIP,
  SUBFLOW,
  VIEW,
  PROCESS,
};
CAPNP_DECLARE_ENUM(ComponentType, c6976ac75246b450);
CAPNP_DECLARE_SCHEMA(c28d2829add1cd72);
CAPNP_DECLARE_SCHEMA(f58d7a7318a06224);
enum class PortType_f58d7a7318a06224: uint16_t {
  STANDARD,
};
CAPNP_DECLARE_ENUM(PortType, f58d7a7318a06224);
CAPNP_DECLARE_SCHEMA(f30610cf0ed94a2f);
enum class ContentType_f30610cf0ed94a2f: uint16_t {
  STRUCTURED_TEXT,
};
CAPNP_DECLARE_ENUM(ContentType, f30610cf0ed94a2f);
CAPNP_DECLARE_SCHEMA(e1a4104633d629d4);
CAPNP_DECLARE_SCHEMA(bde616d300754ff0);
CAPNP_DECLARE_SCHEMA(f5694db406aa9975);
CAPNP_DECLARE_SCHEMA(ef35cb55860e1c65);
CAPNP_DECLARE_SCHEMA(8e483f7d2668e153);
CAPNP_DECLARE_SCHEMA(9e5b8ec57b93780c);
CAPNP_DECLARE_SCHEMA(f34a8f368330a36d);
CAPNP_DECLARE_SCHEMA(a593e62c492f42f1);
CAPNP_DECLARE_SCHEMA(dfe8d20013a383bf);
CAPNP_DECLARE_SCHEMA(bbad56943a039783);
CAPNP_DECLARE_SCHEMA(b01652ab8f1ac0d3);
CAPNP_DECLARE_SCHEMA(d97b10297d574590);
CAPNP_DECLARE_SCHEMA(8c00219c9e2715f2);
CAPNP_DECLARE_SCHEMA(a8d0bdfb4ddda7b3);
CAPNP_DECLARE_SCHEMA(e67044233be769a5);
enum class State_e67044233be769a5: uint16_t {
  STARTED,
  STOPPED,
  CANCELED,
};
CAPNP_DECLARE_ENUM(State, e67044233be769a5);
CAPNP_DECLARE_SCHEMA(9c8fa975665cfafa);
CAPNP_DECLARE_SCHEMA(f6196a1a97213420);
CAPNP_DECLARE_SCHEMA(f0d589af3c8253af);
CAPNP_DECLARE_SCHEMA(f7ecea5ecff7797e);
CAPNP_DECLARE_SCHEMA(cd9154730a050d21);
CAPNP_DECLARE_SCHEMA(dc3bf3d87cee74a3);
CAPNP_DECLARE_SCHEMA(9f2e15f17d6894cd);
CAPNP_DECLARE_SCHEMA(c87493b1428b0a52);
CAPNP_DECLARE_SCHEMA(a394c49bfa79bd73);
CAPNP_DECLARE_SCHEMA(e0c0057317bd32c6);
CAPNP_DECLARE_SCHEMA(b364ef5d2a7d582d);
CAPNP_DECLARE_SCHEMA(91d109cdc059cd88);
CAPNP_DECLARE_SCHEMA(e6f5ed0f7285c794);
CAPNP_DECLARE_SCHEMA(d1de57bb71794fec);
CAPNP_DECLARE_SCHEMA(f563b2171ed5b332);
CAPNP_DECLARE_SCHEMA(d35bbb909ba0c554);
CAPNP_DECLARE_SCHEMA(ee5188311583039d);
CAPNP_DECLARE_SCHEMA(c8608732b07a57dd);
CAPNP_DECLARE_SCHEMA(b6f9c7723a43c20a);
CAPNP_DECLARE_SCHEMA(d83c7bb8305387ce);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace fbp {

struct IP {
  IP() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct KV;
  typedef ::capnp::schemas::Type_f684cae29bdc484e Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(af0a1dc4709a5ccf, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IP::KV {
  KV() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e9e5391e0c499e6, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IIP {
  IIP() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f3705fb36d44a21f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename V = ::capnp::AnyPointer>
struct Channel {
  Channel() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  typedef ::capnp::schemas::CloseSemantics_a8d787cae7e0b243 CloseSemantics;

  struct Msg;
  struct StartupInfo;
  struct ChanReader;
  struct ChanWriter;
  struct SetBufferSizeParams;
  struct SetBufferSizeResults;
  struct ReaderParams;
  struct ReaderResults;
  struct WriterParams;
  struct WriterResults;
  struct EndpointsParams;
  struct EndpointsResults;
  struct SetAutoCloseSemanticsParams;
  struct SetAutoCloseSemanticsResults;
  struct CloseParams;
  struct CloseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9c62c32b2ff2b1e8)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
struct Channel<V>::Msg {
  Msg() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    VALUE,
    DONE,
    NO_MSG,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d5b512f4bcd0aa2e, 1, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::StartupInfo {
  StartupInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3d7a3237f175028, 2, 6)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader {
  ChanReader() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ReadParams;
  struct CloseParams;
  struct CloseResults;
  struct ReadIfMsgParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(8bc69192f3bc97cc)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
struct Channel<V>::ChanReader::ReadParams {
  ReadParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0335d99db8b2ba5, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader::CloseParams {
  CloseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9428ea64f18c41c8, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader::CloseResults {
  CloseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3fe08a1bf53821a, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader::ReadIfMsgParams {
  ReadIfMsgParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(89e521a99fcc4044, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter {
  ChanWriter() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct WriteResults;
  struct CloseParams;
  struct CloseResults;
  struct WriteIfSpaceResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f7fec613b4a8c79f)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
struct Channel<V>::ChanWriter::WriteResults {
  WriteResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce9f24b8ec149524, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter::CloseParams {
  CloseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(badc988dda3d1e50, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter::CloseResults {
  CloseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb02dc91e18e58c9, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter::WriteIfSpaceResults {
  WriteIfSpaceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c61c438f89d10281, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetBufferSizeParams {
  SetBufferSizeParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(92101e3b7a761333, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetBufferSizeResults {
  SetBufferSizeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe6a08d5e0712c23, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ReaderParams {
  ReaderParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e607c9dd64da04c4, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ReaderResults {
  ReaderResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b135ffc9ccc9eca6, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::WriterParams {
  WriterParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(be611d34e368e109, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::WriterResults {
  WriterResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b47b53679e985c7e, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::EndpointsParams {
  EndpointsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d23f817e914373d8, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::EndpointsResults {
  EndpointsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f37401d21f8d97bb, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetAutoCloseSemanticsParams {
  SetAutoCloseSemanticsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b49836b545583add, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetAutoCloseSemanticsResults {
  SetAutoCloseSemanticsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0fc6e5a3fcb3206, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::CloseParams {
  CloseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(95d8ad01c1113d9c, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::CloseResults {
  CloseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cc079ad60f1363b7, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct StartChannelsService {
  StartChannelsService() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Params;
  struct StartResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(d0cd6d829b810229)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct StartChannelsService::Params {
  Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9576b9a98d58fba2, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct StartChannelsService::StartResults {
  StartResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(de5975c83de2b10c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PortInfos {
  PortInfos() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct NameAndSR;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ece0efa9a922d4a8, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PortInfos::NameAndSR {
  NameAndSR() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SR,
    SRS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8a4d34c4b5eb1545, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Component {
  Component() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::ComponentType_c6976ac75246b450 ComponentType;

  struct Port;
  struct Factory;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d717ff7d6815a6b0, 1, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Component::Port {
  Port() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::PortType_f58d7a7318a06224 PortType;

  typedef ::capnp::schemas::ContentType_f30610cf0ed94a2f ContentType;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c28d2829add1cd72, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Component::Factory {
  Factory() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    RUNNABLE,
    PROCESS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e1a4104633d629d4, 1, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Runnable {
  Runnable() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Factory;
  struct StartParams;
  struct StartResults;
  struct StopParams;
  struct StopResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(bde616d300754ff0)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Runnable::Factory {
  Factory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CreateParams;
  struct CreateResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f5694db406aa9975)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Runnable::Factory::CreateParams {
  CreateParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef35cb55860e1c65, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Runnable::Factory::CreateResults {
  CreateResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e483f7d2668e153, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Runnable::StartParams {
  StartParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e5b8ec57b93780c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Runnable::StartResults {
  StartResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f34a8f368330a36d, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Runnable::StopParams {
  StopParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a593e62c492f42f1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Runnable::StopResults {
  StopResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dfe8d20013a383bf, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process {
  Process() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Factory;
  struct ConfigEntry;
  typedef ::capnp::schemas::State_e67044233be769a5 State;

  struct StateTransition;
  struct InPortsParams;
  struct InPortsResults;
  struct ConnectInPortParams;
  struct ConnectInPortResults;
  struct OutPortsParams;
  struct OutPortsResults;
  struct ConnectOutPortParams;
  struct ConnectOutPortResults;
  struct ConfigEntriesParams;
  struct ConfigEntriesResults;
  struct StartParams;
  struct StartResults;
  struct StopParams;
  struct StopResults;
  struct SetConfigEntryResults;
  struct StateParams;
  struct StateResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(bbad56943a039783)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Process::Factory {
  Factory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CreateParams;
  struct CreateResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(b01652ab8f1ac0d3)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Process::Factory::CreateParams {
  CreateParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d97b10297d574590, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::Factory::CreateResults {
  CreateResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8c00219c9e2715f2, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::ConfigEntry {
  ConfigEntry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a8d0bdfb4ddda7b3, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::StateTransition {
  StateTransition() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct StateChangedParams;
  struct StateChangedResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9c8fa975665cfafa)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Process::StateTransition::StateChangedParams {
  StateChangedParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f6196a1a97213420, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::StateTransition::StateChangedResults {
  StateChangedResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f0d589af3c8253af, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::InPortsParams {
  InPortsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f7ecea5ecff7797e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::InPortsResults {
  InPortsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cd9154730a050d21, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::ConnectInPortParams {
  ConnectInPortParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc3bf3d87cee74a3, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::ConnectInPortResults {
  ConnectInPortResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9f2e15f17d6894cd, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::OutPortsParams {
  OutPortsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c87493b1428b0a52, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::OutPortsResults {
  OutPortsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a394c49bfa79bd73, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::ConnectOutPortParams {
  ConnectOutPortParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0c0057317bd32c6, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::ConnectOutPortResults {
  ConnectOutPortResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b364ef5d2a7d582d, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::ConfigEntriesParams {
  ConfigEntriesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(91d109cdc059cd88, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::ConfigEntriesResults {
  ConfigEntriesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6f5ed0f7285c794, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::StartParams {
  StartParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d1de57bb71794fec, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::StartResults {
  StartResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f563b2171ed5b332, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::StopParams {
  StopParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d35bbb909ba0c554, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::StopResults {
  StopResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee5188311583039d, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::SetConfigEntryResults {
  SetConfigEntryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c8608732b07a57dd, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::StateParams {
  StateParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b6f9c7723a43c20a, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Process::StateResults {
  StateResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d83c7bb8305387ce, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class IP::Reader {
public:
  typedef IP Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAttributes() const;
  inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Reader getAttributes() const;

  inline bool hasContent() const;
  inline ::capnp::AnyPointer::Reader getContent() const;

  inline  ::mas::schema::fbp::IP::Type getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IP::Builder {
public:
  typedef IP Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAttributes();
  inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Builder getAttributes();
  inline void setAttributes( ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Builder initAttributes(unsigned int size);
  inline void adoptAttributes(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>> disownAttributes();

  inline bool hasContent();
  inline ::capnp::AnyPointer::Builder getContent();
  inline ::capnp::AnyPointer::Builder initContent();

  inline  ::mas::schema::fbp::IP::Type getType();
  inline void setType( ::mas::schema::fbp::IP::Type value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IP::Pipeline {
public:
  typedef IP Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IP::KV::Reader {
public:
  typedef KV Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline bool hasDesc() const;
  inline  ::capnp::Text::Reader getDesc() const;

  inline bool hasValue() const;
  inline ::capnp::AnyPointer::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IP::KV::Builder {
public:
  typedef KV Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline bool hasDesc();
  inline  ::capnp::Text::Builder getDesc();
  inline void setDesc( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDesc(unsigned int size);
  inline void adoptDesc(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDesc();

  inline bool hasValue();
  inline ::capnp::AnyPointer::Builder getValue();
  inline ::capnp::AnyPointer::Builder initValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IP::KV::Pipeline {
public:
  typedef KV Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IIP::Reader {
public:
  typedef IIP Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContent() const;
  inline ::capnp::AnyPointer::Reader getContent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IIP::Builder {
public:
  typedef IIP Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContent();
  inline ::capnp::AnyPointer::Builder getContent();
  inline ::capnp::AnyPointer::Builder initContent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IIP::Pipeline {
public:
  typedef IIP Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class Channel<V>::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Channel Calls;
  typedef Channel Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::Client asGeneric() {
    return castAs<Channel<V2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults>) setBufferSizeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ReaderParams, typename  ::mas::schema::fbp::Channel<V>::ReaderResults>) readerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::WriterParams, typename  ::mas::schema::fbp::Channel<V>::WriterResults>) writerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::EndpointsParams, typename  ::mas::schema::fbp::Channel<V>::EndpointsResults>) endpointsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults>) setAutoCloseSemanticsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::CloseParams, typename  ::mas::schema::fbp::Channel<V>::CloseResults>) closeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class Channel<V>::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Channel Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams SetBufferSizeParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults SetBufferSizeResults;
  typedef ::capnp::CallContext<SetBufferSizeParams, SetBufferSizeResults> SetBufferSizeContext;
  virtual ::kj::Promise<void> setBufferSize(SetBufferSizeContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ReaderParams ReaderParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::ReaderResults ReaderResults;
  typedef ::capnp::CallContext<ReaderParams, ReaderResults> ReaderContext;
  virtual ::kj::Promise<void> reader(ReaderContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::WriterParams WriterParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::WriterResults WriterResults;
  typedef ::capnp::CallContext<WriterParams, WriterResults> WriterContext;
  virtual ::kj::Promise<void> writer(WriterContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::EndpointsParams EndpointsParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::EndpointsResults EndpointsResults;
  typedef ::capnp::CallContext<EndpointsParams, EndpointsResults> EndpointsContext;
  virtual ::kj::Promise<void> endpoints(EndpointsContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams SetAutoCloseSemanticsParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults SetAutoCloseSemanticsResults;
  typedef ::capnp::CallContext<SetAutoCloseSemanticsParams, SetAutoCloseSemanticsResults> SetAutoCloseSemanticsContext;
  virtual ::kj::Promise<void> setAutoCloseSemantics(SetAutoCloseSemanticsContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::CloseParams CloseParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::CloseResults CloseResults;
  typedef ::capnp::CallContext<CloseParams, CloseResults> CloseContext;
  virtual ::kj::Promise<void> close(CloseContext context);

  inline typename  ::mas::schema::fbp::Channel<V>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::Channel<V>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::Msg::Reader {
public:
  typedef Msg Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::Msg::Reader asChannelGeneric() const {
    return typename Channel<V2>::Msg::Reader(_reader);
  }

  inline Which which() const;
  inline bool isValue() const;
  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<V> getValue() const;

  inline bool isDone() const;
  inline  ::capnp::Void getDone() const;

  inline bool isNoMsg() const;
  inline  ::capnp::Void getNoMsg() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::Msg::Builder {
public:
  typedef Msg Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::Msg::Builder asChannelGeneric() {
    return typename Channel<V2>::Msg::Builder(_builder);
  }

  inline Which which();
  inline bool isValue();
  inline bool hasValue();
  inline  ::capnp::BuilderFor<V> getValue();
  inline void setValue( ::capnp::ReaderFor<V> value);
  inline  ::capnp::BuilderFor<V> initValue();
  inline  ::capnp::BuilderFor<V> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<V>&& value);
  inline ::capnp::Orphan<V> disownValue();

  inline bool isDone();
  inline  ::capnp::Void getDone();
  inline void setDone( ::capnp::Void value = ::capnp::VOID);

  inline bool isNoMsg();
  inline  ::capnp::Void getNoMsg();
  inline void setNoMsg( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::Msg::Pipeline {
public:
  typedef Msg Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::StartupInfo::Reader {
public:
  typedef StartupInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::StartupInfo::Reader asChannelGeneric() const {
    return typename Channel<V2>::StartupInfo::Reader(_reader);
  }

  inline  ::uint64_t getBufferSize() const;

  inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics getCloseSemantics() const;

  inline bool hasChannelSR() const;
  inline  ::mas::schema::persistence::SturdyRef::Reader getChannelSR() const;

  inline bool hasReaderSRs() const;
  inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader getReaderSRs() const;

  inline bool hasWriterSRs() const;
  inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader getWriterSRs() const;

  inline bool hasChannel() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::Client getChannel() const;
#endif  // !CAPNP_LITE

  inline bool hasReaders() const;
#if !CAPNP_LITE
  inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>::Reader getReaders() const;
#endif  // !CAPNP_LITE

  inline bool hasWriters() const;
#if !CAPNP_LITE
  inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>::Reader getWriters() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::StartupInfo::Builder {
public:
  typedef StartupInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::StartupInfo::Builder asChannelGeneric() {
    return typename Channel<V2>::StartupInfo::Builder(_builder);
  }

  inline  ::uint64_t getBufferSize();
  inline void setBufferSize( ::uint64_t value);

  inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics getCloseSemantics();
  inline void setCloseSemantics(typename  ::mas::schema::fbp::Channel<V>::CloseSemantics value);

  inline bool hasChannelSR();
  inline  ::mas::schema::persistence::SturdyRef::Builder getChannelSR();
  inline void setChannelSR( ::mas::schema::persistence::SturdyRef::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Builder initChannelSR();
  inline void adoptChannelSR(::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> disownChannelSR();

  inline bool hasReaderSRs();
  inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder getReaderSRs();
  inline void setReaderSRs( ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder initReaderSRs(unsigned int size);
  inline void adoptReaderSRs(::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>> disownReaderSRs();

  inline bool hasWriterSRs();
  inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder getWriterSRs();
  inline void setWriterSRs( ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder initWriterSRs(unsigned int size);
  inline void adoptWriterSRs(::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>> disownWriterSRs();

  inline bool hasChannel();
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::Client getChannel();
  inline void setChannel(typename  ::mas::schema::fbp::Channel<V>::Client&& value);
  inline void setChannel(typename  ::mas::schema::fbp::Channel<V>::Client& value);
  inline void adoptChannel(::capnp::Orphan< ::mas::schema::fbp::Channel<V>>&& value);
  inline ::capnp::Orphan< ::mas::schema::fbp::Channel<V>> disownChannel();
#endif  // !CAPNP_LITE

  inline bool hasReaders();
#if !CAPNP_LITE
  inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>::Builder getReaders();
  inline void setReaders(typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>::Reader value);
  inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>::Builder initReaders(unsigned int size);
  inline void adoptReaders(::capnp::Orphan< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>> disownReaders();
#endif  // !CAPNP_LITE

  inline bool hasWriters();
#if !CAPNP_LITE
  inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>::Builder getWriters();
  inline void setWriters(typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>::Reader value);
  inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>::Builder initWriters(unsigned int size);
  inline void adoptWriters(::capnp::Orphan< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>> disownWriters();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::StartupInfo::Pipeline {
public:
  typedef StartupInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::SturdyRef::Pipeline getChannelSR();
  inline typename  ::mas::schema::fbp::Channel<V>::Client getChannel();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef ChanReader Calls;
  typedef ChanReader Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Client asChannelGeneric() {
    return castAs<typename Channel<V2>::ChanReader>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg>) readRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults>) closeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg>) readIfMsgRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class Channel<V>::ChanReader::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef ChanReader Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams ReadParams;
  typedef ::capnp::CallContext<ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg> ReadContext;
  virtual ::kj::Promise<void> read(ReadContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams CloseParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults CloseResults;
  typedef ::capnp::CallContext<CloseParams, CloseResults> CloseContext;
  virtual ::kj::Promise<void> close(CloseContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams ReadIfMsgParams;
  typedef ::capnp::CallContext<ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg> ReadIfMsgContext;
  virtual ::kj::Promise<void> readIfMsg(ReadIfMsgContext context);

  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::mas::schema::fbp::Channel<V>::ChanReader>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::ReadParams::Reader {
public:
  typedef ReadParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() const {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::ReadParams::Builder {
public:
  typedef ReadParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::ReadParams::Pipeline {
public:
  typedef ReadParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::CloseParams::Reader {
public:
  typedef CloseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() const {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::CloseParams::Builder {
public:
  typedef CloseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::CloseParams::Pipeline {
public:
  typedef CloseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::CloseResults::Reader {
public:
  typedef CloseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() const {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::CloseResults::Builder {
public:
  typedef CloseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::CloseResults::Pipeline {
public:
  typedef CloseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::ReadIfMsgParams::Reader {
public:
  typedef ReadIfMsgParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() const {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::ReadIfMsgParams::Builder {
public:
  typedef ReadIfMsgParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::ReadIfMsgParams::Pipeline {
public:
  typedef ReadIfMsgParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef ChanWriter Calls;
  typedef ChanWriter Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Client asChannelGeneric() {
    return castAs<typename Channel<V2>::ChanWriter>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults>) writeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults>) closeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults>) writeIfSpaceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class Channel<V>::ChanWriter::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef ChanWriter Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults WriteResults;
  typedef ::capnp::CallContext<typename  ::mas::schema::fbp::Channel<V>::Msg, WriteResults> WriteContext;
  virtual ::kj::Promise<void> write(WriteContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams CloseParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults CloseResults;
  typedef ::capnp::CallContext<CloseParams, CloseResults> CloseContext;
  virtual ::kj::Promise<void> close(CloseContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults WriteIfSpaceResults;
  typedef ::capnp::CallContext<typename  ::mas::schema::fbp::Channel<V>::Msg, WriteIfSpaceResults> WriteIfSpaceContext;
  virtual ::kj::Promise<void> writeIfSpace(WriteIfSpaceContext context);

  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::WriteResults::Reader {
public:
  typedef WriteResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() const {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::WriteResults::Builder {
public:
  typedef WriteResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::WriteResults::Pipeline {
public:
  typedef WriteResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::CloseParams::Reader {
public:
  typedef CloseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() const {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::CloseParams::Builder {
public:
  typedef CloseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::CloseParams::Pipeline {
public:
  typedef CloseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::CloseResults::Reader {
public:
  typedef CloseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() const {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::CloseResults::Builder {
public:
  typedef CloseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::CloseResults::Pipeline {
public:
  typedef CloseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::WriteIfSpaceResults::Reader {
public:
  typedef WriteIfSpaceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() const {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::WriteIfSpaceResults::Builder {
public:
  typedef WriteIfSpaceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::WriteIfSpaceResults::Pipeline {
public:
  typedef WriteIfSpaceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetBufferSizeParams::Reader {
public:
  typedef SetBufferSizeParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeParams::Reader asChannelGeneric() const {
    return typename Channel<V2>::SetBufferSizeParams::Reader(_reader);
  }

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetBufferSizeParams::Builder {
public:
  typedef SetBufferSizeParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeParams::Builder asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeParams::Builder(_builder);
  }

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetBufferSizeParams::Pipeline {
public:
  typedef SetBufferSizeParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetBufferSizeResults::Reader {
public:
  typedef SetBufferSizeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeResults::Reader asChannelGeneric() const {
    return typename Channel<V2>::SetBufferSizeResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetBufferSizeResults::Builder {
public:
  typedef SetBufferSizeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeResults::Builder asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetBufferSizeResults::Pipeline {
public:
  typedef SetBufferSizeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ReaderParams::Reader {
public:
  typedef ReaderParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderParams::Reader asChannelGeneric() const {
    return typename Channel<V2>::ReaderParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ReaderParams::Builder {
public:
  typedef ReaderParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderParams::Builder asChannelGeneric() {
    return typename Channel<V2>::ReaderParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ReaderParams::Pipeline {
public:
  typedef ReaderParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ReaderResults::Reader {
public:
  typedef ReaderResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderResults::Reader asChannelGeneric() const {
    return typename Channel<V2>::ReaderResults::Reader(_reader);
  }

  inline bool hasR() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ReaderResults::Builder {
public:
  typedef ReaderResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderResults::Builder asChannelGeneric() {
    return typename Channel<V2>::ReaderResults::Builder(_builder);
  }

  inline bool hasR();
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR();
  inline void setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client&& value);
  inline void setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& value);
  inline void adoptR(::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader> disownR();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ReaderResults::Pipeline {
public:
  typedef ReaderResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::WriterParams::Reader {
public:
  typedef WriterParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterParams::Reader asChannelGeneric() const {
    return typename Channel<V2>::WriterParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::WriterParams::Builder {
public:
  typedef WriterParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterParams::Builder asChannelGeneric() {
    return typename Channel<V2>::WriterParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::WriterParams::Pipeline {
public:
  typedef WriterParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::WriterResults::Reader {
public:
  typedef WriterResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterResults::Reader asChannelGeneric() const {
    return typename Channel<V2>::WriterResults::Reader(_reader);
  }

  inline bool hasW() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::WriterResults::Builder {
public:
  typedef WriterResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterResults::Builder asChannelGeneric() {
    return typename Channel<V2>::WriterResults::Builder(_builder);
  }

  inline bool hasW();
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW();
  inline void setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client&& value);
  inline void setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& value);
  inline void adoptW(::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter> disownW();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::WriterResults::Pipeline {
public:
  typedef WriterResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::EndpointsParams::Reader {
public:
  typedef EndpointsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsParams::Reader asChannelGeneric() const {
    return typename Channel<V2>::EndpointsParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::EndpointsParams::Builder {
public:
  typedef EndpointsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsParams::Builder asChannelGeneric() {
    return typename Channel<V2>::EndpointsParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::EndpointsParams::Pipeline {
public:
  typedef EndpointsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::EndpointsResults::Reader {
public:
  typedef EndpointsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsResults::Reader asChannelGeneric() const {
    return typename Channel<V2>::EndpointsResults::Reader(_reader);
  }

  inline bool hasR() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR() const;
#endif  // !CAPNP_LITE

  inline bool hasW() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::EndpointsResults::Builder {
public:
  typedef EndpointsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsResults::Builder asChannelGeneric() {
    return typename Channel<V2>::EndpointsResults::Builder(_builder);
  }

  inline bool hasR();
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR();
  inline void setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client&& value);
  inline void setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& value);
  inline void adoptR(::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader> disownR();
#endif  // !CAPNP_LITE

  inline bool hasW();
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW();
  inline void setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client&& value);
  inline void setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& value);
  inline void adoptW(::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter> disownW();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::EndpointsResults::Pipeline {
public:
  typedef EndpointsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR();
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetAutoCloseSemanticsParams::Reader {
public:
  typedef SetAutoCloseSemanticsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsParams::Reader asChannelGeneric() const {
    return typename Channel<V2>::SetAutoCloseSemanticsParams::Reader(_reader);
  }

  inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics getCs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetAutoCloseSemanticsParams::Builder {
public:
  typedef SetAutoCloseSemanticsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsParams::Builder asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsParams::Builder(_builder);
  }

  inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics getCs();
  inline void setCs(typename  ::mas::schema::fbp::Channel<V>::CloseSemantics value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetAutoCloseSemanticsParams::Pipeline {
public:
  typedef SetAutoCloseSemanticsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetAutoCloseSemanticsResults::Reader {
public:
  typedef SetAutoCloseSemanticsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsResults::Reader asChannelGeneric() const {
    return typename Channel<V2>::SetAutoCloseSemanticsResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetAutoCloseSemanticsResults::Builder {
public:
  typedef SetAutoCloseSemanticsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsResults::Builder asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetAutoCloseSemanticsResults::Pipeline {
public:
  typedef SetAutoCloseSemanticsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::CloseParams::Reader {
public:
  typedef CloseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseParams::Reader asChannelGeneric() const {
    return typename Channel<V2>::CloseParams::Reader(_reader);
  }

  inline bool getWaitForEmptyBuffer() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::CloseParams::Builder {
public:
  typedef CloseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseParams::Builder asChannelGeneric() {
    return typename Channel<V2>::CloseParams::Builder(_builder);
  }

  inline bool getWaitForEmptyBuffer();
  inline void setWaitForEmptyBuffer(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::CloseParams::Pipeline {
public:
  typedef CloseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::CloseResults::Reader {
public:
  typedef CloseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseResults::Reader asChannelGeneric() const {
    return typename Channel<V2>::CloseResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::CloseResults::Builder {
public:
  typedef CloseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseResults::Builder asChannelGeneric() {
    return typename Channel<V2>::CloseResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::CloseResults::Pipeline {
public:
  typedef CloseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class StartChannelsService::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef StartChannelsService Calls;
  typedef StartChannelsService Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::fbp::StartChannelsService::Params,  ::mas::schema::fbp::StartChannelsService::StartResults> startRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class StartChannelsService::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef StartChannelsService Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::fbp::StartChannelsService::StartResults StartResults;
  typedef ::capnp::CallContext< ::mas::schema::fbp::StartChannelsService::Params, StartResults> StartContext;
  virtual ::kj::Promise<void> start(StartContext context);

  inline  ::mas::schema::fbp::StartChannelsService::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::StartChannelsService>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class StartChannelsService::Params::Reader {
public:
  typedef Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint16_t getNoOfChannels() const;

  inline  ::uint16_t getNoOfReaders() const;

  inline  ::uint16_t getNoOfWriters() const;

  inline bool hasReaderSrts() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getReaderSrts() const;

  inline bool hasWriterSrts() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getWriterSrts() const;

  inline  ::uint16_t getBufferSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StartChannelsService::Params::Builder {
public:
  typedef Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint16_t getNoOfChannels();
  inline void setNoOfChannels( ::uint16_t value);

  inline  ::uint16_t getNoOfReaders();
  inline void setNoOfReaders( ::uint16_t value);

  inline  ::uint16_t getNoOfWriters();
  inline void setNoOfWriters( ::uint16_t value);

  inline bool hasReaderSrts();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getReaderSrts();
  inline void setReaderSrts( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setReaderSrts(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initReaderSrts(unsigned int size);
  inline void adoptReaderSrts(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownReaderSrts();

  inline bool hasWriterSrts();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getWriterSrts();
  inline void setWriterSrts( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setWriterSrts(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initWriterSrts(unsigned int size);
  inline void adoptWriterSrts(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownWriterSrts();

  inline  ::uint16_t getBufferSize();
  inline void setBufferSize( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StartChannelsService::Params::Pipeline {
public:
  typedef Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StartChannelsService::StartResults::Reader {
public:
  typedef StartResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStartupInfos() const;
  inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Reader getStartupInfos() const;

  inline bool hasStop() const;
#if !CAPNP_LITE
  inline  ::mas::schema::service::Stoppable::Client getStop() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StartChannelsService::StartResults::Builder {
public:
  typedef StartResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStartupInfos();
  inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Builder getStartupInfos();
  inline void setStartupInfos( ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Builder initStartupInfos(unsigned int size);
  inline void adoptStartupInfos(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>> disownStartupInfos();

  inline bool hasStop();
#if !CAPNP_LITE
  inline  ::mas::schema::service::Stoppable::Client getStop();
  inline void setStop( ::mas::schema::service::Stoppable::Client&& value);
  inline void setStop( ::mas::schema::service::Stoppable::Client& value);
  inline void adoptStop(::capnp::Orphan< ::mas::schema::service::Stoppable>&& value);
  inline ::capnp::Orphan< ::mas::schema::service::Stoppable> disownStop();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StartChannelsService::StartResults::Pipeline {
public:
  typedef StartResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::service::Stoppable::Client getStop();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PortInfos::Reader {
public:
  typedef PortInfos Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader getInPorts() const;

  inline bool hasOutPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader getOutPorts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PortInfos::Builder {
public:
  typedef PortInfos Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInPorts();
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder getInPorts();
  inline void setInPorts( ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder initInPorts(unsigned int size);
  inline void adoptInPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>> disownInPorts();

  inline bool hasOutPorts();
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder getOutPorts();
  inline void setOutPorts( ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder initOutPorts(unsigned int size);
  inline void adoptOutPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>> disownOutPorts();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PortInfos::Pipeline {
public:
  typedef PortInfos Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PortInfos::NameAndSR::Reader {
public:
  typedef NameAndSR Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool isSr() const;
  inline bool hasSr() const;
  inline  ::mas::schema::persistence::SturdyRef::Reader getSr() const;

  inline bool isSrs() const;
  inline bool hasSrs() const;
  inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader getSrs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PortInfos::NameAndSR::Builder {
public:
  typedef NameAndSR Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool isSr();
  inline bool hasSr();
  inline  ::mas::schema::persistence::SturdyRef::Builder getSr();
  inline void setSr( ::mas::schema::persistence::SturdyRef::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Builder initSr();
  inline void adoptSr(::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> disownSr();

  inline bool isSrs();
  inline bool hasSrs();
  inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder getSrs();
  inline void setSrs( ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder initSrs(unsigned int size);
  inline void adoptSrs(::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>> disownSrs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PortInfos::NameAndSR::Pipeline {
public:
  typedef NameAndSR Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Component::Reader {
public:
  typedef Component Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInfo() const;
  inline  ::mas::schema::common::IdInformation::Reader getInfo() const;

  inline  ::mas::schema::fbp::Component::ComponentType getType() const;

  inline bool hasInPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader getInPorts() const;

  inline bool hasOutPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader getOutPorts() const;

  inline bool hasDefaultConfig() const;
  inline  ::capnp::Text::Reader getDefaultConfig() const;

  inline typename Factory::Reader getFactory() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Component::Builder {
public:
  typedef Component Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInfo();
  inline  ::mas::schema::common::IdInformation::Builder getInfo();
  inline void setInfo( ::mas::schema::common::IdInformation::Reader value);
  inline  ::mas::schema::common::IdInformation::Builder initInfo();
  inline void adoptInfo(::capnp::Orphan< ::mas::schema::common::IdInformation>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::IdInformation> disownInfo();

  inline  ::mas::schema::fbp::Component::ComponentType getType();
  inline void setType( ::mas::schema::fbp::Component::ComponentType value);

  inline bool hasInPorts();
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder getInPorts();
  inline void setInPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder initInPorts(unsigned int size);
  inline void adoptInPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> disownInPorts();

  inline bool hasOutPorts();
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder getOutPorts();
  inline void setOutPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder initOutPorts(unsigned int size);
  inline void adoptOutPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> disownOutPorts();

  inline bool hasDefaultConfig();
  inline  ::capnp::Text::Builder getDefaultConfig();
  inline void setDefaultConfig( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDefaultConfig(unsigned int size);
  inline void adoptDefaultConfig(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDefaultConfig();

  inline typename Factory::Builder getFactory();
  inline typename Factory::Builder initFactory();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Component::Pipeline {
public:
  typedef Component Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::IdInformation::Pipeline getInfo();
  inline typename Factory::Pipeline getFactory();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Component::Port::Reader {
public:
  typedef Port Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasContentType() const;
  inline  ::capnp::Text::Reader getContentType() const;

  inline  ::mas::schema::fbp::Component::Port::PortType getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Component::Port::Builder {
public:
  typedef Port Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasContentType();
  inline  ::capnp::Text::Builder getContentType();
  inline void setContentType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initContentType(unsigned int size);
  inline void adoptContentType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownContentType();

  inline  ::mas::schema::fbp::Component::Port::PortType getType();
  inline void setType( ::mas::schema::fbp::Component::Port::PortType value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Component::Port::Pipeline {
public:
  typedef Port Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Component::Factory::Reader {
public:
  typedef Factory Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline  ::capnp::Void getNone() const;

  inline bool isRunnable() const;
  inline bool hasRunnable() const;
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Runnable::Factory::Client getRunnable() const;
#endif  // !CAPNP_LITE

  inline bool isProcess() const;
  inline bool hasProcess() const;
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Process::Factory::Client getProcess() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Component::Factory::Builder {
public:
  typedef Factory Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline  ::capnp::Void getNone();
  inline void setNone( ::capnp::Void value = ::capnp::VOID);

  inline bool isRunnable();
  inline bool hasRunnable();
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Runnable::Factory::Client getRunnable();
  inline void setRunnable( ::mas::schema::fbp::Runnable::Factory::Client&& value);
  inline void setRunnable( ::mas::schema::fbp::Runnable::Factory::Client& value);
  inline void adoptRunnable(::capnp::Orphan< ::mas::schema::fbp::Runnable::Factory>&& value);
  inline ::capnp::Orphan< ::mas::schema::fbp::Runnable::Factory> disownRunnable();
#endif  // !CAPNP_LITE

  inline bool isProcess();
  inline bool hasProcess();
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Process::Factory::Client getProcess();
  inline void setProcess( ::mas::schema::fbp::Process::Factory::Client&& value);
  inline void setProcess( ::mas::schema::fbp::Process::Factory::Client& value);
  inline void adoptProcess(::capnp::Orphan< ::mas::schema::fbp::Process::Factory>&& value);
  inline ::capnp::Orphan< ::mas::schema::fbp::Process::Factory> disownProcess();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Component::Factory::Pipeline {
public:
  typedef Factory Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Runnable::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Runnable Calls;
  typedef Runnable Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::fbp::Runnable::StartParams,  ::mas::schema::fbp::Runnable::StartResults> startRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Runnable::StopParams,  ::mas::schema::fbp::Runnable::StopResults> stopRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Runnable::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Runnable Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::fbp::Runnable::StartParams StartParams;
  typedef  ::mas::schema::fbp::Runnable::StartResults StartResults;
  typedef ::capnp::CallContext<StartParams, StartResults> StartContext;
  virtual ::kj::Promise<void> start(StartContext context);
  typedef  ::mas::schema::fbp::Runnable::StopParams StopParams;
  typedef  ::mas::schema::fbp::Runnable::StopResults StopResults;
  typedef ::capnp::CallContext<StopParams, StopResults> StopContext;
  virtual ::kj::Promise<void> stop(StopContext context);

  inline  ::mas::schema::fbp::Runnable::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::Runnable>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Runnable::Factory::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Factory Calls;
  typedef Factory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::fbp::Runnable::Factory::CreateParams,  ::mas::schema::fbp::Runnable::Factory::CreateResults> createRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Runnable::Factory::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Factory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::fbp::Runnable::Factory::CreateParams CreateParams;
  typedef  ::mas::schema::fbp::Runnable::Factory::CreateResults CreateResults;
  typedef ::capnp::CallContext<CreateParams, CreateResults> CreateContext;
  virtual ::kj::Promise<void> create(CreateContext context);

  inline  ::mas::schema::fbp::Runnable::Factory::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::Runnable::Factory>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Runnable::Factory::CreateParams::Reader {
public:
  typedef CreateParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Runnable::Factory::CreateParams::Builder {
public:
  typedef CreateParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Runnable::Factory::CreateParams::Pipeline {
public:
  typedef CreateParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Runnable::Factory::CreateResults::Reader {
public:
  typedef CreateResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasOut() const;
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Runnable::Client getOut() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Runnable::Factory::CreateResults::Builder {
public:
  typedef CreateResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasOut();
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Runnable::Client getOut();
  inline void setOut( ::mas::schema::fbp::Runnable::Client&& value);
  inline void setOut( ::mas::schema::fbp::Runnable::Client& value);
  inline void adoptOut(::capnp::Orphan< ::mas::schema::fbp::Runnable>&& value);
  inline ::capnp::Orphan< ::mas::schema::fbp::Runnable> disownOut();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Runnable::Factory::CreateResults::Pipeline {
public:
  typedef CreateResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::fbp::Runnable::Client getOut();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Runnable::StartParams::Reader {
public:
  typedef StartParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPortInfosReaderSr() const;
  inline  ::mas::schema::persistence::SturdyRef::Reader getPortInfosReaderSr() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Runnable::StartParams::Builder {
public:
  typedef StartParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPortInfosReaderSr();
  inline  ::mas::schema::persistence::SturdyRef::Builder getPortInfosReaderSr();
  inline void setPortInfosReaderSr( ::mas::schema::persistence::SturdyRef::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Builder initPortInfosReaderSr();
  inline void adoptPortInfosReaderSr(::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> disownPortInfosReaderSr();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Runnable::StartParams::Pipeline {
public:
  typedef StartParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::SturdyRef::Pipeline getPortInfosReaderSr();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Runnable::StartResults::Reader {
public:
  typedef StartResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Runnable::StartResults::Builder {
public:
  typedef StartResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Runnable::StartResults::Pipeline {
public:
  typedef StartResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Runnable::StopParams::Reader {
public:
  typedef StopParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Runnable::StopParams::Builder {
public:
  typedef StopParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Runnable::StopParams::Pipeline {
public:
  typedef StopParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Runnable::StopResults::Reader {
public:
  typedef StopResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Runnable::StopResults::Builder {
public:
  typedef StopResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Runnable::StopResults::Pipeline {
public:
  typedef StopResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Process::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::GatewayRegistrable::Client {
public:
  typedef Process Calls;
  typedef Process Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::fbp::Process::InPortsParams,  ::mas::schema::fbp::Process::InPortsResults> inPortsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Process::ConnectInPortParams,  ::mas::schema::fbp::Process::ConnectInPortResults> connectInPortRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Process::OutPortsParams,  ::mas::schema::fbp::Process::OutPortsResults> outPortsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Process::ConnectOutPortParams,  ::mas::schema::fbp::Process::ConnectOutPortResults> connectOutPortRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Process::ConfigEntriesParams,  ::mas::schema::fbp::Process::ConfigEntriesResults> configEntriesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Process::StartParams,  ::mas::schema::fbp::Process::StartResults> startRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Process::StopParams,  ::mas::schema::fbp::Process::StopResults> stopRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Process::ConfigEntry,  ::mas::schema::fbp::Process::SetConfigEntryResults> setConfigEntryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Process::StateParams,  ::mas::schema::fbp::Process::StateResults> stateRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Process::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::GatewayRegistrable::Server {
public:
  typedef Process Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::fbp::Process::InPortsParams InPortsParams;
  typedef  ::mas::schema::fbp::Process::InPortsResults InPortsResults;
  typedef ::capnp::CallContext<InPortsParams, InPortsResults> InPortsContext;
  virtual ::kj::Promise<void> inPorts(InPortsContext context);
  typedef  ::mas::schema::fbp::Process::ConnectInPortParams ConnectInPortParams;
  typedef  ::mas::schema::fbp::Process::ConnectInPortResults ConnectInPortResults;
  typedef ::capnp::CallContext<ConnectInPortParams, ConnectInPortResults> ConnectInPortContext;
  virtual ::kj::Promise<void> connectInPort(ConnectInPortContext context);
  typedef  ::mas::schema::fbp::Process::OutPortsParams OutPortsParams;
  typedef  ::mas::schema::fbp::Process::OutPortsResults OutPortsResults;
  typedef ::capnp::CallContext<OutPortsParams, OutPortsResults> OutPortsContext;
  virtual ::kj::Promise<void> outPorts(OutPortsContext context);
  typedef  ::mas::schema::fbp::Process::ConnectOutPortParams ConnectOutPortParams;
  typedef  ::mas::schema::fbp::Process::ConnectOutPortResults ConnectOutPortResults;
  typedef ::capnp::CallContext<ConnectOutPortParams, ConnectOutPortResults> ConnectOutPortContext;
  virtual ::kj::Promise<void> connectOutPort(ConnectOutPortContext context);
  typedef  ::mas::schema::fbp::Process::ConfigEntriesParams ConfigEntriesParams;
  typedef  ::mas::schema::fbp::Process::ConfigEntriesResults ConfigEntriesResults;
  typedef ::capnp::CallContext<ConfigEntriesParams, ConfigEntriesResults> ConfigEntriesContext;
  virtual ::kj::Promise<void> configEntries(ConfigEntriesContext context);
  typedef  ::mas::schema::fbp::Process::StartParams StartParams;
  typedef  ::mas::schema::fbp::Process::StartResults StartResults;
  typedef ::capnp::CallContext<StartParams, StartResults> StartContext;
  virtual ::kj::Promise<void> start(StartContext context);
  typedef  ::mas::schema::fbp::Process::StopParams StopParams;
  typedef  ::mas::schema::fbp::Process::StopResults StopResults;
  typedef ::capnp::CallContext<StopParams, StopResults> StopContext;
  virtual ::kj::Promise<void> stop(StopContext context);
  typedef  ::mas::schema::fbp::Process::SetConfigEntryResults SetConfigEntryResults;
  typedef ::capnp::CallContext< ::mas::schema::fbp::Process::ConfigEntry, SetConfigEntryResults> SetConfigEntryContext;
  virtual ::kj::Promise<void> setConfigEntry(SetConfigEntryContext context);
  typedef  ::mas::schema::fbp::Process::StateParams StateParams;
  typedef  ::mas::schema::fbp::Process::StateResults StateResults;
  typedef ::capnp::CallContext<StateParams, StateResults> StateContext;
  virtual ::kj::Promise<void> state(StateContext context);

  inline  ::mas::schema::fbp::Process::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::Process>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Process::Factory::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Factory Calls;
  typedef Factory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::fbp::Process::Factory::CreateParams,  ::mas::schema::fbp::Process::Factory::CreateResults> createRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Process::Factory::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Factory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::fbp::Process::Factory::CreateParams CreateParams;
  typedef  ::mas::schema::fbp::Process::Factory::CreateResults CreateResults;
  typedef ::capnp::CallContext<CreateParams, CreateResults> CreateContext;
  virtual ::kj::Promise<void> create(CreateContext context);

  inline  ::mas::schema::fbp::Process::Factory::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::Process::Factory>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Process::Factory::CreateParams::Reader {
public:
  typedef CreateParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::Factory::CreateParams::Builder {
public:
  typedef CreateParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::Factory::CreateParams::Pipeline {
public:
  typedef CreateParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::Factory::CreateResults::Reader {
public:
  typedef CreateResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasOut() const;
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Process::Client getOut() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::Factory::CreateResults::Builder {
public:
  typedef CreateResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasOut();
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Process::Client getOut();
  inline void setOut( ::mas::schema::fbp::Process::Client&& value);
  inline void setOut( ::mas::schema::fbp::Process::Client& value);
  inline void adoptOut(::capnp::Orphan< ::mas::schema::fbp::Process>&& value);
  inline ::capnp::Orphan< ::mas::schema::fbp::Process> disownOut();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::Factory::CreateResults::Pipeline {
public:
  typedef CreateResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::fbp::Process::Client getOut();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::ConfigEntry::Reader {
public:
  typedef ConfigEntry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasVal() const;
  inline  ::mas::schema::common::Value::Reader getVal() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::ConfigEntry::Builder {
public:
  typedef ConfigEntry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasVal();
  inline  ::mas::schema::common::Value::Builder getVal();
  inline void setVal( ::mas::schema::common::Value::Reader value);
  inline  ::mas::schema::common::Value::Builder initVal();
  inline void adoptVal(::capnp::Orphan< ::mas::schema::common::Value>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Value> disownVal();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::ConfigEntry::Pipeline {
public:
  typedef ConfigEntry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Value::Pipeline getVal();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Process::StateTransition::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef StateTransition Calls;
  typedef StateTransition Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::fbp::Process::StateTransition::StateChangedParams,  ::mas::schema::fbp::Process::StateTransition::StateChangedResults> stateChangedRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Process::StateTransition::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef StateTransition Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::fbp::Process::StateTransition::StateChangedParams StateChangedParams;
  typedef  ::mas::schema::fbp::Process::StateTransition::StateChangedResults StateChangedResults;
  typedef ::capnp::CallContext<StateChangedParams, StateChangedResults> StateChangedContext;
  virtual ::kj::Promise<void> stateChanged(StateChangedContext context);

  inline  ::mas::schema::fbp::Process::StateTransition::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::Process::StateTransition>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Process::StateTransition::StateChangedParams::Reader {
public:
  typedef StateChangedParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::fbp::Process::State getOld() const;

  inline  ::mas::schema::fbp::Process::State getNew() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::StateTransition::StateChangedParams::Builder {
public:
  typedef StateChangedParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::fbp::Process::State getOld();
  inline void setOld( ::mas::schema::fbp::Process::State value);

  inline  ::mas::schema::fbp::Process::State getNew();
  inline void setNew( ::mas::schema::fbp::Process::State value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::StateTransition::StateChangedParams::Pipeline {
public:
  typedef StateChangedParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::StateTransition::StateChangedResults::Reader {
public:
  typedef StateChangedResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::StateTransition::StateChangedResults::Builder {
public:
  typedef StateChangedResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::StateTransition::StateChangedResults::Pipeline {
public:
  typedef StateChangedResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::InPortsParams::Reader {
public:
  typedef InPortsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::InPortsParams::Builder {
public:
  typedef InPortsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::InPortsParams::Pipeline {
public:
  typedef InPortsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::InPortsResults::Reader {
public:
  typedef InPortsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader getPorts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::InPortsResults::Builder {
public:
  typedef InPortsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPorts();
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder getPorts();
  inline void setPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder initPorts(unsigned int size);
  inline void adoptPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> disownPorts();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::InPortsResults::Pipeline {
public:
  typedef InPortsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::ConnectInPortParams::Reader {
public:
  typedef ConnectInPortParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasSturdyRef() const;
  inline  ::mas::schema::persistence::SturdyRef::Reader getSturdyRef() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::ConnectInPortParams::Builder {
public:
  typedef ConnectInPortParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasSturdyRef();
  inline  ::mas::schema::persistence::SturdyRef::Builder getSturdyRef();
  inline void setSturdyRef( ::mas::schema::persistence::SturdyRef::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Builder initSturdyRef();
  inline void adoptSturdyRef(::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> disownSturdyRef();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::ConnectInPortParams::Pipeline {
public:
  typedef ConnectInPortParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::SturdyRef::Pipeline getSturdyRef();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::ConnectInPortResults::Reader {
public:
  typedef ConnectInPortResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getConnected() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::ConnectInPortResults::Builder {
public:
  typedef ConnectInPortResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getConnected();
  inline void setConnected(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::ConnectInPortResults::Pipeline {
public:
  typedef ConnectInPortResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::OutPortsParams::Reader {
public:
  typedef OutPortsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::OutPortsParams::Builder {
public:
  typedef OutPortsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::OutPortsParams::Pipeline {
public:
  typedef OutPortsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::OutPortsResults::Reader {
public:
  typedef OutPortsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader getPorts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::OutPortsResults::Builder {
public:
  typedef OutPortsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPorts();
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder getPorts();
  inline void setPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder initPorts(unsigned int size);
  inline void adoptPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> disownPorts();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::OutPortsResults::Pipeline {
public:
  typedef OutPortsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::ConnectOutPortParams::Reader {
public:
  typedef ConnectOutPortParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasSturdyRef() const;
  inline  ::mas::schema::persistence::SturdyRef::Reader getSturdyRef() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::ConnectOutPortParams::Builder {
public:
  typedef ConnectOutPortParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasSturdyRef();
  inline  ::mas::schema::persistence::SturdyRef::Builder getSturdyRef();
  inline void setSturdyRef( ::mas::schema::persistence::SturdyRef::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Builder initSturdyRef();
  inline void adoptSturdyRef(::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> disownSturdyRef();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::ConnectOutPortParams::Pipeline {
public:
  typedef ConnectOutPortParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::SturdyRef::Pipeline getSturdyRef();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::ConnectOutPortResults::Reader {
public:
  typedef ConnectOutPortResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getConnected() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::ConnectOutPortResults::Builder {
public:
  typedef ConnectOutPortResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getConnected();
  inline void setConnected(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::ConnectOutPortResults::Pipeline {
public:
  typedef ConnectOutPortResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::ConfigEntriesParams::Reader {
public:
  typedef ConfigEntriesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::ConfigEntriesParams::Builder {
public:
  typedef ConfigEntriesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::ConfigEntriesParams::Pipeline {
public:
  typedef ConfigEntriesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::ConfigEntriesResults::Reader {
public:
  typedef ConfigEntriesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasConfig() const;
  inline  ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>::Reader getConfig() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::ConfigEntriesResults::Builder {
public:
  typedef ConfigEntriesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasConfig();
  inline  ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>::Builder getConfig();
  inline void setConfig( ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>::Builder initConfig(unsigned int size);
  inline void adoptConfig(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>> disownConfig();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::ConfigEntriesResults::Pipeline {
public:
  typedef ConfigEntriesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::StartParams::Reader {
public:
  typedef StartParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::StartParams::Builder {
public:
  typedef StartParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::StartParams::Pipeline {
public:
  typedef StartParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::StartResults::Reader {
public:
  typedef StartResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::StartResults::Builder {
public:
  typedef StartResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::StartResults::Pipeline {
public:
  typedef StartResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::StopParams::Reader {
public:
  typedef StopParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::StopParams::Builder {
public:
  typedef StopParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::StopParams::Pipeline {
public:
  typedef StopParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::StopResults::Reader {
public:
  typedef StopResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::StopResults::Builder {
public:
  typedef StopResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::StopResults::Pipeline {
public:
  typedef StopResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::SetConfigEntryResults::Reader {
public:
  typedef SetConfigEntryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::SetConfigEntryResults::Builder {
public:
  typedef SetConfigEntryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::SetConfigEntryResults::Pipeline {
public:
  typedef SetConfigEntryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::StateParams::Reader {
public:
  typedef StateParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTransitionCallback() const;
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Process::StateTransition::Client getTransitionCallback() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::StateParams::Builder {
public:
  typedef StateParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTransitionCallback();
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Process::StateTransition::Client getTransitionCallback();
  inline void setTransitionCallback( ::mas::schema::fbp::Process::StateTransition::Client&& value);
  inline void setTransitionCallback( ::mas::schema::fbp::Process::StateTransition::Client& value);
  inline void adoptTransitionCallback(::capnp::Orphan< ::mas::schema::fbp::Process::StateTransition>&& value);
  inline ::capnp::Orphan< ::mas::schema::fbp::Process::StateTransition> disownTransitionCallback();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::StateParams::Pipeline {
public:
  typedef StateParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::fbp::Process::StateTransition::Client getTransitionCallback();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::StateResults::Reader {
public:
  typedef StateResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::fbp::Process::State getCurrentState() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::StateResults::Builder {
public:
  typedef StateResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::fbp::Process::State getCurrentState();
  inline void setCurrentState( ::mas::schema::fbp::Process::State value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::StateResults::Pipeline {
public:
  typedef StateResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool IP::Reader::hasAttributes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IP::Builder::hasAttributes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Reader IP::Reader::getAttributes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Builder IP::Builder::getAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IP::Builder::setAttributes( ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Builder IP::Builder::initAttributes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IP::Builder::adoptAttributes(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>> IP::Builder::disownAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IP::Reader::hasContent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool IP::Builder::hasContent() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader IP::Reader::getContent() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::Builder::getContent() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::Builder::initContent() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline  ::mas::schema::fbp::IP::Type IP::Reader::getType() const {
  return _reader.getDataField< ::mas::schema::fbp::IP::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::fbp::IP::Type IP::Builder::getType() {
  return _builder.getDataField< ::mas::schema::fbp::IP::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IP::Builder::setType( ::mas::schema::fbp::IP::Type value) {
  _builder.setDataField< ::mas::schema::fbp::IP::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IP::KV::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IP::KV::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IP::KV::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IP::KV::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IP::KV::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IP::KV::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IP::KV::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IP::KV::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IP::KV::Reader::hasDesc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool IP::KV::Builder::hasDesc() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IP::KV::Reader::getDesc() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IP::KV::Builder::getDesc() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void IP::KV::Builder::setDesc( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IP::KV::Builder::initDesc(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void IP::KV::Builder::adoptDesc(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IP::KV::Builder::disownDesc() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool IP::KV::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool IP::KV::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader IP::KV::Reader::getValue() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::KV::Builder::getValue() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::KV::Builder::initValue() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool IIP::Reader::hasContent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IIP::Builder::hasContent() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader IIP::Reader::getContent() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IIP::Builder::getContent() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IIP::Builder::initContent() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

#if !CAPNP_LITE
template <typename V>
inline Channel<V>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline Channel<V>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline Channel<V>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Client& Channel<V>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Client& Channel<V>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Msg::Which Channel<V>::Msg::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Msg::Which Channel<V>::Msg::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline bool Channel<V>::Msg::Reader::isValue() const {
  return which() == Channel<V>::Msg::VALUE;
}
template <typename V>
inline bool Channel<V>::Msg::Builder::isValue() {
  return which() == Channel<V>::Msg::VALUE;
}
template <typename V>
inline bool Channel<V>::Msg::Reader::hasValue() const {
  if (which() != Channel<V>::Msg::VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::Msg::Builder::hasValue() {
  if (which() != Channel<V>::Msg::VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline  ::capnp::ReaderFor<V> Channel<V>::Msg::Reader::getValue() const {
  KJ_IREQUIRE((which() == Channel<V>::Msg::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<V>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::BuilderFor<V> Channel<V>::Msg::Builder::getValue() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<V>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::Msg::Builder::setValue( ::capnp::ReaderFor<V> value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  ::capnp::_::PointerHelpers<V>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename V>
inline  ::capnp::BuilderFor<V> Channel<V>::Msg::Builder::initValue() {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  return ::capnp::_::PointerHelpers<V>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::BuilderFor<V> Channel<V>::Msg::Builder::initValue(unsigned int size) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  return ::capnp::_::PointerHelpers<V>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::Msg::Builder::adoptValue(
    ::capnp::Orphan<V>&& value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  ::capnp::_::PointerHelpers<V>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<V> Channel<V>::Msg::Builder::disownValue() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<V>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename V>
inline bool Channel<V>::Msg::Reader::isDone() const {
  return which() == Channel<V>::Msg::DONE;
}
template <typename V>
inline bool Channel<V>::Msg::Builder::isDone() {
  return which() == Channel<V>::Msg::DONE;
}
template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Reader::getDone() const {
  KJ_IREQUIRE((which() == Channel<V>::Msg::DONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Builder::getDone() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::DONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::Msg::Builder::setDone( ::capnp::Void value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::DONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename V>
inline bool Channel<V>::Msg::Reader::isNoMsg() const {
  return which() == Channel<V>::Msg::NO_MSG;
}
template <typename V>
inline bool Channel<V>::Msg::Builder::isNoMsg() {
  return which() == Channel<V>::Msg::NO_MSG;
}
template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Reader::getNoMsg() const {
  KJ_IREQUIRE((which() == Channel<V>::Msg::NO_MSG),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Builder::getNoMsg() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::NO_MSG),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::Msg::Builder::setNoMsg( ::capnp::Void value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::NO_MSG);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// Channel<V>::Msg
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::Msg::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::Msg::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::Msg::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::Msg::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::Msg::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::Msg::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::Msg::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d5b512f4bcd0aa2e, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline  ::uint64_t Channel<V>::StartupInfo::Reader::getBufferSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline  ::uint64_t Channel<V>::StartupInfo::Builder::getBufferSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setBufferSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics Channel<V>::StartupInfo::Reader::getCloseSemantics() const {
  return _reader.getDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics Channel<V>::StartupInfo::Builder::getCloseSemantics() {
  return _builder.getDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setCloseSemantics(typename  ::mas::schema::fbp::Channel<V>::CloseSemantics value) {
  _builder.setDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

template <typename V>
inline bool Channel<V>::StartupInfo::Reader::hasChannelSR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::StartupInfo::Builder::hasChannelSR() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline  ::mas::schema::persistence::SturdyRef::Reader Channel<V>::StartupInfo::Reader::getChannelSR() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::mas::schema::persistence::SturdyRef::Builder Channel<V>::StartupInfo::Builder::getChannelSR() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename V>
inline  ::mas::schema::persistence::SturdyRef::Pipeline Channel<V>::StartupInfo::Pipeline::getChannelSR() {
  return  ::mas::schema::persistence::SturdyRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setChannelSR( ::mas::schema::persistence::SturdyRef::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename V>
inline  ::mas::schema::persistence::SturdyRef::Builder Channel<V>::StartupInfo::Builder::initChannelSR() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::adoptChannelSR(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> Channel<V>::StartupInfo::Builder::disownChannelSR() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename V>
inline bool Channel<V>::StartupInfo::Reader::hasReaderSRs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::StartupInfo::Builder::hasReaderSRs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader Channel<V>::StartupInfo::Reader::getReaderSRs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder Channel<V>::StartupInfo::Builder::getReaderSRs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setReaderSRs( ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename V>
inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder Channel<V>::StartupInfo::Builder::initReaderSRs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::adoptReaderSRs(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>> Channel<V>::StartupInfo::Builder::disownReaderSRs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename V>
inline bool Channel<V>::StartupInfo::Reader::hasWriterSRs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::StartupInfo::Builder::hasWriterSRs() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader Channel<V>::StartupInfo::Reader::getWriterSRs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder Channel<V>::StartupInfo::Builder::getWriterSRs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setWriterSRs( ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename V>
inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder Channel<V>::StartupInfo::Builder::initWriterSRs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::adoptWriterSRs(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>> Channel<V>::StartupInfo::Builder::disownWriterSRs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

template <typename V>
inline bool Channel<V>::StartupInfo::Reader::hasChannel() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::StartupInfo::Builder::hasChannel() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Client Channel<V>::StartupInfo::Reader::getChannel() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Channel<V>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Client Channel<V>::StartupInfo::Builder::getChannel() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Channel<V>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Client Channel<V>::StartupInfo::Pipeline::getChannel() {
  return typename  ::mas::schema::fbp::Channel<V>::Client(_typeless.getPointerField(3).asCap());
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setChannel(typename  ::mas::schema::fbp::Channel<V>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Channel<V>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setChannel(typename  ::mas::schema::fbp::Channel<V>::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Channel<V>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::adoptChannel(
    ::capnp::Orphan< ::mas::schema::fbp::Channel<V>>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Channel<V>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan< ::mas::schema::fbp::Channel<V>> Channel<V>::StartupInfo::Builder::disownChannel() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Channel<V>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::StartupInfo::Reader::hasReaders() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::StartupInfo::Builder::hasReaders() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>::Reader Channel<V>::StartupInfo::Reader::getReaders() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>::Builder Channel<V>::StartupInfo::Builder::getReaders() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setReaders(typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
template <typename V>
inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>::Builder Channel<V>::StartupInfo::Builder::initReaders(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::adoptReaders(
    ::capnp::Orphan< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>> Channel<V>::StartupInfo::Builder::disownReaders() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanReader,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::StartupInfo::Reader::hasWriters() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::StartupInfo::Builder::hasWriters() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>::Reader Channel<V>::StartupInfo::Reader::getWriters() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>::Builder Channel<V>::StartupInfo::Builder::getWriters() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setWriters(typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
template <typename V>
inline typename  ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>::Builder Channel<V>::StartupInfo::Builder::initWriters(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::adoptWriters(
    ::capnp::Orphan< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>> Channel<V>::StartupInfo::Builder::disownWriters() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::fbp::Channel<V>::ChanWriter,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::StartupInfo
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::StartupInfo::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::StartupInfo::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::StartupInfo::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::StartupInfo::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::StartupInfo::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::StartupInfo::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::StartupInfo::_capnpPrivate::brandDependencies[] = {
  { 16777221,  ::mas::schema::fbp::Channel<V>::_capnpPrivate::brand() },
  { 16777222,  ::mas::schema::fbp::Channel<V>::ChanReader::_capnpPrivate::brand() },
  { 16777223,  ::mas::schema::fbp::Channel<V>::ChanWriter::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::StartupInfo::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e3d7a3237f175028, brandScopes, brandDependencies,
  1, 3, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
inline Channel<V>::ChanReader::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline Channel<V>::ChanReader::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanReader::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanReader::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline Channel<V>::ChanReader::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& Channel<V>::ChanReader::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& Channel<V>::ChanReader::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// Channel<V>::ChanReader::ReadParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::ReadParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::ReadParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::ReadParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::ReadParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::ReadParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c0335d99db8b2ba5, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader::CloseParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::CloseParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::CloseParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::CloseParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::CloseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::CloseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9428ea64f18c41c8, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader::CloseResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::CloseResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::CloseResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::CloseResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::CloseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::CloseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b3fe08a1bf53821a, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader::ReadIfMsgParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_89e521a99fcc4044, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg>)
Channel<V>::ChanReader::Client::readRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg>(
      0x8bc69192f3bc97ccull, 0, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanReader::Server::read(ReadContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Reader", "read",
      0x8bc69192f3bc97ccull, 0);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults>)
Channel<V>::ChanReader::Client::closeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults>(
      0x8bc69192f3bc97ccull, 1, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanReader::Server::close(CloseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Reader", "close",
      0x8bc69192f3bc97ccull, 1);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg>)
Channel<V>::ChanReader::Client::readIfMsgRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg>(
      0x8bc69192f3bc97ccull, 2, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanReader::Server::readIfMsg(ReadIfMsgContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Reader", "readIfMsg",
      0x8bc69192f3bc97ccull, 2);
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanReader::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0x8bc69192f3bc97ccull:
      return dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    case 0xc1a7daa0dc36cb65ull:
      return  ::mas::schema::persistence::Persistent::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("fbp.capnp:Channel.Reader", interfaceId);
  }
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanReader::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        read(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg>(context)),
        false,
        false
      };
    case 1:
      return {
        close(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults>(context)),
        false,
        false
      };
    case 2:
      return {
        readIfMsg(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg>(context)),
        false,
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "fbp.capnp:Channel.Reader",
          0x8bc69192f3bc97ccull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::ChanReader::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams::_capnpPrivate::brand() },
  { 33554434,  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::fbp::Channel<V>::Msg::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults::_capnpPrivate::brand() },
  { 50331650,  ::mas::schema::fbp::Channel<V>::Msg::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_8bc69192f3bc97cc, brandScopes, brandDependencies,
  1, 6, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
inline Channel<V>::ChanWriter::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline Channel<V>::ChanWriter::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanWriter::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanWriter::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline Channel<V>::ChanWriter::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& Channel<V>::ChanWriter::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& Channel<V>::ChanWriter::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// Channel<V>::ChanWriter::WriteResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::WriteResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::WriteResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::WriteResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::WriteResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::WriteResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ce9f24b8ec149524, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanWriter::CloseParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::CloseParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::CloseParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::CloseParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::CloseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::CloseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_badc988dda3d1e50, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanWriter::CloseResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::CloseResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::CloseResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::CloseResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::CloseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::CloseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_cb02dc91e18e58c9, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::ChanWriter::WriteIfSpaceResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline bool Channel<V>::ChanWriter::WriteIfSpaceResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::ChanWriter::WriteIfSpaceResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// Channel<V>::ChanWriter::WriteIfSpaceResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c61c438f89d10281, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults>)
Channel<V>::ChanWriter::Client::writeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults>(
      0xf7fec613b4a8c79full, 0, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanWriter::Server::write(WriteContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Writer", "write",
      0xf7fec613b4a8c79full, 0);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults>)
Channel<V>::ChanWriter::Client::closeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults>(
      0xf7fec613b4a8c79full, 1, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanWriter::Server::close(CloseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Writer", "close",
      0xf7fec613b4a8c79full, 1);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults>)
Channel<V>::ChanWriter::Client::writeIfSpaceRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults>(
      0xf7fec613b4a8c79full, 2, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanWriter::Server::writeIfSpace(WriteIfSpaceContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Writer", "writeIfSpace",
      0xf7fec613b4a8c79full, 2);
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanWriter::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xf7fec613b4a8c79full:
      return dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    case 0xc1a7daa0dc36cb65ull:
      return  ::mas::schema::persistence::Persistent::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("fbp.capnp:Channel.Writer", interfaceId);
  }
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanWriter::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        write(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults>(context)),
        false,
        false
      };
    case 1:
      return {
        close(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults>(context)),
        false,
        false
      };
    case 2:
      return {
        writeIfSpace(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults>(context)),
        false,
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "fbp.capnp:Channel.Writer",
          0xf7fec613b4a8c79full, methodId);
  }
}
#endif  // !CAPNP_LITE

// Channel<V>::ChanWriter
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::ChanWriter::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::fbp::Channel<V>::Msg::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams::_capnpPrivate::brand() },
  { 33554434,  ::mas::schema::fbp::Channel<V>::Msg::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults::_capnpPrivate::brand() },
  { 50331650,  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f7fec613b4a8c79f, brandScopes, brandDependencies,
  1, 6, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline  ::uint64_t Channel<V>::SetBufferSizeParams::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1ull);
}

template <typename V>
inline  ::uint64_t Channel<V>::SetBufferSizeParams::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1ull);
}
template <typename V>
inline void Channel<V>::SetBufferSizeParams::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1ull);
}

// Channel<V>::SetBufferSizeParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetBufferSizeParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetBufferSizeParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetBufferSizeParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetBufferSizeParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetBufferSizeParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_92101e3b7a761333, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::SetBufferSizeResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetBufferSizeResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetBufferSizeResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetBufferSizeResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetBufferSizeResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetBufferSizeResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_fe6a08d5e0712c23, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ReaderParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ReaderParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ReaderParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ReaderParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ReaderParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ReaderParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ReaderParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ReaderParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e607c9dd64da04c4, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::ReaderResults::Reader::hasR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::ReaderResults::Builder::hasR() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::ReaderResults::Reader::getR() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::ReaderResults::Builder::getR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::ReaderResults::Pipeline::getR() {
  return typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client(_typeless.getPointerField(0).asCap());
}
template <typename V>
inline void Channel<V>::ReaderResults::Builder::setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::ReaderResults::Builder::setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::ReaderResults::Builder::adoptR(
    ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader> Channel<V>::ReaderResults::Builder::disownR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::ReaderResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ReaderResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ReaderResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ReaderResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ReaderResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ReaderResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ReaderResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::ReaderResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::fbp::Channel<V>::ChanReader::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ReaderResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b135ffc9ccc9eca6, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::WriterParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::WriterParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::WriterParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::WriterParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::WriterParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::WriterParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::WriterParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::WriterParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_be611d34e368e109, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::WriterResults::Reader::hasW() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::WriterResults::Builder::hasW() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::WriterResults::Reader::getW() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::WriterResults::Builder::getW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::WriterResults::Pipeline::getW() {
  return typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client(_typeless.getPointerField(0).asCap());
}
template <typename V>
inline void Channel<V>::WriterResults::Builder::setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::WriterResults::Builder::setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::WriterResults::Builder::adoptW(
    ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter> Channel<V>::WriterResults::Builder::disownW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::WriterResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::WriterResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::WriterResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::WriterResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::WriterResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::WriterResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::WriterResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::WriterResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::fbp::Channel<V>::ChanWriter::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::WriterResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b47b53679e985c7e, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::EndpointsParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::EndpointsParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::EndpointsParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::EndpointsParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::EndpointsParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::EndpointsParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::EndpointsParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::EndpointsParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d23f817e914373d8, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::EndpointsResults::Reader::hasR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::EndpointsResults::Builder::hasR() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::EndpointsResults::Reader::getR() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::EndpointsResults::Builder::getR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::EndpointsResults::Pipeline::getR() {
  return typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client(_typeless.getPointerField(0).asCap());
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::adoptR(
    ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader> Channel<V>::EndpointsResults::Builder::disownR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::EndpointsResults::Reader::hasW() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::EndpointsResults::Builder::hasW() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::EndpointsResults::Reader::getW() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::EndpointsResults::Builder::getW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::EndpointsResults::Pipeline::getW() {
  return typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client(_typeless.getPointerField(1).asCap());
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::adoptW(
    ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter> Channel<V>::EndpointsResults::Builder::disownW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::EndpointsResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::EndpointsResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::EndpointsResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::EndpointsResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::EndpointsResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::EndpointsResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::EndpointsResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::EndpointsResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::fbp::Channel<V>::ChanReader::_capnpPrivate::brand() },
  { 16777217,  ::mas::schema::fbp::Channel<V>::ChanWriter::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::EndpointsResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f37401d21f8d97bb, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics Channel<V>::SetAutoCloseSemanticsParams::Reader::getCs() const {
  return _reader.getDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics Channel<V>::SetAutoCloseSemanticsParams::Builder::getCs() {
  return _builder.getDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::SetAutoCloseSemanticsParams::Builder::setCs(typename  ::mas::schema::fbp::Channel<V>::CloseSemantics value) {
  _builder.setDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// Channel<V>::SetAutoCloseSemanticsParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b49836b545583add, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::SetAutoCloseSemanticsResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c0fc6e5a3fcb3206, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::CloseParams::Reader::getWaitForEmptyBuffer() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}

template <typename V>
inline bool Channel<V>::CloseParams::Builder::getWaitForEmptyBuffer() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}
template <typename V>
inline void Channel<V>::CloseParams::Builder::setWaitForEmptyBuffer(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, true);
}

// Channel<V>::CloseParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::CloseParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::CloseParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::CloseParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::CloseParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::CloseParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::CloseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::CloseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_95d8ad01c1113d9c, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::CloseResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::CloseResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::CloseResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::CloseResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::CloseResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::CloseResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::CloseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::CloseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_cc079ad60f1363b7, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults>)
Channel<V>::Client::setBufferSizeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults>(
      0x9c62c32b2ff2b1e8ull, 0, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::setBufferSize(SetBufferSizeContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "setBufferSize",
      0x9c62c32b2ff2b1e8ull, 0);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ReaderParams, typename  ::mas::schema::fbp::Channel<V>::ReaderResults>)
Channel<V>::Client::readerRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ReaderParams, typename  ::mas::schema::fbp::Channel<V>::ReaderResults>(
      0x9c62c32b2ff2b1e8ull, 1, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::reader(ReaderContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "reader",
      0x9c62c32b2ff2b1e8ull, 1);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::WriterParams, typename  ::mas::schema::fbp::Channel<V>::WriterResults>)
Channel<V>::Client::writerRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::WriterParams, typename  ::mas::schema::fbp::Channel<V>::WriterResults>(
      0x9c62c32b2ff2b1e8ull, 2, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::writer(WriterContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "writer",
      0x9c62c32b2ff2b1e8ull, 2);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::EndpointsParams, typename  ::mas::schema::fbp::Channel<V>::EndpointsResults>)
Channel<V>::Client::endpointsRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::EndpointsParams, typename  ::mas::schema::fbp::Channel<V>::EndpointsResults>(
      0x9c62c32b2ff2b1e8ull, 3, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::endpoints(EndpointsContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "endpoints",
      0x9c62c32b2ff2b1e8ull, 3);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults>)
Channel<V>::Client::setAutoCloseSemanticsRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults>(
      0x9c62c32b2ff2b1e8ull, 4, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::setAutoCloseSemantics(SetAutoCloseSemanticsContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "setAutoCloseSemantics",
      0x9c62c32b2ff2b1e8ull, 4);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::CloseParams, typename  ::mas::schema::fbp::Channel<V>::CloseResults>)
Channel<V>::Client::closeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::CloseParams, typename  ::mas::schema::fbp::Channel<V>::CloseResults>(
      0x9c62c32b2ff2b1e8ull, 5, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::close(CloseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "close",
      0x9c62c32b2ff2b1e8ull, 5);
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0x9c62c32b2ff2b1e8ull:
      return dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    case 0xc1a7daa0dc36cb65ull:
      return  ::mas::schema::persistence::Persistent::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("fbp.capnp:Channel", interfaceId);
  }
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        setBufferSize(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults>(context)),
        false,
        false
      };
    case 1:
      return {
        reader(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ReaderParams, typename  ::mas::schema::fbp::Channel<V>::ReaderResults>(context)),
        false,
        false
      };
    case 2:
      return {
        writer(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::WriterParams, typename  ::mas::schema::fbp::Channel<V>::WriterResults>(context)),
        false,
        false
      };
    case 3:
      return {
        endpoints(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::EndpointsParams, typename  ::mas::schema::fbp::Channel<V>::EndpointsResults>(context)),
        false,
        false
      };
    case 4:
      return {
        setAutoCloseSemantics(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults>(context)),
        false,
        false
      };
    case 5:
      return {
        close(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::CloseParams, typename  ::mas::schema::fbp::Channel<V>::CloseResults>(context)),
        false,
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "fbp.capnp:Channel",
          0x9c62c32b2ff2b1e8ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Channel<V>
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::fbp::Channel<V>::ReaderParams::_capnpPrivate::brand() },
  { 33554434,  ::mas::schema::fbp::Channel<V>::WriterParams::_capnpPrivate::brand() },
  { 33554435,  ::mas::schema::fbp::Channel<V>::EndpointsParams::_capnpPrivate::brand() },
  { 33554436,  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::brand() },
  { 33554437,  ::mas::schema::fbp::Channel<V>::CloseParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::fbp::Channel<V>::ReaderResults::_capnpPrivate::brand() },
  { 50331650,  ::mas::schema::fbp::Channel<V>::WriterResults::_capnpPrivate::brand() },
  { 50331651,  ::mas::schema::fbp::Channel<V>::EndpointsResults::_capnpPrivate::brand() },
  { 50331652,  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::brand() },
  { 50331653,  ::mas::schema::fbp::Channel<V>::CloseResults::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9c62c32b2ff2b1e8, brandScopes, brandDependencies,
  1, 12, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline StartChannelsService::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline StartChannelsService::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline StartChannelsService::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline StartChannelsService::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline StartChannelsService::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::fbp::StartChannelsService::Client& StartChannelsService::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::fbp::StartChannelsService::Client& StartChannelsService::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool StartChannelsService::Params::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::Params::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader StartChannelsService::Params::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder StartChannelsService::Params::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void StartChannelsService::Params::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder StartChannelsService::Params::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StartChannelsService::Params::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> StartChannelsService::Params::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t StartChannelsService::Params::Reader::getNoOfChannels() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Builder::getNoOfChannels() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}
inline void StartChannelsService::Params::Builder::setNoOfChannels( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Reader::getNoOfReaders() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Builder::getNoOfReaders() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1u);
}
inline void StartChannelsService::Params::Builder::setNoOfReaders( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Reader::getNoOfWriters() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Builder::getNoOfWriters() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, 1u);
}
inline void StartChannelsService::Params::Builder::setNoOfWriters( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value, 1u);
}

inline bool StartChannelsService::Params::Reader::hasReaderSrts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::Params::Builder::hasReaderSrts() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader StartChannelsService::Params::Reader::getReaderSrts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder StartChannelsService::Params::Builder::getReaderSrts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void StartChannelsService::Params::Builder::setReaderSrts( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void StartChannelsService::Params::Builder::setReaderSrts(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder StartChannelsService::Params::Builder::initReaderSrts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void StartChannelsService::Params::Builder::adoptReaderSrts(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> StartChannelsService::Params::Builder::disownReaderSrts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool StartChannelsService::Params::Reader::hasWriterSrts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::Params::Builder::hasWriterSrts() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader StartChannelsService::Params::Reader::getWriterSrts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder StartChannelsService::Params::Builder::getWriterSrts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void StartChannelsService::Params::Builder::setWriterSrts( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void StartChannelsService::Params::Builder::setWriterSrts(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder StartChannelsService::Params::Builder::initWriterSrts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void StartChannelsService::Params::Builder::adoptWriterSrts(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> StartChannelsService::Params::Builder::disownWriterSrts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint16_t StartChannelsService::Params::Reader::getBufferSize() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Builder::getBufferSize() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, 1u);
}
inline void StartChannelsService::Params::Builder::setBufferSize( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value, 1u);
}

inline bool StartChannelsService::StartResults::Reader::hasStartupInfos() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::StartResults::Builder::hasStartupInfos() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Reader StartChannelsService::StartResults::Reader::getStartupInfos() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Builder StartChannelsService::StartResults::Builder::getStartupInfos() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void StartChannelsService::StartResults::Builder::setStartupInfos( ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Builder StartChannelsService::StartResults::Builder::initStartupInfos(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StartChannelsService::StartResults::Builder::adoptStartupInfos(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>> StartChannelsService::StartResults::Builder::disownStartupInfos() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool StartChannelsService::StartResults::Reader::hasStop() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::StartResults::Builder::hasStop() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::service::Stoppable::Client StartChannelsService::StartResults::Reader::getStop() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::service::Stoppable::Client StartChannelsService::StartResults::Builder::getStop() {
  return ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::service::Stoppable::Client StartChannelsService::StartResults::Pipeline::getStop() {
  return  ::mas::schema::service::Stoppable::Client(_typeless.getPointerField(1).asCap());
}
inline void StartChannelsService::StartResults::Builder::setStop( ::mas::schema::service::Stoppable::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void StartChannelsService::StartResults::Builder::setStop( ::mas::schema::service::Stoppable::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void StartChannelsService::StartResults::Builder::adoptStop(
    ::capnp::Orphan< ::mas::schema::service::Stoppable>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::service::Stoppable> StartChannelsService::StartResults::Builder::disownStop() {
  return ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool PortInfos::Reader::hasInPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::Builder::hasInPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader PortInfos::Reader::getInPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder PortInfos::Builder::getInPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PortInfos::Builder::setInPorts( ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder PortInfos::Builder::initInPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PortInfos::Builder::adoptInPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>> PortInfos::Builder::disownInPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PortInfos::Reader::hasOutPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::Builder::hasOutPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader PortInfos::Reader::getOutPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder PortInfos::Builder::getOutPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PortInfos::Builder::setOutPorts( ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder PortInfos::Builder::initOutPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void PortInfos::Builder::adoptOutPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>> PortInfos::Builder::disownOutPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::mas::schema::fbp::PortInfos::NameAndSR::Which PortInfos::NameAndSR::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::fbp::PortInfos::NameAndSR::Which PortInfos::NameAndSR::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool PortInfos::NameAndSR::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::NameAndSR::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader PortInfos::NameAndSR::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder PortInfos::NameAndSR::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PortInfos::NameAndSR::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder PortInfos::NameAndSR::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PortInfos::NameAndSR::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> PortInfos::NameAndSR::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PortInfos::NameAndSR::Reader::isSr() const {
  return which() == PortInfos::NameAndSR::SR;
}
inline bool PortInfos::NameAndSR::Builder::isSr() {
  return which() == PortInfos::NameAndSR::SR;
}
inline bool PortInfos::NameAndSR::Reader::hasSr() const {
  if (which() != PortInfos::NameAndSR::SR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::NameAndSR::Builder::hasSr() {
  if (which() != PortInfos::NameAndSR::SR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Reader PortInfos::NameAndSR::Reader::getSr() const {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Builder PortInfos::NameAndSR::Builder::getSr() {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PortInfos::NameAndSR::Builder::setSr( ::mas::schema::persistence::SturdyRef::Reader value) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SR);
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Builder PortInfos::NameAndSR::Builder::initSr() {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SR);
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PortInfos::NameAndSR::Builder::adoptSr(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SR);
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> PortInfos::NameAndSR::Builder::disownSr() {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PortInfos::NameAndSR::Reader::isSrs() const {
  return which() == PortInfos::NameAndSR::SRS;
}
inline bool PortInfos::NameAndSR::Builder::isSrs() {
  return which() == PortInfos::NameAndSR::SRS;
}
inline bool PortInfos::NameAndSR::Reader::hasSrs() const {
  if (which() != PortInfos::NameAndSR::SRS) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::NameAndSR::Builder::hasSrs() {
  if (which() != PortInfos::NameAndSR::SRS) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader PortInfos::NameAndSR::Reader::getSrs() const {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SRS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder PortInfos::NameAndSR::Builder::getSrs() {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SRS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PortInfos::NameAndSR::Builder::setSrs( ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Reader value) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SRS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>::Builder PortInfos::NameAndSR::Builder::initSrs(unsigned int size) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SRS);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void PortInfos::NameAndSR::Builder::adoptSrs(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>&& value) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SRS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>> PortInfos::NameAndSR::Builder::disownSrs() {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SRS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::persistence::SturdyRef,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Component::Reader::hasInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Builder::hasInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::IdInformation::Reader Component::Reader::getInfo() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::IdInformation::Builder Component::Builder::getInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::IdInformation::Pipeline Component::Pipeline::getInfo() {
  return  ::mas::schema::common::IdInformation::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Component::Builder::setInfo( ::mas::schema::common::IdInformation::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::IdInformation::Builder Component::Builder::initInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Component::Builder::adoptInfo(
    ::capnp::Orphan< ::mas::schema::common::IdInformation>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::IdInformation> Component::Builder::disownInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::mas::schema::fbp::Component::ComponentType Component::Reader::getType() const {
  return _reader.getDataField< ::mas::schema::fbp::Component::ComponentType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::fbp::Component::ComponentType Component::Builder::getType() {
  return _builder.getDataField< ::mas::schema::fbp::Component::ComponentType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Component::Builder::setType( ::mas::schema::fbp::Component::ComponentType value) {
  _builder.setDataField< ::mas::schema::fbp::Component::ComponentType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Component::Reader::hasInPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Builder::hasInPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader Component::Reader::getInPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Component::Builder::getInPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Component::Builder::setInPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Component::Builder::initInPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Component::Builder::adoptInPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> Component::Builder::disownInPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Component::Reader::hasOutPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Builder::hasOutPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader Component::Reader::getOutPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Component::Builder::getOutPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Component::Builder::setOutPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Component::Builder::initOutPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Component::Builder::adoptOutPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> Component::Builder::disownOutPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Component::Reader::hasDefaultConfig() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Builder::hasDefaultConfig() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Component::Reader::getDefaultConfig() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Component::Builder::getDefaultConfig() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Component::Builder::setDefaultConfig( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Component::Builder::initDefaultConfig(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Component::Builder::adoptDefaultConfig(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Component::Builder::disownDefaultConfig() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline typename Component::Factory::Reader Component::Reader::getFactory() const {
  return typename Component::Factory::Reader(_reader);
}
inline typename Component::Factory::Builder Component::Builder::getFactory() {
  return typename Component::Factory::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Component::Factory::Pipeline Component::Pipeline::getFactory() {
  return typename Component::Factory::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Component::Factory::Builder Component::Builder::initFactory() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<4>() * ::capnp::POINTERS).clear();
  return typename Component::Factory::Builder(_builder);
}
inline bool Component::Port::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Port::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Component::Port::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Component::Port::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Component::Port::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Component::Port::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Component::Port::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Component::Port::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Component::Port::Reader::hasContentType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Port::Builder::hasContentType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Component::Port::Reader::getContentType() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Component::Port::Builder::getContentType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Component::Port::Builder::setContentType( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Component::Port::Builder::initContentType(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Component::Port::Builder::adoptContentType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Component::Port::Builder::disownContentType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::mas::schema::fbp::Component::Port::PortType Component::Port::Reader::getType() const {
  return _reader.getDataField< ::mas::schema::fbp::Component::Port::PortType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::fbp::Component::Port::PortType Component::Port::Builder::getType() {
  return _builder.getDataField< ::mas::schema::fbp::Component::Port::PortType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Component::Port::Builder::setType( ::mas::schema::fbp::Component::Port::PortType value) {
  _builder.setDataField< ::mas::schema::fbp::Component::Port::PortType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::fbp::Component::Factory::Which Component::Factory::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::fbp::Component::Factory::Which Component::Factory::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Component::Factory::Reader::isNone() const {
  return which() == Component::Factory::NONE;
}
inline bool Component::Factory::Builder::isNone() {
  return which() == Component::Factory::NONE;
}
inline  ::capnp::Void Component::Factory::Reader::getNone() const {
  KJ_IREQUIRE((which() == Component::Factory::NONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Component::Factory::Builder::getNone() {
  KJ_IREQUIRE((which() == Component::Factory::NONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Component::Factory::Builder::setNone( ::capnp::Void value) {
  _builder.setDataField<Component::Factory::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Component::Factory::NONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Component::Factory::Reader::isRunnable() const {
  return which() == Component::Factory::RUNNABLE;
}
inline bool Component::Factory::Builder::isRunnable() {
  return which() == Component::Factory::RUNNABLE;
}
inline bool Component::Factory::Reader::hasRunnable() const {
  if (which() != Component::Factory::RUNNABLE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Factory::Builder::hasRunnable() {
  if (which() != Component::Factory::RUNNABLE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::fbp::Runnable::Factory::Client Component::Factory::Reader::getRunnable() const {
  KJ_IREQUIRE((which() == Component::Factory::RUNNABLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable::Factory>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Runnable::Factory::Client Component::Factory::Builder::getRunnable() {
  KJ_IREQUIRE((which() == Component::Factory::RUNNABLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable::Factory>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Component::Factory::Builder::setRunnable( ::mas::schema::fbp::Runnable::Factory::Client&& cap) {
  _builder.setDataField<Component::Factory::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Component::Factory::RUNNABLE);
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable::Factory>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Component::Factory::Builder::setRunnable( ::mas::schema::fbp::Runnable::Factory::Client& cap) {
  _builder.setDataField<Component::Factory::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Component::Factory::RUNNABLE);
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable::Factory>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), cap);
}
inline void Component::Factory::Builder::adoptRunnable(
    ::capnp::Orphan< ::mas::schema::fbp::Runnable::Factory>&& value) {
  _builder.setDataField<Component::Factory::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Component::Factory::RUNNABLE);
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable::Factory>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::fbp::Runnable::Factory> Component::Factory::Builder::disownRunnable() {
  KJ_IREQUIRE((which() == Component::Factory::RUNNABLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable::Factory>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Component::Factory::Reader::isProcess() const {
  return which() == Component::Factory::PROCESS;
}
inline bool Component::Factory::Builder::isProcess() {
  return which() == Component::Factory::PROCESS;
}
inline bool Component::Factory::Reader::hasProcess() const {
  if (which() != Component::Factory::PROCESS) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Factory::Builder::hasProcess() {
  if (which() != Component::Factory::PROCESS) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::fbp::Process::Factory::Client Component::Factory::Reader::getProcess() const {
  KJ_IREQUIRE((which() == Component::Factory::PROCESS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::Factory>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Process::Factory::Client Component::Factory::Builder::getProcess() {
  KJ_IREQUIRE((which() == Component::Factory::PROCESS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::Factory>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Component::Factory::Builder::setProcess( ::mas::schema::fbp::Process::Factory::Client&& cap) {
  _builder.setDataField<Component::Factory::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Component::Factory::PROCESS);
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::Factory>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Component::Factory::Builder::setProcess( ::mas::schema::fbp::Process::Factory::Client& cap) {
  _builder.setDataField<Component::Factory::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Component::Factory::PROCESS);
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::Factory>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), cap);
}
inline void Component::Factory::Builder::adoptProcess(
    ::capnp::Orphan< ::mas::schema::fbp::Process::Factory>&& value) {
  _builder.setDataField<Component::Factory::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Component::Factory::PROCESS);
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::Factory>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::fbp::Process::Factory> Component::Factory::Builder::disownProcess() {
  KJ_IREQUIRE((which() == Component::Factory::PROCESS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::Factory>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline Runnable::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Runnable::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Runnable::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Runnable::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Runnable::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::fbp::Runnable::Client& Runnable::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::fbp::Runnable::Client& Runnable::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Runnable::Factory::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Runnable::Factory::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Runnable::Factory::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Runnable::Factory::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Runnable::Factory::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::fbp::Runnable::Factory::Client& Runnable::Factory::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::fbp::Runnable::Factory::Client& Runnable::Factory::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Runnable::Factory::CreateResults::Reader::hasOut() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Runnable::Factory::CreateResults::Builder::hasOut() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::fbp::Runnable::Client Runnable::Factory::CreateResults::Reader::getOut() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Runnable::Client Runnable::Factory::CreateResults::Builder::getOut() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Runnable::Client Runnable::Factory::CreateResults::Pipeline::getOut() {
  return  ::mas::schema::fbp::Runnable::Client(_typeless.getPointerField(0).asCap());
}
inline void Runnable::Factory::CreateResults::Builder::setOut( ::mas::schema::fbp::Runnable::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Runnable::Factory::CreateResults::Builder::setOut( ::mas::schema::fbp::Runnable::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Runnable::Factory::CreateResults::Builder::adoptOut(
    ::capnp::Orphan< ::mas::schema::fbp::Runnable>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::fbp::Runnable> Runnable::Factory::CreateResults::Builder::disownOut() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Runnable>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Runnable::StartParams::Reader::hasPortInfosReaderSr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Runnable::StartParams::Builder::hasPortInfosReaderSr() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Reader Runnable::StartParams::Reader::getPortInfosReaderSr() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Builder Runnable::StartParams::Builder::getPortInfosReaderSr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Pipeline Runnable::StartParams::Pipeline::getPortInfosReaderSr() {
  return  ::mas::schema::persistence::SturdyRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Runnable::StartParams::Builder::setPortInfosReaderSr( ::mas::schema::persistence::SturdyRef::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Builder Runnable::StartParams::Builder::initPortInfosReaderSr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Runnable::StartParams::Builder::adoptPortInfosReaderSr(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> Runnable::StartParams::Builder::disownPortInfosReaderSr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Runnable::StartParams::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Runnable::StartParams::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Runnable::StartParams::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Runnable::StartParams::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Runnable::StartParams::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Runnable::StartParams::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Runnable::StartParams::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Runnable::StartParams::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Runnable::StartResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Runnable::StartResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Runnable::StartResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Runnable::StopResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Runnable::StopResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Runnable::StopResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Process::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Process::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Process::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Process::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Process::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::fbp::Process::Client& Process::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::fbp::Process::Client& Process::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Process::Factory::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Process::Factory::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Process::Factory::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Process::Factory::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Process::Factory::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::fbp::Process::Factory::Client& Process::Factory::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::fbp::Process::Factory::Client& Process::Factory::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Process::Factory::CreateResults::Reader::hasOut() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Process::Factory::CreateResults::Builder::hasOut() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::fbp::Process::Client Process::Factory::CreateResults::Reader::getOut() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Process::Client Process::Factory::CreateResults::Builder::getOut() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Process::Client Process::Factory::CreateResults::Pipeline::getOut() {
  return  ::mas::schema::fbp::Process::Client(_typeless.getPointerField(0).asCap());
}
inline void Process::Factory::CreateResults::Builder::setOut( ::mas::schema::fbp::Process::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Process::Factory::CreateResults::Builder::setOut( ::mas::schema::fbp::Process::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Process::Factory::CreateResults::Builder::adoptOut(
    ::capnp::Orphan< ::mas::schema::fbp::Process>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::fbp::Process> Process::Factory::CreateResults::Builder::disownOut() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Process::ConfigEntry::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Process::ConfigEntry::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Process::ConfigEntry::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Process::ConfigEntry::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Process::ConfigEntry::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Process::ConfigEntry::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Process::ConfigEntry::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Process::ConfigEntry::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Process::ConfigEntry::Reader::hasVal() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Process::ConfigEntry::Builder::hasVal() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Value::Reader Process::ConfigEntry::Reader::getVal() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Value>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Value::Builder Process::ConfigEntry::Builder::getVal() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Value>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Value::Pipeline Process::ConfigEntry::Pipeline::getVal() {
  return  ::mas::schema::common::Value::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Process::ConfigEntry::Builder::setVal( ::mas::schema::common::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Value>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Value::Builder Process::ConfigEntry::Builder::initVal() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Value>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Process::ConfigEntry::Builder::adoptVal(
    ::capnp::Orphan< ::mas::schema::common::Value>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Value> Process::ConfigEntry::Builder::disownVal() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Process::StateTransition::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Process::StateTransition::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Process::StateTransition::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Process::StateTransition::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Process::StateTransition::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::fbp::Process::StateTransition::Client& Process::StateTransition::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::fbp::Process::StateTransition::Client& Process::StateTransition::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::mas::schema::fbp::Process::State Process::StateTransition::StateChangedParams::Reader::getOld() const {
  return _reader.getDataField< ::mas::schema::fbp::Process::State>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::fbp::Process::State Process::StateTransition::StateChangedParams::Builder::getOld() {
  return _builder.getDataField< ::mas::schema::fbp::Process::State>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Process::StateTransition::StateChangedParams::Builder::setOld( ::mas::schema::fbp::Process::State value) {
  _builder.setDataField< ::mas::schema::fbp::Process::State>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::fbp::Process::State Process::StateTransition::StateChangedParams::Reader::getNew() const {
  return _reader.getDataField< ::mas::schema::fbp::Process::State>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::fbp::Process::State Process::StateTransition::StateChangedParams::Builder::getNew() {
  return _builder.getDataField< ::mas::schema::fbp::Process::State>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Process::StateTransition::StateChangedParams::Builder::setNew( ::mas::schema::fbp::Process::State value) {
  _builder.setDataField< ::mas::schema::fbp::Process::State>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Process::InPortsResults::Reader::hasPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Process::InPortsResults::Builder::hasPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader Process::InPortsResults::Reader::getPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Process::InPortsResults::Builder::getPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Process::InPortsResults::Builder::setPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Process::InPortsResults::Builder::initPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Process::InPortsResults::Builder::adoptPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> Process::InPortsResults::Builder::disownPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Process::ConnectInPortParams::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Process::ConnectInPortParams::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Process::ConnectInPortParams::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Process::ConnectInPortParams::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Process::ConnectInPortParams::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Process::ConnectInPortParams::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Process::ConnectInPortParams::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Process::ConnectInPortParams::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Process::ConnectInPortParams::Reader::hasSturdyRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Process::ConnectInPortParams::Builder::hasSturdyRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Reader Process::ConnectInPortParams::Reader::getSturdyRef() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Builder Process::ConnectInPortParams::Builder::getSturdyRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Pipeline Process::ConnectInPortParams::Pipeline::getSturdyRef() {
  return  ::mas::schema::persistence::SturdyRef::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Process::ConnectInPortParams::Builder::setSturdyRef( ::mas::schema::persistence::SturdyRef::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Builder Process::ConnectInPortParams::Builder::initSturdyRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Process::ConnectInPortParams::Builder::adoptSturdyRef(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> Process::ConnectInPortParams::Builder::disownSturdyRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Process::ConnectInPortResults::Reader::getConnected() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Process::ConnectInPortResults::Builder::getConnected() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Process::ConnectInPortResults::Builder::setConnected(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Process::OutPortsResults::Reader::hasPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Process::OutPortsResults::Builder::hasPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader Process::OutPortsResults::Reader::getPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Process::OutPortsResults::Builder::getPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Process::OutPortsResults::Builder::setPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Process::OutPortsResults::Builder::initPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Process::OutPortsResults::Builder::adoptPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> Process::OutPortsResults::Builder::disownPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Process::ConnectOutPortParams::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Process::ConnectOutPortParams::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Process::ConnectOutPortParams::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Process::ConnectOutPortParams::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Process::ConnectOutPortParams::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Process::ConnectOutPortParams::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Process::ConnectOutPortParams::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Process::ConnectOutPortParams::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Process::ConnectOutPortParams::Reader::hasSturdyRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Process::ConnectOutPortParams::Builder::hasSturdyRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Reader Process::ConnectOutPortParams::Reader::getSturdyRef() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Builder Process::ConnectOutPortParams::Builder::getSturdyRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Pipeline Process::ConnectOutPortParams::Pipeline::getSturdyRef() {
  return  ::mas::schema::persistence::SturdyRef::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Process::ConnectOutPortParams::Builder::setSturdyRef( ::mas::schema::persistence::SturdyRef::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Builder Process::ConnectOutPortParams::Builder::initSturdyRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Process::ConnectOutPortParams::Builder::adoptSturdyRef(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> Process::ConnectOutPortParams::Builder::disownSturdyRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Process::ConnectOutPortResults::Reader::getConnected() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Process::ConnectOutPortResults::Builder::getConnected() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Process::ConnectOutPortResults::Builder::setConnected(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Process::ConfigEntriesResults::Reader::hasConfig() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Process::ConfigEntriesResults::Builder::hasConfig() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>::Reader Process::ConfigEntriesResults::Reader::getConfig() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>::Builder Process::ConfigEntriesResults::Builder::getConfig() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Process::ConfigEntriesResults::Builder::setConfig( ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>::Builder Process::ConfigEntriesResults::Builder::initConfig(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Process::ConfigEntriesResults::Builder::adoptConfig(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>> Process::ConfigEntriesResults::Builder::disownConfig() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Process::ConfigEntry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Process::StateParams::Reader::hasTransitionCallback() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Process::StateParams::Builder::hasTransitionCallback() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::fbp::Process::StateTransition::Client Process::StateParams::Reader::getTransitionCallback() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::StateTransition>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Process::StateTransition::Client Process::StateParams::Builder::getTransitionCallback() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::StateTransition>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Process::StateTransition::Client Process::StateParams::Pipeline::getTransitionCallback() {
  return  ::mas::schema::fbp::Process::StateTransition::Client(_typeless.getPointerField(0).asCap());
}
inline void Process::StateParams::Builder::setTransitionCallback( ::mas::schema::fbp::Process::StateTransition::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::StateTransition>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Process::StateParams::Builder::setTransitionCallback( ::mas::schema::fbp::Process::StateTransition::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::StateTransition>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Process::StateParams::Builder::adoptTransitionCallback(
    ::capnp::Orphan< ::mas::schema::fbp::Process::StateTransition>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::StateTransition>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::fbp::Process::StateTransition> Process::StateParams::Builder::disownTransitionCallback() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Process::StateTransition>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::mas::schema::fbp::Process::State Process::StateResults::Reader::getCurrentState() const {
  return _reader.getDataField< ::mas::schema::fbp::Process::State>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::fbp::Process::State Process::StateResults::Builder::getCurrentState() {
  return _builder.getDataField< ::mas::schema::fbp::Process::State>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Process::StateResults::Builder::setCurrentState( ::mas::schema::fbp::Process::State value) {
  _builder.setDataField< ::mas::schema::fbp::Process::State>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

