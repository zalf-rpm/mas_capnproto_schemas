// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: fbp.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"
#include "persistence.capnp.h"
#include "service.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(af0a1dc4709a5ccf);
CAPNP_DECLARE_SCHEMA(9e9e5391e0c499e6);
CAPNP_DECLARE_SCHEMA(f684cae29bdc484e);
enum class Type_f684cae29bdc484e: uint16_t {
  STANDARD,
  OPEN_BRACKET,
  CLOSE_BRACKET,
};
CAPNP_DECLARE_ENUM(Type, f684cae29bdc484e);
CAPNP_DECLARE_SCHEMA(f3705fb36d44a21f);
CAPNP_DECLARE_SCHEMA(9c62c32b2ff2b1e8);
CAPNP_DECLARE_SCHEMA(a8d787cae7e0b243);
enum class CloseSemantics_a8d787cae7e0b243: uint16_t {
  FBP,
  NO,
};
CAPNP_DECLARE_ENUM(CloseSemantics, a8d787cae7e0b243);
CAPNP_DECLARE_SCHEMA(d5b512f4bcd0aa2e);
CAPNP_DECLARE_SCHEMA(e3d7a3237f175028);
CAPNP_DECLARE_SCHEMA(8bc69192f3bc97cc);
CAPNP_DECLARE_SCHEMA(c0335d99db8b2ba5);
CAPNP_DECLARE_SCHEMA(9428ea64f18c41c8);
CAPNP_DECLARE_SCHEMA(b3fe08a1bf53821a);
CAPNP_DECLARE_SCHEMA(89e521a99fcc4044);
CAPNP_DECLARE_SCHEMA(f7fec613b4a8c79f);
CAPNP_DECLARE_SCHEMA(ce9f24b8ec149524);
CAPNP_DECLARE_SCHEMA(badc988dda3d1e50);
CAPNP_DECLARE_SCHEMA(cb02dc91e18e58c9);
CAPNP_DECLARE_SCHEMA(c61c438f89d10281);
CAPNP_DECLARE_SCHEMA(92101e3b7a761333);
CAPNP_DECLARE_SCHEMA(fe6a08d5e0712c23);
CAPNP_DECLARE_SCHEMA(e607c9dd64da04c4);
CAPNP_DECLARE_SCHEMA(b135ffc9ccc9eca6);
CAPNP_DECLARE_SCHEMA(be611d34e368e109);
CAPNP_DECLARE_SCHEMA(b47b53679e985c7e);
CAPNP_DECLARE_SCHEMA(d23f817e914373d8);
CAPNP_DECLARE_SCHEMA(f37401d21f8d97bb);
CAPNP_DECLARE_SCHEMA(b49836b545583add);
CAPNP_DECLARE_SCHEMA(c0fc6e5a3fcb3206);
CAPNP_DECLARE_SCHEMA(95d8ad01c1113d9c);
CAPNP_DECLARE_SCHEMA(cc079ad60f1363b7);
CAPNP_DECLARE_SCHEMA(d0cd6d829b810229);
CAPNP_DECLARE_SCHEMA(9576b9a98d58fba2);
CAPNP_DECLARE_SCHEMA(de5975c83de2b10c);
CAPNP_DECLARE_SCHEMA(ece0efa9a922d4a8);
CAPNP_DECLARE_SCHEMA(8a4d34c4b5eb1545);
CAPNP_DECLARE_SCHEMA(d717ff7d6815a6b0);
CAPNP_DECLARE_SCHEMA(cb17668f2d39c70f);
CAPNP_DECLARE_SCHEMA(deb75f08b2540532);
CAPNP_DECLARE_SCHEMA(bb18da359652a59c);
CAPNP_DECLARE_SCHEMA(e6ba083a247c91ee);
CAPNP_DECLARE_SCHEMA(cbf00f9ba87ee17e);
CAPNP_DECLARE_SCHEMA(c6976ac75246b450);
enum class ComponentType_c6976ac75246b450: uint16_t {
  STANDARD,
  IIP,
  SUBFLOW,
};
CAPNP_DECLARE_ENUM(ComponentType, c6976ac75246b450);
CAPNP_DECLARE_SCHEMA(c28d2829add1cd72);
CAPNP_DECLARE_SCHEMA(f58d7a7318a06224);
enum class PortType_f58d7a7318a06224: uint16_t {
  STANDARD,
};
CAPNP_DECLARE_ENUM(PortType, f58d7a7318a06224);
CAPNP_DECLARE_SCHEMA(f30610cf0ed94a2f);
enum class ContentType_f30610cf0ed94a2f: uint16_t {
  STRUCTURED_TEXT,
};
CAPNP_DECLARE_ENUM(ContentType, f30610cf0ed94a2f);
CAPNP_DECLARE_SCHEMA(fd32766446625ad7);
CAPNP_DECLARE_SCHEMA(eda3c43711165718);
CAPNP_DECLARE_SCHEMA(8fe5f30dda656838);
CAPNP_DECLARE_SCHEMA(a99399396807d8c5);
CAPNP_DECLARE_SCHEMA(973c5bebb677e106);
CAPNP_DECLARE_SCHEMA(816f3a8598cfd055);
CAPNP_DECLARE_SCHEMA(dd2951b8efe293ae);
CAPNP_DECLARE_SCHEMA(b4315bf70ae26e84);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace fbp {

struct IP {
  IP() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct KV;
  typedef ::capnp::schemas::Type_f684cae29bdc484e Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(af0a1dc4709a5ccf, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IP::KV {
  KV() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e9e5391e0c499e6, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IIP {
  IIP() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f3705fb36d44a21f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename V = ::capnp::AnyPointer>
struct Channel {
  Channel() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  typedef ::capnp::schemas::CloseSemantics_a8d787cae7e0b243 CloseSemantics;

  struct Msg;
  struct StartupInfo;
  struct ChanReader;
  struct ChanWriter;
  struct SetBufferSizeParams;
  struct SetBufferSizeResults;
  struct ReaderParams;
  struct ReaderResults;
  struct WriterParams;
  struct WriterResults;
  struct EndpointsParams;
  struct EndpointsResults;
  struct SetAutoCloseSemanticsParams;
  struct SetAutoCloseSemanticsResults;
  struct CloseParams;
  struct CloseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9c62c32b2ff2b1e8)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
struct Channel<V>::Msg {
  Msg() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    VALUE,
    DONE,
    NO_MSG,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d5b512f4bcd0aa2e, 1, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::StartupInfo {
  StartupInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3d7a3237f175028, 2, 3)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader {
  ChanReader() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ReadParams;
  struct CloseParams;
  struct CloseResults;
  struct ReadIfMsgParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(8bc69192f3bc97cc)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
struct Channel<V>::ChanReader::ReadParams {
  ReadParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0335d99db8b2ba5, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader::CloseParams {
  CloseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9428ea64f18c41c8, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader::CloseResults {
  CloseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3fe08a1bf53821a, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader::ReadIfMsgParams {
  ReadIfMsgParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(89e521a99fcc4044, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter {
  ChanWriter() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct WriteResults;
  struct CloseParams;
  struct CloseResults;
  struct WriteIfSpaceResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f7fec613b4a8c79f)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
struct Channel<V>::ChanWriter::WriteResults {
  WriteResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce9f24b8ec149524, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter::CloseParams {
  CloseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(badc988dda3d1e50, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter::CloseResults {
  CloseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb02dc91e18e58c9, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter::WriteIfSpaceResults {
  WriteIfSpaceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c61c438f89d10281, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetBufferSizeParams {
  SetBufferSizeParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(92101e3b7a761333, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetBufferSizeResults {
  SetBufferSizeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe6a08d5e0712c23, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ReaderParams {
  ReaderParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e607c9dd64da04c4, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ReaderResults {
  ReaderResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b135ffc9ccc9eca6, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::WriterParams {
  WriterParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(be611d34e368e109, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::WriterResults {
  WriterResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b47b53679e985c7e, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::EndpointsParams {
  EndpointsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d23f817e914373d8, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::EndpointsResults {
  EndpointsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f37401d21f8d97bb, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetAutoCloseSemanticsParams {
  SetAutoCloseSemanticsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b49836b545583add, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetAutoCloseSemanticsResults {
  SetAutoCloseSemanticsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0fc6e5a3fcb3206, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::CloseParams {
  CloseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(95d8ad01c1113d9c, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::CloseResults {
  CloseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cc079ad60f1363b7, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct StartChannelsService {
  StartChannelsService() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Params;
  struct StartResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(d0cd6d829b810229)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct StartChannelsService::Params {
  Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9576b9a98d58fba2, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct StartChannelsService::StartResults {
  StartResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(de5975c83de2b10c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PortInfos {
  PortInfos() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct NameAndSR;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ece0efa9a922d4a8, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PortInfos::NameAndSR {
  NameAndSR() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SR,
    SRS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8a4d34c4b5eb1545, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Component {
  Component() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Runnable;
  typedef ::capnp::schemas::ComponentType_c6976ac75246b450 ComponentType;

  struct Port;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d717ff7d6815a6b0, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Component::Runnable {
  Runnable() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct StartParams;
  struct StartResults;
  struct StopParams;
  struct StopResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(cb17668f2d39c70f)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Component::Runnable::StartParams {
  StartParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(deb75f08b2540532, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Component::Runnable::StartResults {
  StartResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb18da359652a59c, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Component::Runnable::StopParams {
  StopParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6ba083a247c91ee, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Component::Runnable::StopResults {
  StopResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cbf00f9ba87ee17e, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Component::Port {
  Port() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::PortType_f58d7a7318a06224 PortType;

  typedef ::capnp::schemas::ContentType_f30610cf0ed94a2f ContentType;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c28d2829add1cd72, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentService {
  ComponentService() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Entry;
  struct ListParams;
  struct ListResults;
  struct ComponentParams;
  struct ComponentResults;
  struct CategoriesParams;
  struct CategoriesResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(fd32766446625ad7)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct ComponentService::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eda3c43711165718, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentService::ListParams {
  ListParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8fe5f30dda656838, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentService::ListResults {
  ListResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a99399396807d8c5, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentService::ComponentParams {
  ComponentParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(973c5bebb677e106, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentService::ComponentResults {
  ComponentResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(816f3a8598cfd055, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentService::CategoriesParams {
  CategoriesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd2951b8efe293ae, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentService::CategoriesResults {
  CategoriesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b4315bf70ae26e84, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class IP::Reader {
public:
  typedef IP Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAttributes() const;
  inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Reader getAttributes() const;

  inline bool hasContent() const;
  inline ::capnp::AnyPointer::Reader getContent() const;

  inline  ::mas::schema::fbp::IP::Type getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IP::Builder {
public:
  typedef IP Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAttributes();
  inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Builder getAttributes();
  inline void setAttributes( ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Builder initAttributes(unsigned int size);
  inline void adoptAttributes(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>> disownAttributes();

  inline bool hasContent();
  inline ::capnp::AnyPointer::Builder getContent();
  inline ::capnp::AnyPointer::Builder initContent();

  inline  ::mas::schema::fbp::IP::Type getType();
  inline void setType( ::mas::schema::fbp::IP::Type value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IP::Pipeline {
public:
  typedef IP Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IP::KV::Reader {
public:
  typedef KV Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline bool hasDesc() const;
  inline  ::capnp::Text::Reader getDesc() const;

  inline bool hasValue() const;
  inline ::capnp::AnyPointer::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IP::KV::Builder {
public:
  typedef KV Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline bool hasDesc();
  inline  ::capnp::Text::Builder getDesc();
  inline void setDesc( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDesc(unsigned int size);
  inline void adoptDesc(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDesc();

  inline bool hasValue();
  inline ::capnp::AnyPointer::Builder getValue();
  inline ::capnp::AnyPointer::Builder initValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IP::KV::Pipeline {
public:
  typedef KV Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IIP::Reader {
public:
  typedef IIP Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContent() const;
  inline ::capnp::AnyPointer::Reader getContent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IIP::Builder {
public:
  typedef IIP Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContent();
  inline ::capnp::AnyPointer::Builder getContent();
  inline ::capnp::AnyPointer::Builder initContent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IIP::Pipeline {
public:
  typedef IIP Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class Channel<V>::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Channel Calls;
  typedef Channel Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::Client asGeneric() {
    return castAs<Channel<V2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults>) setBufferSizeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ReaderParams, typename  ::mas::schema::fbp::Channel<V>::ReaderResults>) readerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::WriterParams, typename  ::mas::schema::fbp::Channel<V>::WriterResults>) writerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::EndpointsParams, typename  ::mas::schema::fbp::Channel<V>::EndpointsResults>) endpointsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults>) setAutoCloseSemanticsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::CloseParams, typename  ::mas::schema::fbp::Channel<V>::CloseResults>) closeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class Channel<V>::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Channel Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams SetBufferSizeParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults SetBufferSizeResults;
  typedef ::capnp::CallContext<SetBufferSizeParams, SetBufferSizeResults> SetBufferSizeContext;
  virtual ::kj::Promise<void> setBufferSize(SetBufferSizeContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ReaderParams ReaderParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::ReaderResults ReaderResults;
  typedef ::capnp::CallContext<ReaderParams, ReaderResults> ReaderContext;
  virtual ::kj::Promise<void> reader(ReaderContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::WriterParams WriterParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::WriterResults WriterResults;
  typedef ::capnp::CallContext<WriterParams, WriterResults> WriterContext;
  virtual ::kj::Promise<void> writer(WriterContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::EndpointsParams EndpointsParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::EndpointsResults EndpointsResults;
  typedef ::capnp::CallContext<EndpointsParams, EndpointsResults> EndpointsContext;
  virtual ::kj::Promise<void> endpoints(EndpointsContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams SetAutoCloseSemanticsParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults SetAutoCloseSemanticsResults;
  typedef ::capnp::CallContext<SetAutoCloseSemanticsParams, SetAutoCloseSemanticsResults> SetAutoCloseSemanticsContext;
  virtual ::kj::Promise<void> setAutoCloseSemantics(SetAutoCloseSemanticsContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::CloseParams CloseParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::CloseResults CloseResults;
  typedef ::capnp::CallContext<CloseParams, CloseResults> CloseContext;
  virtual ::kj::Promise<void> close(CloseContext context);

  inline typename  ::mas::schema::fbp::Channel<V>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::Channel<V>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::Msg::Reader {
public:
  typedef Msg Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::Msg::Reader asChannelGeneric() {
    return typename Channel<V2>::Msg::Reader(_reader);
  }

  inline Which which() const;
  inline bool isValue() const;
  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<V> getValue() const;

  inline bool isDone() const;
  inline  ::capnp::Void getDone() const;

  inline bool isNoMsg() const;
  inline  ::capnp::Void getNoMsg() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::Msg::Builder {
public:
  typedef Msg Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::Msg::Builder asChannelGeneric() {
    return typename Channel<V2>::Msg::Builder(_builder);
  }

  inline Which which();
  inline bool isValue();
  inline bool hasValue();
  inline  ::capnp::BuilderFor<V> getValue();
  inline void setValue( ::capnp::ReaderFor<V> value);
  inline  ::capnp::BuilderFor<V> initValue();
  inline  ::capnp::BuilderFor<V> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<V>&& value);
  inline ::capnp::Orphan<V> disownValue();

  inline bool isDone();
  inline  ::capnp::Void getDone();
  inline void setDone( ::capnp::Void value = ::capnp::VOID);

  inline bool isNoMsg();
  inline  ::capnp::Void getNoMsg();
  inline void setNoMsg( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::Msg::Pipeline {
public:
  typedef Msg Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::StartupInfo::Reader {
public:
  typedef StartupInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::StartupInfo::Reader asChannelGeneric() {
    return typename Channel<V2>::StartupInfo::Reader(_reader);
  }

  inline  ::uint64_t getBufferSize() const;

  inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics getCloseSemantics() const;

  inline bool hasChannelSR() const;
  inline  ::capnp::Text::Reader getChannelSR() const;

  inline bool hasReaderSRs() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getReaderSRs() const;

  inline bool hasWriterSRs() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getWriterSRs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::StartupInfo::Builder {
public:
  typedef StartupInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::StartupInfo::Builder asChannelGeneric() {
    return typename Channel<V2>::StartupInfo::Builder(_builder);
  }

  inline  ::uint64_t getBufferSize();
  inline void setBufferSize( ::uint64_t value);

  inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics getCloseSemantics();
  inline void setCloseSemantics(typename  ::mas::schema::fbp::Channel<V>::CloseSemantics value);

  inline bool hasChannelSR();
  inline  ::capnp::Text::Builder getChannelSR();
  inline void setChannelSR( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initChannelSR(unsigned int size);
  inline void adoptChannelSR(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownChannelSR();

  inline bool hasReaderSRs();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getReaderSRs();
  inline void setReaderSRs( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setReaderSRs(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initReaderSRs(unsigned int size);
  inline void adoptReaderSRs(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownReaderSRs();

  inline bool hasWriterSRs();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getWriterSRs();
  inline void setWriterSRs( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setWriterSRs(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initWriterSRs(unsigned int size);
  inline void adoptWriterSRs(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownWriterSRs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::StartupInfo::Pipeline {
public:
  typedef StartupInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef ChanReader Calls;
  typedef ChanReader Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Client asChannelGeneric() {
    return castAs<typename Channel<V2>::ChanReader>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg>) readRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults>) closeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg>) readIfMsgRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class Channel<V>::ChanReader::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef ChanReader Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams ReadParams;
  typedef ::capnp::CallContext<ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg> ReadContext;
  virtual ::kj::Promise<void> read(ReadContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams CloseParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults CloseResults;
  typedef ::capnp::CallContext<CloseParams, CloseResults> CloseContext;
  virtual ::kj::Promise<void> close(CloseContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams ReadIfMsgParams;
  typedef ::capnp::CallContext<ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg> ReadIfMsgContext;
  virtual ::kj::Promise<void> readIfMsg(ReadIfMsgContext context);

  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::mas::schema::fbp::Channel<V>::ChanReader>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::ReadParams::Reader {
public:
  typedef ReadParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::ReadParams::Builder {
public:
  typedef ReadParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::ReadParams::Pipeline {
public:
  typedef ReadParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::CloseParams::Reader {
public:
  typedef CloseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::CloseParams::Builder {
public:
  typedef CloseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::CloseParams::Pipeline {
public:
  typedef CloseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::CloseResults::Reader {
public:
  typedef CloseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::CloseResults::Builder {
public:
  typedef CloseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::CloseResults::Pipeline {
public:
  typedef CloseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::ReadIfMsgParams::Reader {
public:
  typedef ReadIfMsgParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::ReadIfMsgParams::Builder {
public:
  typedef ReadIfMsgParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::ReadIfMsgParams::Pipeline {
public:
  typedef ReadIfMsgParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef ChanWriter Calls;
  typedef ChanWriter Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Client asChannelGeneric() {
    return castAs<typename Channel<V2>::ChanWriter>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults>) writeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults>) closeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults>) writeIfSpaceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class Channel<V>::ChanWriter::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef ChanWriter Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults WriteResults;
  typedef ::capnp::CallContext<typename  ::mas::schema::fbp::Channel<V>::Msg, WriteResults> WriteContext;
  virtual ::kj::Promise<void> write(WriteContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams CloseParams;
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults CloseResults;
  typedef ::capnp::CallContext<CloseParams, CloseResults> CloseContext;
  virtual ::kj::Promise<void> close(CloseContext context);
  typedef typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults WriteIfSpaceResults;
  typedef ::capnp::CallContext<typename  ::mas::schema::fbp::Channel<V>::Msg, WriteIfSpaceResults> WriteIfSpaceContext;
  virtual ::kj::Promise<void> writeIfSpace(WriteIfSpaceContext context);

  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::WriteResults::Reader {
public:
  typedef WriteResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::WriteResults::Builder {
public:
  typedef WriteResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::WriteResults::Pipeline {
public:
  typedef WriteResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::CloseParams::Reader {
public:
  typedef CloseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::CloseParams::Builder {
public:
  typedef CloseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::CloseParams::Pipeline {
public:
  typedef CloseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::CloseResults::Reader {
public:
  typedef CloseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::CloseResults::Builder {
public:
  typedef CloseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::CloseResults::Pipeline {
public:
  typedef CloseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::WriteIfSpaceResults::Reader {
public:
  typedef WriteIfSpaceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::WriteIfSpaceResults::Builder {
public:
  typedef WriteIfSpaceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::WriteIfSpaceResults::Pipeline {
public:
  typedef WriteIfSpaceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetBufferSizeParams::Reader {
public:
  typedef SetBufferSizeParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeParams::Reader asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeParams::Reader(_reader);
  }

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetBufferSizeParams::Builder {
public:
  typedef SetBufferSizeParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeParams::Builder asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeParams::Builder(_builder);
  }

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetBufferSizeParams::Pipeline {
public:
  typedef SetBufferSizeParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetBufferSizeResults::Reader {
public:
  typedef SetBufferSizeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeResults::Reader asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetBufferSizeResults::Builder {
public:
  typedef SetBufferSizeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeResults::Builder asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetBufferSizeResults::Pipeline {
public:
  typedef SetBufferSizeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ReaderParams::Reader {
public:
  typedef ReaderParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderParams::Reader asChannelGeneric() {
    return typename Channel<V2>::ReaderParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ReaderParams::Builder {
public:
  typedef ReaderParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderParams::Builder asChannelGeneric() {
    return typename Channel<V2>::ReaderParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ReaderParams::Pipeline {
public:
  typedef ReaderParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ReaderResults::Reader {
public:
  typedef ReaderResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderResults::Reader asChannelGeneric() {
    return typename Channel<V2>::ReaderResults::Reader(_reader);
  }

  inline bool hasR() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ReaderResults::Builder {
public:
  typedef ReaderResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderResults::Builder asChannelGeneric() {
    return typename Channel<V2>::ReaderResults::Builder(_builder);
  }

  inline bool hasR();
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR();
  inline void setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client&& value);
  inline void setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& value);
  inline void adoptR(::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader> disownR();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ReaderResults::Pipeline {
public:
  typedef ReaderResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::WriterParams::Reader {
public:
  typedef WriterParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterParams::Reader asChannelGeneric() {
    return typename Channel<V2>::WriterParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::WriterParams::Builder {
public:
  typedef WriterParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterParams::Builder asChannelGeneric() {
    return typename Channel<V2>::WriterParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::WriterParams::Pipeline {
public:
  typedef WriterParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::WriterResults::Reader {
public:
  typedef WriterResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterResults::Reader asChannelGeneric() {
    return typename Channel<V2>::WriterResults::Reader(_reader);
  }

  inline bool hasW() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::WriterResults::Builder {
public:
  typedef WriterResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterResults::Builder asChannelGeneric() {
    return typename Channel<V2>::WriterResults::Builder(_builder);
  }

  inline bool hasW();
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW();
  inline void setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client&& value);
  inline void setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& value);
  inline void adoptW(::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter> disownW();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::WriterResults::Pipeline {
public:
  typedef WriterResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::EndpointsParams::Reader {
public:
  typedef EndpointsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsParams::Reader asChannelGeneric() {
    return typename Channel<V2>::EndpointsParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::EndpointsParams::Builder {
public:
  typedef EndpointsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsParams::Builder asChannelGeneric() {
    return typename Channel<V2>::EndpointsParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::EndpointsParams::Pipeline {
public:
  typedef EndpointsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::EndpointsResults::Reader {
public:
  typedef EndpointsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsResults::Reader asChannelGeneric() {
    return typename Channel<V2>::EndpointsResults::Reader(_reader);
  }

  inline bool hasR() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR() const;
#endif  // !CAPNP_LITE

  inline bool hasW() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::EndpointsResults::Builder {
public:
  typedef EndpointsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsResults::Builder asChannelGeneric() {
    return typename Channel<V2>::EndpointsResults::Builder(_builder);
  }

  inline bool hasR();
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR();
  inline void setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client&& value);
  inline void setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& value);
  inline void adoptR(::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader> disownR();
#endif  // !CAPNP_LITE

  inline bool hasW();
#if !CAPNP_LITE
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW();
  inline void setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client&& value);
  inline void setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& value);
  inline void adoptW(::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter> disownW();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::EndpointsResults::Pipeline {
public:
  typedef EndpointsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client getR();
  inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client getW();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetAutoCloseSemanticsParams::Reader {
public:
  typedef SetAutoCloseSemanticsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsParams::Reader asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsParams::Reader(_reader);
  }

  inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics getCs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetAutoCloseSemanticsParams::Builder {
public:
  typedef SetAutoCloseSemanticsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsParams::Builder asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsParams::Builder(_builder);
  }

  inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics getCs();
  inline void setCs(typename  ::mas::schema::fbp::Channel<V>::CloseSemantics value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetAutoCloseSemanticsParams::Pipeline {
public:
  typedef SetAutoCloseSemanticsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetAutoCloseSemanticsResults::Reader {
public:
  typedef SetAutoCloseSemanticsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsResults::Reader asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetAutoCloseSemanticsResults::Builder {
public:
  typedef SetAutoCloseSemanticsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsResults::Builder asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetAutoCloseSemanticsResults::Pipeline {
public:
  typedef SetAutoCloseSemanticsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::CloseParams::Reader {
public:
  typedef CloseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseParams::Reader asChannelGeneric() {
    return typename Channel<V2>::CloseParams::Reader(_reader);
  }

  inline bool getWaitForEmptyBuffer() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::CloseParams::Builder {
public:
  typedef CloseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseParams::Builder asChannelGeneric() {
    return typename Channel<V2>::CloseParams::Builder(_builder);
  }

  inline bool getWaitForEmptyBuffer();
  inline void setWaitForEmptyBuffer(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::CloseParams::Pipeline {
public:
  typedef CloseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::CloseResults::Reader {
public:
  typedef CloseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseResults::Reader asChannelGeneric() {
    return typename Channel<V2>::CloseResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::CloseResults::Builder {
public:
  typedef CloseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseResults::Builder asChannelGeneric() {
    return typename Channel<V2>::CloseResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::CloseResults::Pipeline {
public:
  typedef CloseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class StartChannelsService::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef StartChannelsService Calls;
  typedef StartChannelsService Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::fbp::StartChannelsService::Params,  ::mas::schema::fbp::StartChannelsService::StartResults> startRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class StartChannelsService::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef StartChannelsService Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::fbp::StartChannelsService::StartResults StartResults;
  typedef ::capnp::CallContext< ::mas::schema::fbp::StartChannelsService::Params, StartResults> StartContext;
  virtual ::kj::Promise<void> start(StartContext context);

  inline  ::mas::schema::fbp::StartChannelsService::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::StartChannelsService>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class StartChannelsService::Params::Reader {
public:
  typedef Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint16_t getNoOfChannels() const;

  inline  ::uint16_t getNoOfReaders() const;

  inline  ::uint16_t getNoOfWriters() const;

  inline bool hasReaderSrts() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getReaderSrts() const;

  inline bool hasWriterSrts() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getWriterSrts() const;

  inline  ::uint16_t getBufferSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StartChannelsService::Params::Builder {
public:
  typedef Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint16_t getNoOfChannels();
  inline void setNoOfChannels( ::uint16_t value);

  inline  ::uint16_t getNoOfReaders();
  inline void setNoOfReaders( ::uint16_t value);

  inline  ::uint16_t getNoOfWriters();
  inline void setNoOfWriters( ::uint16_t value);

  inline bool hasReaderSrts();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getReaderSrts();
  inline void setReaderSrts( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setReaderSrts(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initReaderSrts(unsigned int size);
  inline void adoptReaderSrts(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownReaderSrts();

  inline bool hasWriterSrts();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getWriterSrts();
  inline void setWriterSrts( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setWriterSrts(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initWriterSrts(unsigned int size);
  inline void adoptWriterSrts(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownWriterSrts();

  inline  ::uint16_t getBufferSize();
  inline void setBufferSize( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StartChannelsService::Params::Pipeline {
public:
  typedef Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StartChannelsService::StartResults::Reader {
public:
  typedef StartResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStartupInfos() const;
  inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Reader getStartupInfos() const;

  inline bool hasStop() const;
#if !CAPNP_LITE
  inline  ::mas::schema::service::Stoppable::Client getStop() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StartChannelsService::StartResults::Builder {
public:
  typedef StartResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStartupInfos();
  inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Builder getStartupInfos();
  inline void setStartupInfos( ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Builder initStartupInfos(unsigned int size);
  inline void adoptStartupInfos(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>> disownStartupInfos();

  inline bool hasStop();
#if !CAPNP_LITE
  inline  ::mas::schema::service::Stoppable::Client getStop();
  inline void setStop( ::mas::schema::service::Stoppable::Client&& value);
  inline void setStop( ::mas::schema::service::Stoppable::Client& value);
  inline void adoptStop(::capnp::Orphan< ::mas::schema::service::Stoppable>&& value);
  inline ::capnp::Orphan< ::mas::schema::service::Stoppable> disownStop();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StartChannelsService::StartResults::Pipeline {
public:
  typedef StartResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::service::Stoppable::Client getStop();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PortInfos::Reader {
public:
  typedef PortInfos Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader getInPorts() const;

  inline bool hasOutPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader getOutPorts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PortInfos::Builder {
public:
  typedef PortInfos Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInPorts();
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder getInPorts();
  inline void setInPorts( ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder initInPorts(unsigned int size);
  inline void adoptInPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>> disownInPorts();

  inline bool hasOutPorts();
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder getOutPorts();
  inline void setOutPorts( ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder initOutPorts(unsigned int size);
  inline void adoptOutPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>> disownOutPorts();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PortInfos::Pipeline {
public:
  typedef PortInfos Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PortInfos::NameAndSR::Reader {
public:
  typedef NameAndSR Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool isSr() const;
  inline bool hasSr() const;
  inline  ::capnp::Text::Reader getSr() const;

  inline bool isSrs() const;
  inline bool hasSrs() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getSrs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PortInfos::NameAndSR::Builder {
public:
  typedef NameAndSR Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool isSr();
  inline bool hasSr();
  inline  ::capnp::Text::Builder getSr();
  inline void setSr( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSr(unsigned int size);
  inline void adoptSr(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSr();

  inline bool isSrs();
  inline bool hasSrs();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getSrs();
  inline void setSrs( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setSrs(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initSrs(unsigned int size);
  inline void adoptSrs(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownSrs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PortInfos::NameAndSR::Pipeline {
public:
  typedef NameAndSR Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Component::Reader {
public:
  typedef Component Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInfo() const;
  inline  ::mas::schema::common::IdInformation::Reader getInfo() const;

  inline  ::mas::schema::fbp::Component::ComponentType getType() const;

  inline bool hasInPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader getInPorts() const;

  inline bool hasOutPorts() const;
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader getOutPorts() const;

  inline bool hasRun() const;
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Component::Runnable::Client getRun() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Component::Builder {
public:
  typedef Component Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInfo();
  inline  ::mas::schema::common::IdInformation::Builder getInfo();
  inline void setInfo( ::mas::schema::common::IdInformation::Reader value);
  inline  ::mas::schema::common::IdInformation::Builder initInfo();
  inline void adoptInfo(::capnp::Orphan< ::mas::schema::common::IdInformation>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::IdInformation> disownInfo();

  inline  ::mas::schema::fbp::Component::ComponentType getType();
  inline void setType( ::mas::schema::fbp::Component::ComponentType value);

  inline bool hasInPorts();
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder getInPorts();
  inline void setInPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder initInPorts(unsigned int size);
  inline void adoptInPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> disownInPorts();

  inline bool hasOutPorts();
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder getOutPorts();
  inline void setOutPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder initOutPorts(unsigned int size);
  inline void adoptOutPorts(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> disownOutPorts();

  inline bool hasRun();
#if !CAPNP_LITE
  inline  ::mas::schema::fbp::Component::Runnable::Client getRun();
  inline void setRun( ::mas::schema::fbp::Component::Runnable::Client&& value);
  inline void setRun( ::mas::schema::fbp::Component::Runnable::Client& value);
  inline void adoptRun(::capnp::Orphan< ::mas::schema::fbp::Component::Runnable>&& value);
  inline ::capnp::Orphan< ::mas::schema::fbp::Component::Runnable> disownRun();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Component::Pipeline {
public:
  typedef Component Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::IdInformation::Pipeline getInfo();
  inline  ::mas::schema::fbp::Component::Runnable::Client getRun();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Component::Runnable::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Runnable Calls;
  typedef Runnable Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::fbp::Component::Runnable::StartParams,  ::mas::schema::fbp::Component::Runnable::StartResults> startRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::Component::Runnable::StopParams,  ::mas::schema::fbp::Component::Runnable::StopResults> stopRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Component::Runnable::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Runnable Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::fbp::Component::Runnable::StartParams StartParams;
  typedef  ::mas::schema::fbp::Component::Runnable::StartResults StartResults;
  typedef ::capnp::CallContext<StartParams, StartResults> StartContext;
  virtual ::kj::Promise<void> start(StartContext context);
  typedef  ::mas::schema::fbp::Component::Runnable::StopParams StopParams;
  typedef  ::mas::schema::fbp::Component::Runnable::StopResults StopResults;
  typedef ::capnp::CallContext<StopParams, StopResults> StopContext;
  virtual ::kj::Promise<void> stop(StopContext context);

  inline  ::mas::schema::fbp::Component::Runnable::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::Component::Runnable>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Component::Runnable::StartParams::Reader {
public:
  typedef StartParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPortInfosReaderSr() const;
  inline  ::capnp::Text::Reader getPortInfosReaderSr() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Component::Runnable::StartParams::Builder {
public:
  typedef StartParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPortInfosReaderSr();
  inline  ::capnp::Text::Builder getPortInfosReaderSr();
  inline void setPortInfosReaderSr( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPortInfosReaderSr(unsigned int size);
  inline void adoptPortInfosReaderSr(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPortInfosReaderSr();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Component::Runnable::StartParams::Pipeline {
public:
  typedef StartParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Component::Runnable::StartResults::Reader {
public:
  typedef StartResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Component::Runnable::StartResults::Builder {
public:
  typedef StartResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Component::Runnable::StartResults::Pipeline {
public:
  typedef StartResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Component::Runnable::StopParams::Reader {
public:
  typedef StopParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Component::Runnable::StopParams::Builder {
public:
  typedef StopParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Component::Runnable::StopParams::Pipeline {
public:
  typedef StopParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Component::Runnable::StopResults::Reader {
public:
  typedef StopResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Component::Runnable::StopResults::Builder {
public:
  typedef StopResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Component::Runnable::StopResults::Pipeline {
public:
  typedef StopResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Component::Port::Reader {
public:
  typedef Port Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasContentType() const;
  inline  ::capnp::Text::Reader getContentType() const;

  inline  ::mas::schema::fbp::Component::Port::PortType getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Component::Port::Builder {
public:
  typedef Port Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasContentType();
  inline  ::capnp::Text::Builder getContentType();
  inline void setContentType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initContentType(unsigned int size);
  inline void adoptContentType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownContentType();

  inline  ::mas::schema::fbp::Component::Port::PortType getType();
  inline void setType( ::mas::schema::fbp::Component::Port::PortType value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Component::Port::Pipeline {
public:
  typedef Port Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class ComponentService::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef ComponentService Calls;
  typedef ComponentService Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::fbp::ComponentService::ListParams,  ::mas::schema::fbp::ComponentService::ListResults> listRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::ComponentService::ComponentParams,  ::mas::schema::fbp::ComponentService::ComponentResults> componentRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::fbp::ComponentService::CategoriesParams,  ::mas::schema::fbp::ComponentService::CategoriesResults> categoriesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class ComponentService::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef ComponentService Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::fbp::ComponentService::ListParams ListParams;
  typedef  ::mas::schema::fbp::ComponentService::ListResults ListResults;
  typedef ::capnp::CallContext<ListParams, ListResults> ListContext;
  virtual ::kj::Promise<void> list(ListContext context);
  typedef  ::mas::schema::fbp::ComponentService::ComponentParams ComponentParams;
  typedef  ::mas::schema::fbp::ComponentService::ComponentResults ComponentResults;
  typedef ::capnp::CallContext<ComponentParams, ComponentResults> ComponentContext;
  virtual ::kj::Promise<void> component(ComponentContext context);
  typedef  ::mas::schema::fbp::ComponentService::CategoriesParams CategoriesParams;
  typedef  ::mas::schema::fbp::ComponentService::CategoriesResults CategoriesResults;
  typedef ::capnp::CallContext<CategoriesParams, CategoriesResults> CategoriesContext;
  virtual ::kj::Promise<void> categories(CategoriesContext context);

  inline  ::mas::schema::fbp::ComponentService::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::fbp::ComponentService>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class ComponentService::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCategoryId() const;
  inline  ::capnp::Text::Reader getCategoryId() const;

  inline bool hasComponent() const;
  inline  ::mas::schema::fbp::Component::Reader getComponent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentService::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCategoryId();
  inline  ::capnp::Text::Builder getCategoryId();
  inline void setCategoryId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCategoryId(unsigned int size);
  inline void adoptCategoryId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCategoryId();

  inline bool hasComponent();
  inline  ::mas::schema::fbp::Component::Builder getComponent();
  inline void setComponent( ::mas::schema::fbp::Component::Reader value);
  inline  ::mas::schema::fbp::Component::Builder initComponent();
  inline void adoptComponent(::capnp::Orphan< ::mas::schema::fbp::Component>&& value);
  inline ::capnp::Orphan< ::mas::schema::fbp::Component> disownComponent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentService::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::fbp::Component::Pipeline getComponent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentService::ListParams::Reader {
public:
  typedef ListParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentService::ListParams::Builder {
public:
  typedef ListParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentService::ListParams::Pipeline {
public:
  typedef ListParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentService::ListResults::Reader {
public:
  typedef ListResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEntries() const;
  inline  ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentService::ListResults::Builder {
public:
  typedef ListResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntries();
  inline  ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries( ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentService::ListResults::Pipeline {
public:
  typedef ListResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentService::ComponentParams::Reader {
public:
  typedef ComponentParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentService::ComponentParams::Builder {
public:
  typedef ComponentParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentService::ComponentParams::Pipeline {
public:
  typedef ComponentParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentService::ComponentResults::Reader {
public:
  typedef ComponentResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasComp() const;
  inline  ::mas::schema::fbp::Component::Reader getComp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentService::ComponentResults::Builder {
public:
  typedef ComponentResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasComp();
  inline  ::mas::schema::fbp::Component::Builder getComp();
  inline void setComp( ::mas::schema::fbp::Component::Reader value);
  inline  ::mas::schema::fbp::Component::Builder initComp();
  inline void adoptComp(::capnp::Orphan< ::mas::schema::fbp::Component>&& value);
  inline ::capnp::Orphan< ::mas::schema::fbp::Component> disownComp();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentService::ComponentResults::Pipeline {
public:
  typedef ComponentResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::fbp::Component::Pipeline getComp();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentService::CategoriesParams::Reader {
public:
  typedef CategoriesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentService::CategoriesParams::Builder {
public:
  typedef CategoriesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentService::CategoriesParams::Pipeline {
public:
  typedef CategoriesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentService::CategoriesResults::Reader {
public:
  typedef CategoriesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCategories() const;
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader getCategories() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentService::CategoriesResults::Builder {
public:
  typedef CategoriesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCategories();
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder getCategories();
  inline void setCategories( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder initCategories(unsigned int size);
  inline void adoptCategories(::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> disownCategories();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentService::CategoriesResults::Pipeline {
public:
  typedef CategoriesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool IP::Reader::hasAttributes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IP::Builder::hasAttributes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Reader IP::Reader::getAttributes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Builder IP::Builder::getAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IP::Builder::setAttributes( ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>::Builder IP::Builder::initAttributes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IP::Builder::adoptAttributes(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>> IP::Builder::disownAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::IP::KV,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IP::Reader::hasContent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool IP::Builder::hasContent() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader IP::Reader::getContent() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::Builder::getContent() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::Builder::initContent() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline  ::mas::schema::fbp::IP::Type IP::Reader::getType() const {
  return _reader.getDataField< ::mas::schema::fbp::IP::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::fbp::IP::Type IP::Builder::getType() {
  return _builder.getDataField< ::mas::schema::fbp::IP::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IP::Builder::setType( ::mas::schema::fbp::IP::Type value) {
  _builder.setDataField< ::mas::schema::fbp::IP::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IP::KV::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IP::KV::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IP::KV::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IP::KV::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IP::KV::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IP::KV::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IP::KV::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IP::KV::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IP::KV::Reader::hasDesc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool IP::KV::Builder::hasDesc() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IP::KV::Reader::getDesc() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IP::KV::Builder::getDesc() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void IP::KV::Builder::setDesc( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IP::KV::Builder::initDesc(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void IP::KV::Builder::adoptDesc(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IP::KV::Builder::disownDesc() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool IP::KV::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool IP::KV::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader IP::KV::Reader::getValue() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::KV::Builder::getValue() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::KV::Builder::initValue() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool IIP::Reader::hasContent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IIP::Builder::hasContent() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader IIP::Reader::getContent() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IIP::Builder::getContent() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IIP::Builder::initContent() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

#if !CAPNP_LITE
template <typename V>
inline Channel<V>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline Channel<V>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline Channel<V>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Client& Channel<V>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Client& Channel<V>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Msg::Which Channel<V>::Msg::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::Msg::Which Channel<V>::Msg::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline bool Channel<V>::Msg::Reader::isValue() const {
  return which() == Channel<V>::Msg::VALUE;
}
template <typename V>
inline bool Channel<V>::Msg::Builder::isValue() {
  return which() == Channel<V>::Msg::VALUE;
}
template <typename V>
inline bool Channel<V>::Msg::Reader::hasValue() const {
  if (which() != Channel<V>::Msg::VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::Msg::Builder::hasValue() {
  if (which() != Channel<V>::Msg::VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline  ::capnp::ReaderFor<V> Channel<V>::Msg::Reader::getValue() const {
  KJ_IREQUIRE((which() == Channel<V>::Msg::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<V>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::BuilderFor<V> Channel<V>::Msg::Builder::getValue() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<V>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::Msg::Builder::setValue( ::capnp::ReaderFor<V> value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  ::capnp::_::PointerHelpers<V>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename V>
inline  ::capnp::BuilderFor<V> Channel<V>::Msg::Builder::initValue() {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  return ::capnp::_::PointerHelpers<V>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::BuilderFor<V> Channel<V>::Msg::Builder::initValue(unsigned int size) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  return ::capnp::_::PointerHelpers<V>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::Msg::Builder::adoptValue(
    ::capnp::Orphan<V>&& value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  ::capnp::_::PointerHelpers<V>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<V> Channel<V>::Msg::Builder::disownValue() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<V>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename V>
inline bool Channel<V>::Msg::Reader::isDone() const {
  return which() == Channel<V>::Msg::DONE;
}
template <typename V>
inline bool Channel<V>::Msg::Builder::isDone() {
  return which() == Channel<V>::Msg::DONE;
}
template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Reader::getDone() const {
  KJ_IREQUIRE((which() == Channel<V>::Msg::DONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Builder::getDone() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::DONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::Msg::Builder::setDone( ::capnp::Void value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::DONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename V>
inline bool Channel<V>::Msg::Reader::isNoMsg() const {
  return which() == Channel<V>::Msg::NO_MSG;
}
template <typename V>
inline bool Channel<V>::Msg::Builder::isNoMsg() {
  return which() == Channel<V>::Msg::NO_MSG;
}
template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Reader::getNoMsg() const {
  KJ_IREQUIRE((which() == Channel<V>::Msg::NO_MSG),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Builder::getNoMsg() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::NO_MSG),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::Msg::Builder::setNoMsg( ::capnp::Void value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::NO_MSG);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// Channel<V>::Msg
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::Msg::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::Msg::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::Msg::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::Msg::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::Msg::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::Msg::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::Msg::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d5b512f4bcd0aa2e, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline  ::uint64_t Channel<V>::StartupInfo::Reader::getBufferSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline  ::uint64_t Channel<V>::StartupInfo::Builder::getBufferSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setBufferSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics Channel<V>::StartupInfo::Reader::getCloseSemantics() const {
  return _reader.getDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics Channel<V>::StartupInfo::Builder::getCloseSemantics() {
  return _builder.getDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setCloseSemantics(typename  ::mas::schema::fbp::Channel<V>::CloseSemantics value) {
  _builder.setDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

template <typename V>
inline bool Channel<V>::StartupInfo::Reader::hasChannelSR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::StartupInfo::Builder::hasChannelSR() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline  ::capnp::Text::Reader Channel<V>::StartupInfo::Reader::getChannelSR() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::Text::Builder Channel<V>::StartupInfo::Builder::getChannelSR() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setChannelSR( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename V>
inline  ::capnp::Text::Builder Channel<V>::StartupInfo::Builder::initChannelSR(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::adoptChannelSR(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan< ::capnp::Text> Channel<V>::StartupInfo::Builder::disownChannelSR() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename V>
inline bool Channel<V>::StartupInfo::Reader::hasReaderSRs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::StartupInfo::Builder::hasReaderSRs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Channel<V>::StartupInfo::Reader::getReaderSRs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Channel<V>::StartupInfo::Builder::getReaderSRs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setReaderSRs( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setReaderSRs(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename V>
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Channel<V>::StartupInfo::Builder::initReaderSRs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::adoptReaderSRs(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Channel<V>::StartupInfo::Builder::disownReaderSRs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename V>
inline bool Channel<V>::StartupInfo::Reader::hasWriterSRs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::StartupInfo::Builder::hasWriterSRs() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Channel<V>::StartupInfo::Reader::getWriterSRs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Channel<V>::StartupInfo::Builder::getWriterSRs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setWriterSRs( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::setWriterSRs(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename V>
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Channel<V>::StartupInfo::Builder::initWriterSRs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::StartupInfo::Builder::adoptWriterSRs(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Channel<V>::StartupInfo::Builder::disownWriterSRs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

// Channel<V>::StartupInfo
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::StartupInfo::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::StartupInfo::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::StartupInfo::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::StartupInfo::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::StartupInfo::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::StartupInfo::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::StartupInfo::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e3d7a3237f175028, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
inline Channel<V>::ChanReader::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline Channel<V>::ChanReader::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanReader::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanReader::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline Channel<V>::ChanReader::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& Channel<V>::ChanReader::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& Channel<V>::ChanReader::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// Channel<V>::ChanReader::ReadParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::ReadParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::ReadParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::ReadParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::ReadParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::ReadParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c0335d99db8b2ba5, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader::CloseParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::CloseParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::CloseParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::CloseParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::CloseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::CloseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9428ea64f18c41c8, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader::CloseResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::CloseResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::CloseResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::CloseResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::CloseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::CloseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b3fe08a1bf53821a, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader::ReadIfMsgParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_89e521a99fcc4044, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg>)
Channel<V>::ChanReader::Client::readRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg>(
      0x8bc69192f3bc97ccull, 0, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanReader::Server::read(ReadContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Reader", "read",
      0x8bc69192f3bc97ccull, 0);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults>)
Channel<V>::ChanReader::Client::closeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults>(
      0x8bc69192f3bc97ccull, 1, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanReader::Server::close(CloseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Reader", "close",
      0x8bc69192f3bc97ccull, 1);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg>)
Channel<V>::ChanReader::Client::readIfMsgRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg>(
      0x8bc69192f3bc97ccull, 2, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanReader::Server::readIfMsg(ReadIfMsgContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Reader", "readIfMsg",
      0x8bc69192f3bc97ccull, 2);
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanReader::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0x8bc69192f3bc97ccull:
      return dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    case 0xc1a7daa0dc36cb65ull:
      return  ::mas::schema::persistence::Persistent::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("fbp.capnp:Channel.Reader", interfaceId);
  }
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanReader::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        read(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::fbp::Channel<V>::Msg>(context)),
        false,
        false
      };
    case 1:
      return {
        close(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults>(context)),
        false,
        false
      };
    case 2:
      return {
        readIfMsg(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams, typename  ::mas::schema::fbp::Channel<V>::Msg>(context)),
        false,
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "fbp.capnp:Channel.Reader",
          0x8bc69192f3bc97ccull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::ChanReader::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::fbp::Channel<V>::ChanReader::ReadParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::fbp::Channel<V>::ChanReader::CloseParams::_capnpPrivate::brand() },
  { 33554434,  ::mas::schema::fbp::Channel<V>::ChanReader::ReadIfMsgParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::fbp::Channel<V>::Msg::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::fbp::Channel<V>::ChanReader::CloseResults::_capnpPrivate::brand() },
  { 50331650,  ::mas::schema::fbp::Channel<V>::Msg::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_8bc69192f3bc97cc, brandScopes, brandDependencies,
  1, 6, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
inline Channel<V>::ChanWriter::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline Channel<V>::ChanWriter::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanWriter::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanWriter::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline Channel<V>::ChanWriter::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& Channel<V>::ChanWriter::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& Channel<V>::ChanWriter::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// Channel<V>::ChanWriter::WriteResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::WriteResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::WriteResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::WriteResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::WriteResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::WriteResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ce9f24b8ec149524, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanWriter::CloseParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::CloseParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::CloseParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::CloseParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::CloseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::CloseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_badc988dda3d1e50, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanWriter::CloseResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::CloseResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::CloseResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::CloseResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::CloseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::CloseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_cb02dc91e18e58c9, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::ChanWriter::WriteIfSpaceResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline bool Channel<V>::ChanWriter::WriteIfSpaceResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::ChanWriter::WriteIfSpaceResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// Channel<V>::ChanWriter::WriteIfSpaceResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c61c438f89d10281, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults>)
Channel<V>::ChanWriter::Client::writeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults>(
      0xf7fec613b4a8c79full, 0, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanWriter::Server::write(WriteContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Writer", "write",
      0xf7fec613b4a8c79full, 0);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults>)
Channel<V>::ChanWriter::Client::closeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults>(
      0xf7fec613b4a8c79full, 1, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanWriter::Server::close(CloseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Writer", "close",
      0xf7fec613b4a8c79full, 1);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults>)
Channel<V>::ChanWriter::Client::writeIfSpaceRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults>(
      0xf7fec613b4a8c79full, 2, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanWriter::Server::writeIfSpace(WriteIfSpaceContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel.Writer", "writeIfSpace",
      0xf7fec613b4a8c79full, 2);
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanWriter::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xf7fec613b4a8c79full:
      return dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    case 0xc1a7daa0dc36cb65ull:
      return  ::mas::schema::persistence::Persistent::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("fbp.capnp:Channel.Writer", interfaceId);
  }
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanWriter::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        write(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults>(context)),
        false,
        false
      };
    case 1:
      return {
        close(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults>(context)),
        false,
        false
      };
    case 2:
      return {
        writeIfSpace(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::Msg, typename  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults>(context)),
        false,
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "fbp.capnp:Channel.Writer",
          0xf7fec613b4a8c79full, methodId);
  }
}
#endif  // !CAPNP_LITE

// Channel<V>::ChanWriter
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::ChanWriter::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::fbp::Channel<V>::Msg::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseParams::_capnpPrivate::brand() },
  { 33554434,  ::mas::schema::fbp::Channel<V>::Msg::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteResults::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::fbp::Channel<V>::ChanWriter::CloseResults::_capnpPrivate::brand() },
  { 50331650,  ::mas::schema::fbp::Channel<V>::ChanWriter::WriteIfSpaceResults::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f7fec613b4a8c79f, brandScopes, brandDependencies,
  1, 6, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline  ::uint64_t Channel<V>::SetBufferSizeParams::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1ull);
}

template <typename V>
inline  ::uint64_t Channel<V>::SetBufferSizeParams::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1ull);
}
template <typename V>
inline void Channel<V>::SetBufferSizeParams::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1ull);
}

// Channel<V>::SetBufferSizeParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetBufferSizeParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetBufferSizeParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetBufferSizeParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetBufferSizeParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetBufferSizeParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_92101e3b7a761333, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::SetBufferSizeResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetBufferSizeResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetBufferSizeResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetBufferSizeResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetBufferSizeResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetBufferSizeResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_fe6a08d5e0712c23, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ReaderParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ReaderParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ReaderParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ReaderParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ReaderParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ReaderParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ReaderParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ReaderParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e607c9dd64da04c4, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::ReaderResults::Reader::hasR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::ReaderResults::Builder::hasR() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::ReaderResults::Reader::getR() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::ReaderResults::Builder::getR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::ReaderResults::Pipeline::getR() {
  return typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client(_typeless.getPointerField(0).asCap());
}
template <typename V>
inline void Channel<V>::ReaderResults::Builder::setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::ReaderResults::Builder::setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::ReaderResults::Builder::adoptR(
    ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader> Channel<V>::ReaderResults::Builder::disownR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::ReaderResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::ReaderResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ReaderResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::ReaderResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ReaderResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ReaderResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ReaderResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::ReaderResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::fbp::Channel<V>::ChanReader::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ReaderResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b135ffc9ccc9eca6, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::WriterParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::WriterParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::WriterParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::WriterParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::WriterParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::WriterParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::WriterParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::WriterParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_be611d34e368e109, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::WriterResults::Reader::hasW() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::WriterResults::Builder::hasW() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::WriterResults::Reader::getW() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::WriterResults::Builder::getW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::WriterResults::Pipeline::getW() {
  return typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client(_typeless.getPointerField(0).asCap());
}
template <typename V>
inline void Channel<V>::WriterResults::Builder::setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::WriterResults::Builder::setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::WriterResults::Builder::adoptW(
    ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter> Channel<V>::WriterResults::Builder::disownW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::WriterResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::WriterResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::WriterResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::WriterResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::WriterResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::WriterResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::WriterResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::WriterResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::fbp::Channel<V>::ChanWriter::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::WriterResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b47b53679e985c7e, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::EndpointsParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::EndpointsParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::EndpointsParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::EndpointsParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::EndpointsParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::EndpointsParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::EndpointsParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::EndpointsParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d23f817e914373d8, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::EndpointsResults::Reader::hasR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::EndpointsResults::Builder::hasR() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::EndpointsResults::Reader::getR() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::EndpointsResults::Builder::getR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client Channel<V>::EndpointsResults::Pipeline::getR() {
  return typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client(_typeless.getPointerField(0).asCap());
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setR(typename  ::mas::schema::fbp::Channel<V>::ChanReader::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::adoptR(
    ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanReader> Channel<V>::EndpointsResults::Builder::disownR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanReader>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::EndpointsResults::Reader::hasW() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::EndpointsResults::Builder::hasW() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::EndpointsResults::Reader::getW() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::EndpointsResults::Builder::getW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client Channel<V>::EndpointsResults::Pipeline::getW() {
  return typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client(_typeless.getPointerField(1).asCap());
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setW(typename  ::mas::schema::fbp::Channel<V>::ChanWriter::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::adoptW(
    ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::fbp::Channel<V>::ChanWriter> Channel<V>::EndpointsResults::Builder::disownW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::fbp::Channel<V>::ChanWriter>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::EndpointsResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::EndpointsResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::EndpointsResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::EndpointsResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::EndpointsResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::EndpointsResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::EndpointsResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::EndpointsResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::fbp::Channel<V>::ChanReader::_capnpPrivate::brand() },
  { 16777217,  ::mas::schema::fbp::Channel<V>::ChanWriter::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::EndpointsResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f37401d21f8d97bb, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics Channel<V>::SetAutoCloseSemanticsParams::Reader::getCs() const {
  return _reader.getDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline typename  ::mas::schema::fbp::Channel<V>::CloseSemantics Channel<V>::SetAutoCloseSemanticsParams::Builder::getCs() {
  return _builder.getDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::SetAutoCloseSemanticsParams::Builder::setCs(typename  ::mas::schema::fbp::Channel<V>::CloseSemantics value) {
  _builder.setDataField<typename  ::mas::schema::fbp::Channel<V>::CloseSemantics>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// Channel<V>::SetAutoCloseSemanticsParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b49836b545583add, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::SetAutoCloseSemanticsResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c0fc6e5a3fcb3206, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::CloseParams::Reader::getWaitForEmptyBuffer() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}

template <typename V>
inline bool Channel<V>::CloseParams::Builder::getWaitForEmptyBuffer() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}
template <typename V>
inline void Channel<V>::CloseParams::Builder::setWaitForEmptyBuffer(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, true);
}

// Channel<V>::CloseParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::CloseParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::CloseParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::CloseParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::CloseParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::CloseParams::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::CloseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::CloseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_95d8ad01c1113d9c, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::CloseResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr uint16_t Channel<V>::CloseResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::CloseResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::CloseResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::CloseResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::CloseResults::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::CloseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::CloseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_cc079ad60f1363b7, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults>)
Channel<V>::Client::setBufferSizeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults>(
      0x9c62c32b2ff2b1e8ull, 0, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::setBufferSize(SetBufferSizeContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "setBufferSize",
      0x9c62c32b2ff2b1e8ull, 0);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::ReaderParams, typename  ::mas::schema::fbp::Channel<V>::ReaderResults>)
Channel<V>::Client::readerRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::ReaderParams, typename  ::mas::schema::fbp::Channel<V>::ReaderResults>(
      0x9c62c32b2ff2b1e8ull, 1, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::reader(ReaderContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "reader",
      0x9c62c32b2ff2b1e8ull, 1);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::WriterParams, typename  ::mas::schema::fbp::Channel<V>::WriterResults>)
Channel<V>::Client::writerRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::WriterParams, typename  ::mas::schema::fbp::Channel<V>::WriterResults>(
      0x9c62c32b2ff2b1e8ull, 2, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::writer(WriterContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "writer",
      0x9c62c32b2ff2b1e8ull, 2);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::EndpointsParams, typename  ::mas::schema::fbp::Channel<V>::EndpointsResults>)
Channel<V>::Client::endpointsRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::EndpointsParams, typename  ::mas::schema::fbp::Channel<V>::EndpointsResults>(
      0x9c62c32b2ff2b1e8ull, 3, sizeHint, {false});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::endpoints(EndpointsContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "endpoints",
      0x9c62c32b2ff2b1e8ull, 3);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults>)
Channel<V>::Client::setAutoCloseSemanticsRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults>(
      0x9c62c32b2ff2b1e8ull, 4, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::setAutoCloseSemantics(SetAutoCloseSemanticsContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "setAutoCloseSemantics",
      0x9c62c32b2ff2b1e8ull, 4);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::fbp::Channel<V>::CloseParams, typename  ::mas::schema::fbp::Channel<V>::CloseResults>)
Channel<V>::Client::closeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::fbp::Channel<V>::CloseParams, typename  ::mas::schema::fbp::Channel<V>::CloseResults>(
      0x9c62c32b2ff2b1e8ull, 5, sizeHint, {true});
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::close(CloseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "fbp.capnp:Channel", "close",
      0x9c62c32b2ff2b1e8ull, 5);
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0x9c62c32b2ff2b1e8ull:
      return dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    case 0xc1a7daa0dc36cb65ull:
      return  ::mas::schema::persistence::Persistent::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("fbp.capnp:Channel", interfaceId);
  }
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        setBufferSize(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults>(context)),
        false,
        false
      };
    case 1:
      return {
        reader(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::ReaderParams, typename  ::mas::schema::fbp::Channel<V>::ReaderResults>(context)),
        false,
        false
      };
    case 2:
      return {
        writer(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::WriterParams, typename  ::mas::schema::fbp::Channel<V>::WriterResults>(context)),
        false,
        false
      };
    case 3:
      return {
        endpoints(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::EndpointsParams, typename  ::mas::schema::fbp::Channel<V>::EndpointsResults>(context)),
        false,
        false
      };
    case 4:
      return {
        setAutoCloseSemantics(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults>(context)),
        false,
        false
      };
    case 5:
      return {
        close(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::fbp::Channel<V>::CloseParams, typename  ::mas::schema::fbp::Channel<V>::CloseResults>(context)),
        false,
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "fbp.capnp:Channel",
          0x9c62c32b2ff2b1e8ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Channel<V>
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
constexpr ::capnp::Kind Channel<V>::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::_capnpPrivate::brandScopes[] = {
  { 0x9c62c32b2ff2b1e8, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::fbp::Channel<V>::SetBufferSizeParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::fbp::Channel<V>::ReaderParams::_capnpPrivate::brand() },
  { 33554434,  ::mas::schema::fbp::Channel<V>::WriterParams::_capnpPrivate::brand() },
  { 33554435,  ::mas::schema::fbp::Channel<V>::EndpointsParams::_capnpPrivate::brand() },
  { 33554436,  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::brand() },
  { 33554437,  ::mas::schema::fbp::Channel<V>::CloseParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::fbp::Channel<V>::SetBufferSizeResults::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::fbp::Channel<V>::ReaderResults::_capnpPrivate::brand() },
  { 50331650,  ::mas::schema::fbp::Channel<V>::WriterResults::_capnpPrivate::brand() },
  { 50331651,  ::mas::schema::fbp::Channel<V>::EndpointsResults::_capnpPrivate::brand() },
  { 50331652,  ::mas::schema::fbp::Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::brand() },
  { 50331653,  ::mas::schema::fbp::Channel<V>::CloseResults::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9c62c32b2ff2b1e8, brandScopes, brandDependencies,
  1, 12, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline StartChannelsService::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline StartChannelsService::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline StartChannelsService::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline StartChannelsService::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline StartChannelsService::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::fbp::StartChannelsService::Client& StartChannelsService::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::fbp::StartChannelsService::Client& StartChannelsService::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool StartChannelsService::Params::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::Params::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader StartChannelsService::Params::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder StartChannelsService::Params::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void StartChannelsService::Params::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder StartChannelsService::Params::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StartChannelsService::Params::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> StartChannelsService::Params::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t StartChannelsService::Params::Reader::getNoOfChannels() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Builder::getNoOfChannels() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}
inline void StartChannelsService::Params::Builder::setNoOfChannels( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Reader::getNoOfReaders() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Builder::getNoOfReaders() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1u);
}
inline void StartChannelsService::Params::Builder::setNoOfReaders( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Reader::getNoOfWriters() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Builder::getNoOfWriters() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, 1u);
}
inline void StartChannelsService::Params::Builder::setNoOfWriters( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value, 1u);
}

inline bool StartChannelsService::Params::Reader::hasReaderSrts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::Params::Builder::hasReaderSrts() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader StartChannelsService::Params::Reader::getReaderSrts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder StartChannelsService::Params::Builder::getReaderSrts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void StartChannelsService::Params::Builder::setReaderSrts( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void StartChannelsService::Params::Builder::setReaderSrts(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder StartChannelsService::Params::Builder::initReaderSrts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void StartChannelsService::Params::Builder::adoptReaderSrts(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> StartChannelsService::Params::Builder::disownReaderSrts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool StartChannelsService::Params::Reader::hasWriterSrts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::Params::Builder::hasWriterSrts() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader StartChannelsService::Params::Reader::getWriterSrts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder StartChannelsService::Params::Builder::getWriterSrts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void StartChannelsService::Params::Builder::setWriterSrts( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void StartChannelsService::Params::Builder::setWriterSrts(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder StartChannelsService::Params::Builder::initWriterSrts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void StartChannelsService::Params::Builder::adoptWriterSrts(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> StartChannelsService::Params::Builder::disownWriterSrts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint16_t StartChannelsService::Params::Reader::getBufferSize() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint16_t StartChannelsService::Params::Builder::getBufferSize() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, 1u);
}
inline void StartChannelsService::Params::Builder::setBufferSize( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value, 1u);
}

inline bool StartChannelsService::StartResults::Reader::hasStartupInfos() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::StartResults::Builder::hasStartupInfos() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Reader StartChannelsService::StartResults::Reader::getStartupInfos() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Builder StartChannelsService::StartResults::Builder::getStartupInfos() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void StartChannelsService::StartResults::Builder::setStartupInfos( ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>::Builder StartChannelsService::StartResults::Builder::initStartupInfos(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StartChannelsService::StartResults::Builder::adoptStartupInfos(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>> StartChannelsService::StartResults::Builder::disownStartupInfos() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Channel< ::capnp::AnyPointer>::StartupInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool StartChannelsService::StartResults::Reader::hasStop() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool StartChannelsService::StartResults::Builder::hasStop() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::service::Stoppable::Client StartChannelsService::StartResults::Reader::getStop() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::service::Stoppable::Client StartChannelsService::StartResults::Builder::getStop() {
  return ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::service::Stoppable::Client StartChannelsService::StartResults::Pipeline::getStop() {
  return  ::mas::schema::service::Stoppable::Client(_typeless.getPointerField(1).asCap());
}
inline void StartChannelsService::StartResults::Builder::setStop( ::mas::schema::service::Stoppable::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void StartChannelsService::StartResults::Builder::setStop( ::mas::schema::service::Stoppable::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void StartChannelsService::StartResults::Builder::adoptStop(
    ::capnp::Orphan< ::mas::schema::service::Stoppable>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::service::Stoppable> StartChannelsService::StartResults::Builder::disownStop() {
  return ::capnp::_::PointerHelpers< ::mas::schema::service::Stoppable>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool PortInfos::Reader::hasInPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::Builder::hasInPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader PortInfos::Reader::getInPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder PortInfos::Builder::getInPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PortInfos::Builder::setInPorts( ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder PortInfos::Builder::initInPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PortInfos::Builder::adoptInPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>> PortInfos::Builder::disownInPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PortInfos::Reader::hasOutPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::Builder::hasOutPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader PortInfos::Reader::getOutPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder PortInfos::Builder::getOutPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PortInfos::Builder::setOutPorts( ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>::Builder PortInfos::Builder::initOutPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void PortInfos::Builder::adoptOutPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>> PortInfos::Builder::disownOutPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::PortInfos::NameAndSR,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::mas::schema::fbp::PortInfos::NameAndSR::Which PortInfos::NameAndSR::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::fbp::PortInfos::NameAndSR::Which PortInfos::NameAndSR::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool PortInfos::NameAndSR::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::NameAndSR::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader PortInfos::NameAndSR::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder PortInfos::NameAndSR::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PortInfos::NameAndSR::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder PortInfos::NameAndSR::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PortInfos::NameAndSR::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> PortInfos::NameAndSR::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PortInfos::NameAndSR::Reader::isSr() const {
  return which() == PortInfos::NameAndSR::SR;
}
inline bool PortInfos::NameAndSR::Builder::isSr() {
  return which() == PortInfos::NameAndSR::SR;
}
inline bool PortInfos::NameAndSR::Reader::hasSr() const {
  if (which() != PortInfos::NameAndSR::SR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::NameAndSR::Builder::hasSr() {
  if (which() != PortInfos::NameAndSR::SR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader PortInfos::NameAndSR::Reader::getSr() const {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder PortInfos::NameAndSR::Builder::getSr() {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PortInfos::NameAndSR::Builder::setSr( ::capnp::Text::Reader value) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SR);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder PortInfos::NameAndSR::Builder::initSr(unsigned int size) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SR);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void PortInfos::NameAndSR::Builder::adoptSr(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SR);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> PortInfos::NameAndSR::Builder::disownSr() {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PortInfos::NameAndSR::Reader::isSrs() const {
  return which() == PortInfos::NameAndSR::SRS;
}
inline bool PortInfos::NameAndSR::Builder::isSrs() {
  return which() == PortInfos::NameAndSR::SRS;
}
inline bool PortInfos::NameAndSR::Reader::hasSrs() const {
  if (which() != PortInfos::NameAndSR::SRS) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PortInfos::NameAndSR::Builder::hasSrs() {
  if (which() != PortInfos::NameAndSR::SRS) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader PortInfos::NameAndSR::Reader::getSrs() const {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SRS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder PortInfos::NameAndSR::Builder::getSrs() {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SRS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PortInfos::NameAndSR::Builder::setSrs( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SRS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void PortInfos::NameAndSR::Builder::setSrs(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SRS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder PortInfos::NameAndSR::Builder::initSrs(unsigned int size) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SRS);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void PortInfos::NameAndSR::Builder::adoptSrs(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  _builder.setDataField<PortInfos::NameAndSR::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PortInfos::NameAndSR::SRS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> PortInfos::NameAndSR::Builder::disownSrs() {
  KJ_IREQUIRE((which() == PortInfos::NameAndSR::SRS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Component::Reader::hasInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Builder::hasInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::IdInformation::Reader Component::Reader::getInfo() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::IdInformation::Builder Component::Builder::getInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::IdInformation::Pipeline Component::Pipeline::getInfo() {
  return  ::mas::schema::common::IdInformation::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Component::Builder::setInfo( ::mas::schema::common::IdInformation::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::IdInformation::Builder Component::Builder::initInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Component::Builder::adoptInfo(
    ::capnp::Orphan< ::mas::schema::common::IdInformation>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::IdInformation> Component::Builder::disownInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::mas::schema::fbp::Component::ComponentType Component::Reader::getType() const {
  return _reader.getDataField< ::mas::schema::fbp::Component::ComponentType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::fbp::Component::ComponentType Component::Builder::getType() {
  return _builder.getDataField< ::mas::schema::fbp::Component::ComponentType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Component::Builder::setType( ::mas::schema::fbp::Component::ComponentType value) {
  _builder.setDataField< ::mas::schema::fbp::Component::ComponentType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Component::Reader::hasInPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Builder::hasInPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader Component::Reader::getInPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Component::Builder::getInPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Component::Builder::setInPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Component::Builder::initInPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Component::Builder::adoptInPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> Component::Builder::disownInPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Component::Reader::hasOutPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Builder::hasOutPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader Component::Reader::getOutPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Component::Builder::getOutPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Component::Builder::setOutPorts( ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>::Builder Component::Builder::initOutPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Component::Builder::adoptOutPorts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>> Component::Builder::disownOutPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::Component::Port,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Component::Reader::hasRun() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Builder::hasRun() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::fbp::Component::Runnable::Client Component::Reader::getRun() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component::Runnable>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Component::Runnable::Client Component::Builder::getRun() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component::Runnable>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Component::Runnable::Client Component::Pipeline::getRun() {
  return  ::mas::schema::fbp::Component::Runnable::Client(_typeless.getPointerField(3).asCap());
}
inline void Component::Builder::setRun( ::mas::schema::fbp::Component::Runnable::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component::Runnable>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Component::Builder::setRun( ::mas::schema::fbp::Component::Runnable::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component::Runnable>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), cap);
}
inline void Component::Builder::adoptRun(
    ::capnp::Orphan< ::mas::schema::fbp::Component::Runnable>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component::Runnable>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::fbp::Component::Runnable> Component::Builder::disownRun() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component::Runnable>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline Component::Runnable::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Component::Runnable::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Component::Runnable::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Component::Runnable::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Component::Runnable::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::fbp::Component::Runnable::Client& Component::Runnable::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::fbp::Component::Runnable::Client& Component::Runnable::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Component::Runnable::StartParams::Reader::hasPortInfosReaderSr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Runnable::StartParams::Builder::hasPortInfosReaderSr() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Component::Runnable::StartParams::Reader::getPortInfosReaderSr() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Component::Runnable::StartParams::Builder::getPortInfosReaderSr() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Component::Runnable::StartParams::Builder::setPortInfosReaderSr( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Component::Runnable::StartParams::Builder::initPortInfosReaderSr(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Component::Runnable::StartParams::Builder::adoptPortInfosReaderSr(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Component::Runnable::StartParams::Builder::disownPortInfosReaderSr() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Component::Runnable::StartParams::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Runnable::StartParams::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Component::Runnable::StartParams::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Component::Runnable::StartParams::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Component::Runnable::StartParams::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Component::Runnable::StartParams::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Component::Runnable::StartParams::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Component::Runnable::StartParams::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Component::Runnable::StartResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Component::Runnable::StartResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Component::Runnable::StartResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Component::Runnable::StopResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Component::Runnable::StopResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Component::Runnable::StopResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Component::Port::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Port::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Component::Port::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Component::Port::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Component::Port::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Component::Port::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Component::Port::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Component::Port::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Component::Port::Reader::hasContentType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Component::Port::Builder::hasContentType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Component::Port::Reader::getContentType() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Component::Port::Builder::getContentType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Component::Port::Builder::setContentType( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Component::Port::Builder::initContentType(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Component::Port::Builder::adoptContentType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Component::Port::Builder::disownContentType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::mas::schema::fbp::Component::Port::PortType Component::Port::Reader::getType() const {
  return _reader.getDataField< ::mas::schema::fbp::Component::Port::PortType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::fbp::Component::Port::PortType Component::Port::Builder::getType() {
  return _builder.getDataField< ::mas::schema::fbp::Component::Port::PortType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Component::Port::Builder::setType( ::mas::schema::fbp::Component::Port::PortType value) {
  _builder.setDataField< ::mas::schema::fbp::Component::Port::PortType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline ComponentService::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline ComponentService::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline ComponentService::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline ComponentService::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline ComponentService::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::fbp::ComponentService::Client& ComponentService::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::fbp::ComponentService::Client& ComponentService::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool ComponentService::Entry::Reader::hasCategoryId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentService::Entry::Builder::hasCategoryId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ComponentService::Entry::Reader::getCategoryId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ComponentService::Entry::Builder::getCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentService::Entry::Builder::setCategoryId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ComponentService::Entry::Builder::initCategoryId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ComponentService::Entry::Builder::adoptCategoryId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ComponentService::Entry::Builder::disownCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ComponentService::Entry::Reader::hasComponent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentService::Entry::Builder::hasComponent() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::fbp::Component::Reader ComponentService::Entry::Reader::getComponent() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Component::Builder ComponentService::Entry::Builder::getComponent() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::fbp::Component::Pipeline ComponentService::Entry::Pipeline::getComponent() {
  return  ::mas::schema::fbp::Component::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ComponentService::Entry::Builder::setComponent( ::mas::schema::fbp::Component::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::fbp::Component::Builder ComponentService::Entry::Builder::initComponent() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ComponentService::Entry::Builder::adoptComponent(
    ::capnp::Orphan< ::mas::schema::fbp::Component>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::fbp::Component> ComponentService::Entry::Builder::disownComponent() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ComponentService::ListResults::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentService::ListResults::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>::Reader ComponentService::ListResults::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>::Builder ComponentService::ListResults::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentService::ListResults::Builder::setEntries( ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>::Builder ComponentService::ListResults::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ComponentService::ListResults::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>> ComponentService::ListResults::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::fbp::ComponentService::Entry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ComponentService::ComponentParams::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentService::ComponentParams::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ComponentService::ComponentParams::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ComponentService::ComponentParams::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentService::ComponentParams::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ComponentService::ComponentParams::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ComponentService::ComponentParams::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ComponentService::ComponentParams::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ComponentService::ComponentResults::Reader::hasComp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentService::ComponentResults::Builder::hasComp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::fbp::Component::Reader ComponentService::ComponentResults::Reader::getComp() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::fbp::Component::Builder ComponentService::ComponentResults::Builder::getComp() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::fbp::Component::Pipeline ComponentService::ComponentResults::Pipeline::getComp() {
  return  ::mas::schema::fbp::Component::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ComponentService::ComponentResults::Builder::setComp( ::mas::schema::fbp::Component::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::fbp::Component::Builder ComponentService::ComponentResults::Builder::initComp() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentService::ComponentResults::Builder::adoptComp(
    ::capnp::Orphan< ::mas::schema::fbp::Component>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::fbp::Component> ComponentService::ComponentResults::Builder::disownComp() {
  return ::capnp::_::PointerHelpers< ::mas::schema::fbp::Component>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ComponentService::CategoriesResults::Reader::hasCategories() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentService::CategoriesResults::Builder::hasCategories() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader ComponentService::CategoriesResults::Reader::getCategories() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder ComponentService::CategoriesResults::Builder::getCategories() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentService::CategoriesResults::Builder::setCategories( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder ComponentService::CategoriesResults::Builder::initCategories(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ComponentService::CategoriesResults::Builder::adoptCategories(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> ComponentService::CategoriesResults::Builder::disownCategories() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

