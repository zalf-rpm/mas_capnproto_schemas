// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: registry.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"
#include "persistence.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f503f3237666574e);
CAPNP_DECLARE_SCHEMA(db16d4fbb18486f6);
CAPNP_DECLARE_SCHEMA(bd3d832f7a7235b5);
CAPNP_DECLARE_SCHEMA(d5be1b8e0180ded6);
CAPNP_DECLARE_SCHEMA(a9aca103106c8f05);
CAPNP_DECLARE_SCHEMA(8ebfd50c805adbc3);
CAPNP_DECLARE_SCHEMA(d887d79a7ed3f45f);
CAPNP_DECLARE_SCHEMA(96a5b17eee7ee1a3);
CAPNP_DECLARE_SCHEMA(a092f60656bb0db4);
CAPNP_DECLARE_SCHEMA(ee2cf8cf148921b5);
CAPNP_DECLARE_SCHEMA(fe62caefab7dfdad);
CAPNP_DECLARE_SCHEMA(ca7b4bd1600633b8);
CAPNP_DECLARE_SCHEMA(c17987510cf7ac13);
CAPNP_DECLARE_SCHEMA(9c49e6e65e34c29b);
CAPNP_DECLARE_SCHEMA(b2bf60b5817330b0);
CAPNP_DECLARE_SCHEMA(891283e1b248bc9d);
CAPNP_DECLARE_SCHEMA(9ffc53716151c5fa);
CAPNP_DECLARE_SCHEMA(e4eaf56eb486064d);
CAPNP_DECLARE_SCHEMA(abaef93c36f2d1ea);
CAPNP_DECLARE_SCHEMA(aa1198dd7e71b20e);
CAPNP_DECLARE_SCHEMA(e5a84717ea75fb0d);
CAPNP_DECLARE_SCHEMA(c7597e4462528489);
CAPNP_DECLARE_SCHEMA(d023a1df5e372a7e);
CAPNP_DECLARE_SCHEMA(a19166b9981b0854);
CAPNP_DECLARE_SCHEMA(b2a9b080f0c4013c);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace registry {

struct Admin {
  Admin() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct AddCategoryParams;
  struct AddCategoryResults;
  struct RemoveCategoryParams;
  struct RemoveCategoryResults;
  struct MoveObjectsParams;
  struct MoveObjectsResults;
  struct RemoveObjectsParams;
  struct RemoveObjectsResults;
  struct RegistryParams;
  struct RegistryResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f503f3237666574e)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Admin::AddCategoryParams {
  AddCategoryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db16d4fbb18486f6, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::AddCategoryResults {
  AddCategoryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd3d832f7a7235b5, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::RemoveCategoryParams {
  RemoveCategoryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d5be1b8e0180ded6, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::RemoveCategoryResults {
  RemoveCategoryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9aca103106c8f05, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::MoveObjectsParams {
  MoveObjectsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ebfd50c805adbc3, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::MoveObjectsResults {
  MoveObjectsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d887d79a7ed3f45f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::RemoveObjectsParams {
  RemoveObjectsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(96a5b17eee7ee1a3, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::RemoveObjectsResults {
  RemoveObjectsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a092f60656bb0db4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::RegistryParams {
  RegistryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee2cf8cf148921b5, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::RegistryResults {
  RegistryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe62caefab7dfdad, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename T = ::capnp::AnyPointer>
struct Registry {
  Registry() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Entry;
  struct SupportedCategoriesParams;
  struct SupportedCategoriesResults;
  struct CategoryInfoParams;
  struct EntriesParams;
  struct EntriesResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ca7b4bd1600633b8)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename T>
struct Registry<T>::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    REF,
    VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c17987510cf7ac13, 1, 3)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Registry<T>::SupportedCategoriesParams {
  SupportedCategoriesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9c49e6e65e34c29b, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Registry<T>::SupportedCategoriesResults {
  SupportedCategoriesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b2bf60b5817330b0, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Registry<T>::CategoryInfoParams {
  CategoryInfoParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(891283e1b248bc9d, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Registry<T>::EntriesParams {
  EntriesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ffc53716151c5fa, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Registry<T>::EntriesResults {
  EntriesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4eaf56eb486064d, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Registrar {
  Registrar() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CrossDomainRestore;
  struct RegParams;
  struct Unregister;
  struct RegisterResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(abaef93c36f2d1ea)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Registrar::CrossDomainRestore {
  CrossDomainRestore() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa1198dd7e71b20e, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Registrar::RegParams {
  RegParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e5a84717ea75fb0d, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Registrar::Unregister {
  Unregister() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct UnregisterParams;
  struct UnregisterResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c7597e4462528489)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Registrar::Unregister::UnregisterParams {
  UnregisterParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d023a1df5e372a7e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Registrar::Unregister::UnregisterResults {
  UnregisterResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a19166b9981b0854, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Registrar::RegisterResults {
  RegisterResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b2a9b080f0c4013c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Admin::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Admin Calls;
  typedef Admin Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::registry::Admin::AddCategoryParams,  ::mas::schema::registry::Admin::AddCategoryResults> addCategoryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::registry::Admin::RemoveCategoryParams,  ::mas::schema::registry::Admin::RemoveCategoryResults> removeCategoryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::registry::Admin::MoveObjectsParams,  ::mas::schema::registry::Admin::MoveObjectsResults> moveObjectsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::registry::Admin::RemoveObjectsParams,  ::mas::schema::registry::Admin::RemoveObjectsResults> removeObjectsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::registry::Admin::RegistryParams,  ::mas::schema::registry::Admin::RegistryResults> registryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Admin::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Admin Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::registry::Admin::AddCategoryParams AddCategoryParams;
  typedef  ::mas::schema::registry::Admin::AddCategoryResults AddCategoryResults;
  typedef ::capnp::CallContext<AddCategoryParams, AddCategoryResults> AddCategoryContext;
  virtual ::kj::Promise<void> addCategory(AddCategoryContext context);
  typedef  ::mas::schema::registry::Admin::RemoveCategoryParams RemoveCategoryParams;
  typedef  ::mas::schema::registry::Admin::RemoveCategoryResults RemoveCategoryResults;
  typedef ::capnp::CallContext<RemoveCategoryParams, RemoveCategoryResults> RemoveCategoryContext;
  virtual ::kj::Promise<void> removeCategory(RemoveCategoryContext context);
  typedef  ::mas::schema::registry::Admin::MoveObjectsParams MoveObjectsParams;
  typedef  ::mas::schema::registry::Admin::MoveObjectsResults MoveObjectsResults;
  typedef ::capnp::CallContext<MoveObjectsParams, MoveObjectsResults> MoveObjectsContext;
  virtual ::kj::Promise<void> moveObjects(MoveObjectsContext context);
  typedef  ::mas::schema::registry::Admin::RemoveObjectsParams RemoveObjectsParams;
  typedef  ::mas::schema::registry::Admin::RemoveObjectsResults RemoveObjectsResults;
  typedef ::capnp::CallContext<RemoveObjectsParams, RemoveObjectsResults> RemoveObjectsContext;
  virtual ::kj::Promise<void> removeObjects(RemoveObjectsContext context);
  typedef  ::mas::schema::registry::Admin::RegistryParams RegistryParams;
  typedef  ::mas::schema::registry::Admin::RegistryResults RegistryResults;
  typedef ::capnp::CallContext<RegistryParams, RegistryResults> RegistryContext;
  virtual ::kj::Promise<void> registry(RegistryContext context);

  inline  ::mas::schema::registry::Admin::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::registry::Admin>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Admin::AddCategoryParams::Reader {
public:
  typedef AddCategoryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCategory() const;
  inline  ::mas::schema::common::IdInformation::Reader getCategory() const;

  inline bool getUpsert() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::AddCategoryParams::Builder {
public:
  typedef AddCategoryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCategory();
  inline  ::mas::schema::common::IdInformation::Builder getCategory();
  inline void setCategory( ::mas::schema::common::IdInformation::Reader value);
  inline  ::mas::schema::common::IdInformation::Builder initCategory();
  inline void adoptCategory(::capnp::Orphan< ::mas::schema::common::IdInformation>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::IdInformation> disownCategory();

  inline bool getUpsert();
  inline void setUpsert(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::AddCategoryParams::Pipeline {
public:
  typedef AddCategoryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::IdInformation::Pipeline getCategory();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::AddCategoryResults::Reader {
public:
  typedef AddCategoryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::AddCategoryResults::Builder {
public:
  typedef AddCategoryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::AddCategoryResults::Pipeline {
public:
  typedef AddCategoryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::RemoveCategoryParams::Reader {
public:
  typedef RemoveCategoryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCategoryId() const;
  inline  ::capnp::Text::Reader getCategoryId() const;

  inline bool hasMoveObjectsToCategoryId() const;
  inline  ::capnp::Text::Reader getMoveObjectsToCategoryId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::RemoveCategoryParams::Builder {
public:
  typedef RemoveCategoryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCategoryId();
  inline  ::capnp::Text::Builder getCategoryId();
  inline void setCategoryId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCategoryId(unsigned int size);
  inline void adoptCategoryId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCategoryId();

  inline bool hasMoveObjectsToCategoryId();
  inline  ::capnp::Text::Builder getMoveObjectsToCategoryId();
  inline void setMoveObjectsToCategoryId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initMoveObjectsToCategoryId(unsigned int size);
  inline void adoptMoveObjectsToCategoryId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownMoveObjectsToCategoryId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::RemoveCategoryParams::Pipeline {
public:
  typedef RemoveCategoryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::RemoveCategoryResults::Reader {
public:
  typedef RemoveCategoryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRemovedObjects() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader getRemovedObjects() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::RemoveCategoryResults::Builder {
public:
  typedef RemoveCategoryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRemovedObjects();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder getRemovedObjects();
  inline void setRemovedObjects( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder initRemovedObjects(unsigned int size);
  inline void adoptRemovedObjects(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> disownRemovedObjects();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::RemoveCategoryResults::Pipeline {
public:
  typedef RemoveCategoryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::MoveObjectsParams::Reader {
public:
  typedef MoveObjectsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasObjectIds() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getObjectIds() const;

  inline bool hasToCatId() const;
  inline  ::capnp::Text::Reader getToCatId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::MoveObjectsParams::Builder {
public:
  typedef MoveObjectsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasObjectIds();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getObjectIds();
  inline void setObjectIds( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setObjectIds(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initObjectIds(unsigned int size);
  inline void adoptObjectIds(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownObjectIds();

  inline bool hasToCatId();
  inline  ::capnp::Text::Builder getToCatId();
  inline void setToCatId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initToCatId(unsigned int size);
  inline void adoptToCatId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownToCatId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::MoveObjectsParams::Pipeline {
public:
  typedef MoveObjectsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::MoveObjectsResults::Reader {
public:
  typedef MoveObjectsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMovedObjectIds() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getMovedObjectIds() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::MoveObjectsResults::Builder {
public:
  typedef MoveObjectsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMovedObjectIds();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getMovedObjectIds();
  inline void setMovedObjectIds( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setMovedObjectIds(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initMovedObjectIds(unsigned int size);
  inline void adoptMovedObjectIds(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownMovedObjectIds();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::MoveObjectsResults::Pipeline {
public:
  typedef MoveObjectsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::RemoveObjectsParams::Reader {
public:
  typedef RemoveObjectsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasObjectIds() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getObjectIds() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::RemoveObjectsParams::Builder {
public:
  typedef RemoveObjectsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasObjectIds();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getObjectIds();
  inline void setObjectIds( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setObjectIds(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initObjectIds(unsigned int size);
  inline void adoptObjectIds(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownObjectIds();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::RemoveObjectsParams::Pipeline {
public:
  typedef RemoveObjectsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::RemoveObjectsResults::Reader {
public:
  typedef RemoveObjectsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRemovedObjects() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader getRemovedObjects() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::RemoveObjectsResults::Builder {
public:
  typedef RemoveObjectsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRemovedObjects();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder getRemovedObjects();
  inline void setRemovedObjects( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder initRemovedObjects(unsigned int size);
  inline void adoptRemovedObjects(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> disownRemovedObjects();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::RemoveObjectsResults::Pipeline {
public:
  typedef RemoveObjectsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::RegistryParams::Reader {
public:
  typedef RegistryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::RegistryParams::Builder {
public:
  typedef RegistryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::RegistryParams::Pipeline {
public:
  typedef RegistryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::RegistryResults::Reader {
public:
  typedef RegistryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRegistry() const;
#if !CAPNP_LITE
  inline  ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client getRegistry() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::RegistryResults::Builder {
public:
  typedef RegistryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRegistry();
#if !CAPNP_LITE
  inline  ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client getRegistry();
  inline void setRegistry( ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client&& value);
  inline void setRegistry( ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client& value);
  inline void adoptRegistry(::capnp::Orphan< ::mas::schema::registry::Registry< ::capnp::AnyPointer>>&& value);
  inline ::capnp::Orphan< ::mas::schema::registry::Registry< ::capnp::AnyPointer>> disownRegistry();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::RegistryResults::Pipeline {
public:
  typedef RegistryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client getRegistry();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
class Registry<T>::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Registry Calls;
  typedef Registry Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::Client asGeneric() {
    return castAs<Registry<T2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesParams, typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesResults>) supportedCategoriesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::registry::Registry<T>::CategoryInfoParams,  ::mas::schema::common::IdInformation>) categoryInfoRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::registry::Registry<T>::EntriesParams, typename  ::mas::schema::registry::Registry<T>::EntriesResults>) entriesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename T>
class Registry<T>::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Registry Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesParams SupportedCategoriesParams;
  typedef typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesResults SupportedCategoriesResults;
  typedef ::capnp::CallContext<SupportedCategoriesParams, SupportedCategoriesResults> SupportedCategoriesContext;
  virtual ::kj::Promise<void> supportedCategories(SupportedCategoriesContext context);
  typedef typename  ::mas::schema::registry::Registry<T>::CategoryInfoParams CategoryInfoParams;
  typedef ::capnp::CallContext<CategoryInfoParams,  ::mas::schema::common::IdInformation> CategoryInfoContext;
  virtual ::kj::Promise<void> categoryInfo(CategoryInfoContext context);
  typedef typename  ::mas::schema::registry::Registry<T>::EntriesParams EntriesParams;
  typedef typename  ::mas::schema::registry::Registry<T>::EntriesResults EntriesResults;
  typedef ::capnp::CallContext<EntriesParams, EntriesResults> EntriesContext;
  virtual ::kj::Promise<void> entries(EntriesContext context);

  inline typename  ::mas::schema::registry::Registry<T>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::registry::Registry<T>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename T>
class Registry<T>::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::Entry::Reader asRegistryGeneric() {
    return typename Registry<T2>::Entry::Reader(_reader);
  }

  inline Which which() const;
  inline bool hasCategoryId() const;
  inline  ::capnp::Text::Reader getCategoryId() const;

  inline bool isRef() const;
  inline bool hasRef() const;
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getRef() const;
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool isValue() const;
  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<T> getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Registry<T>::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::Entry::Builder asRegistryGeneric() {
    return typename Registry<T2>::Entry::Builder(_builder);
  }

  inline Which which();
  inline bool hasCategoryId();
  inline  ::capnp::Text::Builder getCategoryId();
  inline void setCategoryId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCategoryId(unsigned int size);
  inline void adoptCategoryId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCategoryId();

  inline bool isRef();
  inline bool hasRef();
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getRef();
  inline void setRef( ::mas::schema::common::Identifiable::Client&& value);
  inline void setRef( ::mas::schema::common::Identifiable::Client& value);
  inline void adoptRef(::capnp::Orphan< ::mas::schema::common::Identifiable>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Identifiable> disownRef();
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool isValue();
  inline bool hasValue();
  inline  ::capnp::BuilderFor<T> getValue();
  inline void setValue( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initValue();
  inline  ::capnp::BuilderFor<T> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Registry<T>::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Registry<T>::SupportedCategoriesParams::Reader {
public:
  typedef SupportedCategoriesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::SupportedCategoriesParams::Reader asRegistryGeneric() {
    return typename Registry<T2>::SupportedCategoriesParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Registry<T>::SupportedCategoriesParams::Builder {
public:
  typedef SupportedCategoriesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::SupportedCategoriesParams::Builder asRegistryGeneric() {
    return typename Registry<T2>::SupportedCategoriesParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Registry<T>::SupportedCategoriesParams::Pipeline {
public:
  typedef SupportedCategoriesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Registry<T>::SupportedCategoriesResults::Reader {
public:
  typedef SupportedCategoriesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::SupportedCategoriesResults::Reader asRegistryGeneric() {
    return typename Registry<T2>::SupportedCategoriesResults::Reader(_reader);
  }

  inline bool hasCats() const;
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader getCats() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Registry<T>::SupportedCategoriesResults::Builder {
public:
  typedef SupportedCategoriesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::SupportedCategoriesResults::Builder asRegistryGeneric() {
    return typename Registry<T2>::SupportedCategoriesResults::Builder(_builder);
  }

  inline bool hasCats();
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder getCats();
  inline void setCats( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder initCats(unsigned int size);
  inline void adoptCats(::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> disownCats();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Registry<T>::SupportedCategoriesResults::Pipeline {
public:
  typedef SupportedCategoriesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Registry<T>::CategoryInfoParams::Reader {
public:
  typedef CategoryInfoParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::CategoryInfoParams::Reader asRegistryGeneric() {
    return typename Registry<T2>::CategoryInfoParams::Reader(_reader);
  }

  inline bool hasCategoryId() const;
  inline  ::capnp::Text::Reader getCategoryId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Registry<T>::CategoryInfoParams::Builder {
public:
  typedef CategoryInfoParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::CategoryInfoParams::Builder asRegistryGeneric() {
    return typename Registry<T2>::CategoryInfoParams::Builder(_builder);
  }

  inline bool hasCategoryId();
  inline  ::capnp::Text::Builder getCategoryId();
  inline void setCategoryId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCategoryId(unsigned int size);
  inline void adoptCategoryId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCategoryId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Registry<T>::CategoryInfoParams::Pipeline {
public:
  typedef CategoryInfoParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Registry<T>::EntriesParams::Reader {
public:
  typedef EntriesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::EntriesParams::Reader asRegistryGeneric() {
    return typename Registry<T2>::EntriesParams::Reader(_reader);
  }

  inline bool hasCategoryId() const;
  inline  ::capnp::Text::Reader getCategoryId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Registry<T>::EntriesParams::Builder {
public:
  typedef EntriesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::EntriesParams::Builder asRegistryGeneric() {
    return typename Registry<T2>::EntriesParams::Builder(_builder);
  }

  inline bool hasCategoryId();
  inline  ::capnp::Text::Builder getCategoryId();
  inline void setCategoryId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCategoryId(unsigned int size);
  inline void adoptCategoryId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCategoryId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Registry<T>::EntriesParams::Pipeline {
public:
  typedef EntriesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Registry<T>::EntriesResults::Reader {
public:
  typedef EntriesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::EntriesResults::Reader asRegistryGeneric() {
    return typename Registry<T2>::EntriesResults::Reader(_reader);
  }

  inline bool hasEntries() const;
  inline typename  ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Registry<T>::EntriesResults::Builder {
public:
  typedef EntriesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Registry<T2>::EntriesResults::Builder asRegistryGeneric() {
    return typename Registry<T2>::EntriesResults::Builder(_builder);
  }

  inline bool hasEntries();
  inline typename  ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries(typename  ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>::Reader value);
  inline typename  ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Registry<T>::EntriesResults::Pipeline {
public:
  typedef EntriesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Registrar::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Registrar Calls;
  typedef Registrar Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::registry::Registrar::RegParams,  ::mas::schema::registry::Registrar::RegisterResults> registerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Registrar::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Registrar Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::registry::Registrar::RegisterResults RegisterResults;
  typedef ::capnp::CallContext< ::mas::schema::registry::Registrar::RegParams, RegisterResults> RegisterContext;
  virtual ::kj::Promise<void> register_(RegisterContext context);

  inline  ::mas::schema::registry::Registrar::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::registry::Registrar>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Registrar::CrossDomainRestore::Reader {
public:
  typedef CrossDomainRestore Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasVatId() const;
  inline  ::mas::schema::persistence::VatId::Reader getVatId() const;

  inline bool hasRestorer() const;
#if !CAPNP_LITE
  inline  ::mas::schema::persistence::Restorer::Client getRestorer() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Registrar::CrossDomainRestore::Builder {
public:
  typedef CrossDomainRestore Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasVatId();
  inline  ::mas::schema::persistence::VatId::Builder getVatId();
  inline void setVatId( ::mas::schema::persistence::VatId::Reader value);
  inline  ::mas::schema::persistence::VatId::Builder initVatId();
  inline void adoptVatId(::capnp::Orphan< ::mas::schema::persistence::VatId>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::VatId> disownVatId();

  inline bool hasRestorer();
#if !CAPNP_LITE
  inline  ::mas::schema::persistence::Restorer::Client getRestorer();
  inline void setRestorer( ::mas::schema::persistence::Restorer::Client&& value);
  inline void setRestorer( ::mas::schema::persistence::Restorer::Client& value);
  inline void adoptRestorer(::capnp::Orphan< ::mas::schema::persistence::Restorer>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::Restorer> disownRestorer();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Registrar::CrossDomainRestore::Pipeline {
public:
  typedef CrossDomainRestore Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::VatId::Pipeline getVatId();
  inline  ::mas::schema::persistence::Restorer::Client getRestorer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Registrar::RegParams::Reader {
public:
  typedef RegParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getCap() const;
#endif  // !CAPNP_LITE

  inline bool hasRegName() const;
  inline  ::capnp::Text::Reader getRegName() const;

  inline bool hasCategoryId() const;
  inline  ::capnp::Text::Reader getCategoryId() const;

  inline bool hasXDomain() const;
  inline  ::mas::schema::registry::Registrar::CrossDomainRestore::Reader getXDomain() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Registrar::RegParams::Builder {
public:
  typedef RegParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getCap();
  inline void setCap( ::mas::schema::common::Identifiable::Client&& value);
  inline void setCap( ::mas::schema::common::Identifiable::Client& value);
  inline void adoptCap(::capnp::Orphan< ::mas::schema::common::Identifiable>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Identifiable> disownCap();
#endif  // !CAPNP_LITE

  inline bool hasRegName();
  inline  ::capnp::Text::Builder getRegName();
  inline void setRegName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initRegName(unsigned int size);
  inline void adoptRegName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownRegName();

  inline bool hasCategoryId();
  inline  ::capnp::Text::Builder getCategoryId();
  inline void setCategoryId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCategoryId(unsigned int size);
  inline void adoptCategoryId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCategoryId();

  inline bool hasXDomain();
  inline  ::mas::schema::registry::Registrar::CrossDomainRestore::Builder getXDomain();
  inline void setXDomain( ::mas::schema::registry::Registrar::CrossDomainRestore::Reader value);
  inline  ::mas::schema::registry::Registrar::CrossDomainRestore::Builder initXDomain();
  inline void adoptXDomain(::capnp::Orphan< ::mas::schema::registry::Registrar::CrossDomainRestore>&& value);
  inline ::capnp::Orphan< ::mas::schema::registry::Registrar::CrossDomainRestore> disownXDomain();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Registrar::RegParams::Pipeline {
public:
  typedef RegParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Identifiable::Client getCap();
  inline  ::mas::schema::registry::Registrar::CrossDomainRestore::Pipeline getXDomain();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Registrar::Unregister::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Unregister Calls;
  typedef Unregister Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::registry::Registrar::Unregister::UnregisterParams,  ::mas::schema::registry::Registrar::Unregister::UnregisterResults> unregisterRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Registrar::Unregister::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Unregister Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::registry::Registrar::Unregister::UnregisterParams UnregisterParams;
  typedef  ::mas::schema::registry::Registrar::Unregister::UnregisterResults UnregisterResults;
  typedef ::capnp::CallContext<UnregisterParams, UnregisterResults> UnregisterContext;
  virtual ::kj::Promise<void> unregister(UnregisterContext context);

  inline  ::mas::schema::registry::Registrar::Unregister::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::registry::Registrar::Unregister>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Registrar::Unregister::UnregisterParams::Reader {
public:
  typedef UnregisterParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Registrar::Unregister::UnregisterParams::Builder {
public:
  typedef UnregisterParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Registrar::Unregister::UnregisterParams::Pipeline {
public:
  typedef UnregisterParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Registrar::Unregister::UnregisterResults::Reader {
public:
  typedef UnregisterResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Registrar::Unregister::UnregisterResults::Builder {
public:
  typedef UnregisterResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Registrar::Unregister::UnregisterResults::Pipeline {
public:
  typedef UnregisterResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Registrar::RegisterResults::Reader {
public:
  typedef RegisterResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasUnreg() const;
#if !CAPNP_LITE
  inline  ::mas::schema::registry::Registrar::Unregister::Client getUnreg() const;
#endif  // !CAPNP_LITE

  inline bool hasReregSR() const;
  inline  ::mas::schema::persistence::SturdyRef::Reader getReregSR() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Registrar::RegisterResults::Builder {
public:
  typedef RegisterResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUnreg();
#if !CAPNP_LITE
  inline  ::mas::schema::registry::Registrar::Unregister::Client getUnreg();
  inline void setUnreg( ::mas::schema::registry::Registrar::Unregister::Client&& value);
  inline void setUnreg( ::mas::schema::registry::Registrar::Unregister::Client& value);
  inline void adoptUnreg(::capnp::Orphan< ::mas::schema::registry::Registrar::Unregister>&& value);
  inline ::capnp::Orphan< ::mas::schema::registry::Registrar::Unregister> disownUnreg();
#endif  // !CAPNP_LITE

  inline bool hasReregSR();
  inline  ::mas::schema::persistence::SturdyRef::Builder getReregSR();
  inline void setReregSR( ::mas::schema::persistence::SturdyRef::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Builder initReregSR();
  inline void adoptReregSR(::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> disownReregSR();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Registrar::RegisterResults::Pipeline {
public:
  typedef RegisterResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::registry::Registrar::Unregister::Client getUnreg();
  inline  ::mas::schema::persistence::SturdyRef::Pipeline getReregSR();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Admin::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Admin::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Admin::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Admin::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Admin::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::registry::Admin::Client& Admin::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::registry::Admin::Client& Admin::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Admin::AddCategoryParams::Reader::hasCategory() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::AddCategoryParams::Builder::hasCategory() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::IdInformation::Reader Admin::AddCategoryParams::Reader::getCategory() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::IdInformation::Builder Admin::AddCategoryParams::Builder::getCategory() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::IdInformation::Pipeline Admin::AddCategoryParams::Pipeline::getCategory() {
  return  ::mas::schema::common::IdInformation::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Admin::AddCategoryParams::Builder::setCategory( ::mas::schema::common::IdInformation::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::IdInformation::Builder Admin::AddCategoryParams::Builder::initCategory() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Admin::AddCategoryParams::Builder::adoptCategory(
    ::capnp::Orphan< ::mas::schema::common::IdInformation>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::IdInformation> Admin::AddCategoryParams::Builder::disownCategory() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Admin::AddCategoryParams::Reader::getUpsert() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Admin::AddCategoryParams::Builder::getUpsert() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Admin::AddCategoryParams::Builder::setUpsert(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Admin::AddCategoryResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Admin::AddCategoryResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Admin::AddCategoryResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Admin::RemoveCategoryParams::Reader::hasCategoryId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::RemoveCategoryParams::Builder::hasCategoryId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Admin::RemoveCategoryParams::Reader::getCategoryId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Admin::RemoveCategoryParams::Builder::getCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Admin::RemoveCategoryParams::Builder::setCategoryId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Admin::RemoveCategoryParams::Builder::initCategoryId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Admin::RemoveCategoryParams::Builder::adoptCategoryId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Admin::RemoveCategoryParams::Builder::disownCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Admin::RemoveCategoryParams::Reader::hasMoveObjectsToCategoryId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::RemoveCategoryParams::Builder::hasMoveObjectsToCategoryId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Admin::RemoveCategoryParams::Reader::getMoveObjectsToCategoryId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Admin::RemoveCategoryParams::Builder::getMoveObjectsToCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Admin::RemoveCategoryParams::Builder::setMoveObjectsToCategoryId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Admin::RemoveCategoryParams::Builder::initMoveObjectsToCategoryId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Admin::RemoveCategoryParams::Builder::adoptMoveObjectsToCategoryId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Admin::RemoveCategoryParams::Builder::disownMoveObjectsToCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Admin::RemoveCategoryResults::Reader::hasRemovedObjects() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::RemoveCategoryResults::Builder::hasRemovedObjects() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader Admin::RemoveCategoryResults::Reader::getRemovedObjects() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder Admin::RemoveCategoryResults::Builder::getRemovedObjects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Admin::RemoveCategoryResults::Builder::setRemovedObjects( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder Admin::RemoveCategoryResults::Builder::initRemovedObjects(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Admin::RemoveCategoryResults::Builder::adoptRemovedObjects(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> Admin::RemoveCategoryResults::Builder::disownRemovedObjects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Admin::MoveObjectsParams::Reader::hasObjectIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::MoveObjectsParams::Builder::hasObjectIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Admin::MoveObjectsParams::Reader::getObjectIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Admin::MoveObjectsParams::Builder::getObjectIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Admin::MoveObjectsParams::Builder::setObjectIds( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Admin::MoveObjectsParams::Builder::setObjectIds(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Admin::MoveObjectsParams::Builder::initObjectIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Admin::MoveObjectsParams::Builder::adoptObjectIds(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Admin::MoveObjectsParams::Builder::disownObjectIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Admin::MoveObjectsParams::Reader::hasToCatId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::MoveObjectsParams::Builder::hasToCatId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Admin::MoveObjectsParams::Reader::getToCatId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Admin::MoveObjectsParams::Builder::getToCatId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Admin::MoveObjectsParams::Builder::setToCatId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Admin::MoveObjectsParams::Builder::initToCatId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Admin::MoveObjectsParams::Builder::adoptToCatId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Admin::MoveObjectsParams::Builder::disownToCatId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Admin::MoveObjectsResults::Reader::hasMovedObjectIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::MoveObjectsResults::Builder::hasMovedObjectIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Admin::MoveObjectsResults::Reader::getMovedObjectIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Admin::MoveObjectsResults::Builder::getMovedObjectIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Admin::MoveObjectsResults::Builder::setMovedObjectIds( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Admin::MoveObjectsResults::Builder::setMovedObjectIds(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Admin::MoveObjectsResults::Builder::initMovedObjectIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Admin::MoveObjectsResults::Builder::adoptMovedObjectIds(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Admin::MoveObjectsResults::Builder::disownMovedObjectIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Admin::RemoveObjectsParams::Reader::hasObjectIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::RemoveObjectsParams::Builder::hasObjectIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Admin::RemoveObjectsParams::Reader::getObjectIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Admin::RemoveObjectsParams::Builder::getObjectIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Admin::RemoveObjectsParams::Builder::setObjectIds( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Admin::RemoveObjectsParams::Builder::setObjectIds(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Admin::RemoveObjectsParams::Builder::initObjectIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Admin::RemoveObjectsParams::Builder::adoptObjectIds(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Admin::RemoveObjectsParams::Builder::disownObjectIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Admin::RemoveObjectsResults::Reader::hasRemovedObjects() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::RemoveObjectsResults::Builder::hasRemovedObjects() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader Admin::RemoveObjectsResults::Reader::getRemovedObjects() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder Admin::RemoveObjectsResults::Builder::getRemovedObjects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Admin::RemoveObjectsResults::Builder::setRemovedObjects( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder Admin::RemoveObjectsResults::Builder::initRemovedObjects(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Admin::RemoveObjectsResults::Builder::adoptRemovedObjects(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> Admin::RemoveObjectsResults::Builder::disownRemovedObjects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Admin::RegistryResults::Reader::hasRegistry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::RegistryResults::Builder::hasRegistry() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client Admin::RegistryResults::Reader::getRegistry() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registry< ::capnp::AnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client Admin::RegistryResults::Builder::getRegistry() {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registry< ::capnp::AnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client Admin::RegistryResults::Pipeline::getRegistry() {
  return  ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client(_typeless.getPointerField(0).asCap());
}
inline void Admin::RegistryResults::Builder::setRegistry( ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::registry::Registry< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Admin::RegistryResults::Builder::setRegistry( ::mas::schema::registry::Registry< ::capnp::AnyPointer>::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::registry::Registry< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Admin::RegistryResults::Builder::adoptRegistry(
    ::capnp::Orphan< ::mas::schema::registry::Registry< ::capnp::AnyPointer>>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::registry::Registry< ::capnp::AnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::registry::Registry< ::capnp::AnyPointer>> Admin::RegistryResults::Builder::disownRegistry() {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registry< ::capnp::AnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
inline Registry<T>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename T>
inline Registry<T>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename T>
template <typename _t, typename>
inline Registry<T>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename T>
template <typename _t, typename>
inline Registry<T>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename T>
inline Registry<T>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename T>
inline typename  ::mas::schema::registry::Registry<T>::Client& Registry<T>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename T>
inline typename  ::mas::schema::registry::Registry<T>::Client& Registry<T>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename T>
inline typename  ::mas::schema::registry::Registry<T>::Entry::Which Registry<T>::Entry::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename T>
inline typename  ::mas::schema::registry::Registry<T>::Entry::Which Registry<T>::Entry::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename T>
inline bool Registry<T>::Entry::Reader::hasCategoryId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Registry<T>::Entry::Builder::hasCategoryId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::Text::Reader Registry<T>::Entry::Reader::getCategoryId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::Text::Builder Registry<T>::Entry::Builder::getCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void Registry<T>::Entry::Builder::setCategoryId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::Text::Builder Registry<T>::Entry::Builder::initCategoryId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Registry<T>::Entry::Builder::adoptCategoryId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::Text> Registry<T>::Entry::Builder::disownCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename T>
inline bool Registry<T>::Entry::Reader::isRef() const {
  return which() == Registry<T>::Entry::REF;
}
template <typename T>
inline bool Registry<T>::Entry::Builder::isRef() {
  return which() == Registry<T>::Entry::REF;
}
template <typename T>
inline bool Registry<T>::Entry::Reader::hasRef() const {
  if (which() != Registry<T>::Entry::REF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Registry<T>::Entry::Builder::hasRef() {
  if (which() != Registry<T>::Entry::REF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename T>
inline  ::mas::schema::common::Identifiable::Client Registry<T>::Entry::Reader::getRef() const {
  KJ_IREQUIRE((which() == Registry<T>::Entry::REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::mas::schema::common::Identifiable::Client Registry<T>::Entry::Builder::getRef() {
  KJ_IREQUIRE((which() == Registry<T>::Entry::REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline void Registry<T>::Entry::Builder::setRef( ::mas::schema::common::Identifiable::Client&& cap) {
  _builder.setDataField<Registry<T>::Entry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Registry<T>::Entry::REF);
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename T>
inline void Registry<T>::Entry::Builder::setRef( ::mas::schema::common::Identifiable::Client& cap) {
  _builder.setDataField<Registry<T>::Entry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Registry<T>::Entry::REF);
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
template <typename T>
inline void Registry<T>::Entry::Builder::adoptRef(
    ::capnp::Orphan< ::mas::schema::common::Identifiable>&& value) {
  _builder.setDataField<Registry<T>::Entry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Registry<T>::Entry::REF);
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::mas::schema::common::Identifiable> Registry<T>::Entry::Builder::disownRef() {
  KJ_IREQUIRE((which() == Registry<T>::Entry::REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename T>
inline bool Registry<T>::Entry::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Registry<T>::Entry::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::Text::Reader Registry<T>::Entry::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::Text::Builder Registry<T>::Entry::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename T>
inline void Registry<T>::Entry::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::Text::Builder Registry<T>::Entry::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Registry<T>::Entry::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::Text> Registry<T>::Entry::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

template <typename T>
inline bool Registry<T>::Entry::Reader::isValue() const {
  return which() == Registry<T>::Entry::VALUE;
}
template <typename T>
inline bool Registry<T>::Entry::Builder::isValue() {
  return which() == Registry<T>::Entry::VALUE;
}
template <typename T>
inline bool Registry<T>::Entry::Reader::hasValue() const {
  if (which() != Registry<T>::Entry::VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Registry<T>::Entry::Builder::hasValue() {
  if (which() != Registry<T>::Entry::VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::ReaderFor<T> Registry<T>::Entry::Reader::getValue() const {
  KJ_IREQUIRE((which() == Registry<T>::Entry::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> Registry<T>::Entry::Builder::getValue() {
  KJ_IREQUIRE((which() == Registry<T>::Entry::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline void Registry<T>::Entry::Builder::setValue( ::capnp::ReaderFor<T> value) {
  _builder.setDataField<Registry<T>::Entry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Registry<T>::Entry::VALUE);
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::BuilderFor<T> Registry<T>::Entry::Builder::initValue() {
  _builder.setDataField<Registry<T>::Entry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Registry<T>::Entry::VALUE);
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> Registry<T>::Entry::Builder::initValue(unsigned int size) {
  _builder.setDataField<Registry<T>::Entry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Registry<T>::Entry::VALUE);
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Registry<T>::Entry::Builder::adoptValue(
    ::capnp::Orphan<T>&& value) {
  _builder.setDataField<Registry<T>::Entry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Registry<T>::Entry::VALUE);
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan<T> Registry<T>::Entry::Builder::disownValue() {
  KJ_IREQUIRE((which() == Registry<T>::Entry::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Registry<T>::Entry
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Registry<T>::Entry::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Registry<T>::Entry::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Registry<T>::Entry::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Registry<T>::Entry::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Registry<T>::Entry::_capnpPrivate::brandScopes[] = {
  { 0xca7b4bd1600633b8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Registry<T>::Entry::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Registry<T>::Entry::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c17987510cf7ac13, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Registry<T>::SupportedCategoriesParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Registry<T>::SupportedCategoriesParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Registry<T>::SupportedCategoriesParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Registry<T>::SupportedCategoriesParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Registry<T>::SupportedCategoriesParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Registry<T>::SupportedCategoriesParams::_capnpPrivate::brandScopes[] = {
  { 0xca7b4bd1600633b8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Registry<T>::SupportedCategoriesParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Registry<T>::SupportedCategoriesParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9c49e6e65e34c29b, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool Registry<T>::SupportedCategoriesResults::Reader::hasCats() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Registry<T>::SupportedCategoriesResults::Builder::hasCats() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader Registry<T>::SupportedCategoriesResults::Reader::getCats() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder Registry<T>::SupportedCategoriesResults::Builder::getCats() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void Registry<T>::SupportedCategoriesResults::Builder::setCats( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder Registry<T>::SupportedCategoriesResults::Builder::initCats(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Registry<T>::SupportedCategoriesResults::Builder::adoptCats(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> Registry<T>::SupportedCategoriesResults::Builder::disownCats() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Registry<T>::SupportedCategoriesResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Registry<T>::SupportedCategoriesResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Registry<T>::SupportedCategoriesResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Registry<T>::SupportedCategoriesResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Registry<T>::SupportedCategoriesResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Registry<T>::SupportedCategoriesResults::_capnpPrivate::brandScopes[] = {
  { 0xca7b4bd1600633b8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Registry<T>::SupportedCategoriesResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Registry<T>::SupportedCategoriesResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b2bf60b5817330b0, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool Registry<T>::CategoryInfoParams::Reader::hasCategoryId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Registry<T>::CategoryInfoParams::Builder::hasCategoryId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::Text::Reader Registry<T>::CategoryInfoParams::Reader::getCategoryId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::Text::Builder Registry<T>::CategoryInfoParams::Builder::getCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void Registry<T>::CategoryInfoParams::Builder::setCategoryId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::Text::Builder Registry<T>::CategoryInfoParams::Builder::initCategoryId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Registry<T>::CategoryInfoParams::Builder::adoptCategoryId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::Text> Registry<T>::CategoryInfoParams::Builder::disownCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Registry<T>::CategoryInfoParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Registry<T>::CategoryInfoParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Registry<T>::CategoryInfoParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Registry<T>::CategoryInfoParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Registry<T>::CategoryInfoParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Registry<T>::CategoryInfoParams::_capnpPrivate::brandScopes[] = {
  { 0xca7b4bd1600633b8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Registry<T>::CategoryInfoParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Registry<T>::CategoryInfoParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_891283e1b248bc9d, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool Registry<T>::EntriesParams::Reader::hasCategoryId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Registry<T>::EntriesParams::Builder::hasCategoryId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::Text::Reader Registry<T>::EntriesParams::Reader::getCategoryId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::Text::Builder Registry<T>::EntriesParams::Builder::getCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void Registry<T>::EntriesParams::Builder::setCategoryId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::Text::Builder Registry<T>::EntriesParams::Builder::initCategoryId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Registry<T>::EntriesParams::Builder::adoptCategoryId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::Text> Registry<T>::EntriesParams::Builder::disownCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Registry<T>::EntriesParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Registry<T>::EntriesParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Registry<T>::EntriesParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Registry<T>::EntriesParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Registry<T>::EntriesParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Registry<T>::EntriesParams::_capnpPrivate::brandScopes[] = {
  { 0xca7b4bd1600633b8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Registry<T>::EntriesParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Registry<T>::EntriesParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9ffc53716151c5fa, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool Registry<T>::EntriesResults::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Registry<T>::EntriesResults::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline typename  ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>::Reader Registry<T>::EntriesResults::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>::Builder Registry<T>::EntriesResults::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void Registry<T>::EntriesResults::Builder::setEntries(typename  ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline typename  ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>::Builder Registry<T>::EntriesResults::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Registry<T>::EntriesResults::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>> Registry<T>::EntriesResults::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::mas::schema::registry::Registry<T>::Entry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Registry<T>::EntriesResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Registry<T>::EntriesResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Registry<T>::EntriesResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Registry<T>::EntriesResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Registry<T>::EntriesResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Registry<T>::EntriesResults::_capnpPrivate::brandScopes[] = {
  { 0xca7b4bd1600633b8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Registry<T>::EntriesResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency Registry<T>::EntriesResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::registry::Registry<T>::Entry::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema Registry<T>::EntriesResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e4eaf56eb486064d, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesParams, typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesResults>)
Registry<T>::Client::supportedCategoriesRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesParams, typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesResults>(
      0xca7b4bd1600633b8ull, 0, sizeHint, {true});
}
template <typename T>
::kj::Promise<void> Registry<T>::Server::supportedCategories(SupportedCategoriesContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "registry.capnp:Registry", "supportedCategories",
      0xca7b4bd1600633b8ull, 0);
}
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::registry::Registry<T>::CategoryInfoParams,  ::mas::schema::common::IdInformation>)
Registry<T>::Client::categoryInfoRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::registry::Registry<T>::CategoryInfoParams,  ::mas::schema::common::IdInformation>(
      0xca7b4bd1600633b8ull, 1, sizeHint, {true});
}
template <typename T>
::kj::Promise<void> Registry<T>::Server::categoryInfo(CategoryInfoContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "registry.capnp:Registry", "categoryInfo",
      0xca7b4bd1600633b8ull, 1);
}
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::registry::Registry<T>::EntriesParams, typename  ::mas::schema::registry::Registry<T>::EntriesResults>)
Registry<T>::Client::entriesRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::registry::Registry<T>::EntriesParams, typename  ::mas::schema::registry::Registry<T>::EntriesResults>(
      0xca7b4bd1600633b8ull, 2, sizeHint, {false});
}
template <typename T>
::kj::Promise<void> Registry<T>::Server::entries(EntriesContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "registry.capnp:Registry", "entries",
      0xca7b4bd1600633b8ull, 2);
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult Registry<T>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xca7b4bd1600633b8ull:
      return dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("registry.capnp:Registry", interfaceId);
  }
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult Registry<T>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        supportedCategories(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesParams, typename  ::mas::schema::registry::Registry<T>::SupportedCategoriesResults>(context)),
        false,
        false
      };
    case 1:
      return {
        categoryInfo(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::registry::Registry<T>::CategoryInfoParams,  ::mas::schema::common::IdInformation>(context)),
        false,
        false
      };
    case 2:
      return {
        entries(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::registry::Registry<T>::EntriesParams, typename  ::mas::schema::registry::Registry<T>::EntriesResults>(context)),
        false,
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "registry.capnp:Registry",
          0xca7b4bd1600633b8ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Registry<T>
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Registry<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Registry<T>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Registry<T>::_capnpPrivate::brandScopes[] = {
  { 0xca7b4bd1600633b8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Registry<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency Registry<T>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::registry::Registry<T>::SupportedCategoriesParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::registry::Registry<T>::CategoryInfoParams::_capnpPrivate::brand() },
  { 33554434,  ::mas::schema::registry::Registry<T>::EntriesParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::registry::Registry<T>::SupportedCategoriesResults::_capnpPrivate::brand() },
  { 50331650,  ::mas::schema::registry::Registry<T>::EntriesResults::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema Registry<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ca7b4bd1600633b8, brandScopes, brandDependencies,
  1, 5, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline Registrar::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Registrar::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Registrar::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Registrar::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Registrar::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::registry::Registrar::Client& Registrar::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::registry::Registrar::Client& Registrar::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Registrar::CrossDomainRestore::Reader::hasVatId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Registrar::CrossDomainRestore::Builder::hasVatId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::VatId::Reader Registrar::CrossDomainRestore::Reader::getVatId() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::VatId::Builder Registrar::CrossDomainRestore::Builder::getVatId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::VatId::Pipeline Registrar::CrossDomainRestore::Pipeline::getVatId() {
  return  ::mas::schema::persistence::VatId::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Registrar::CrossDomainRestore::Builder::setVatId( ::mas::schema::persistence::VatId::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::VatId::Builder Registrar::CrossDomainRestore::Builder::initVatId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Registrar::CrossDomainRestore::Builder::adoptVatId(
    ::capnp::Orphan< ::mas::schema::persistence::VatId>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::VatId> Registrar::CrossDomainRestore::Builder::disownVatId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Registrar::CrossDomainRestore::Reader::hasRestorer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Registrar::CrossDomainRestore::Builder::hasRestorer() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::Restorer::Client Registrar::CrossDomainRestore::Reader::getRestorer() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Restorer>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::Restorer::Client Registrar::CrossDomainRestore::Builder::getRestorer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Restorer>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::Restorer::Client Registrar::CrossDomainRestore::Pipeline::getRestorer() {
  return  ::mas::schema::persistence::Restorer::Client(_typeless.getPointerField(1).asCap());
}
inline void Registrar::CrossDomainRestore::Builder::setRestorer( ::mas::schema::persistence::Restorer::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::Restorer>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Registrar::CrossDomainRestore::Builder::setRestorer( ::mas::schema::persistence::Restorer::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::Restorer>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void Registrar::CrossDomainRestore::Builder::adoptRestorer(
    ::capnp::Orphan< ::mas::schema::persistence::Restorer>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::Restorer>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::Restorer> Registrar::CrossDomainRestore::Builder::disownRestorer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Restorer>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Registrar::RegParams::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Registrar::RegParams::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Identifiable::Client Registrar::RegParams::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Identifiable::Client Registrar::RegParams::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Identifiable::Client Registrar::RegParams::Pipeline::getCap() {
  return  ::mas::schema::common::Identifiable::Client(_typeless.getPointerField(0).asCap());
}
inline void Registrar::RegParams::Builder::setCap( ::mas::schema::common::Identifiable::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Registrar::RegParams::Builder::setCap( ::mas::schema::common::Identifiable::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Registrar::RegParams::Builder::adoptCap(
    ::capnp::Orphan< ::mas::schema::common::Identifiable>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Identifiable> Registrar::RegParams::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Registrar::RegParams::Reader::hasRegName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Registrar::RegParams::Builder::hasRegName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Registrar::RegParams::Reader::getRegName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Registrar::RegParams::Builder::getRegName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Registrar::RegParams::Builder::setRegName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Registrar::RegParams::Builder::initRegName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Registrar::RegParams::Builder::adoptRegName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Registrar::RegParams::Builder::disownRegName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Registrar::RegParams::Reader::hasCategoryId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Registrar::RegParams::Builder::hasCategoryId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Registrar::RegParams::Reader::getCategoryId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Registrar::RegParams::Builder::getCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Registrar::RegParams::Builder::setCategoryId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Registrar::RegParams::Builder::initCategoryId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Registrar::RegParams::Builder::adoptCategoryId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Registrar::RegParams::Builder::disownCategoryId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Registrar::RegParams::Reader::hasXDomain() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Registrar::RegParams::Builder::hasXDomain() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::registry::Registrar::CrossDomainRestore::Reader Registrar::RegParams::Reader::getXDomain() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::CrossDomainRestore>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::mas::schema::registry::Registrar::CrossDomainRestore::Builder Registrar::RegParams::Builder::getXDomain() {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::CrossDomainRestore>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::registry::Registrar::CrossDomainRestore::Pipeline Registrar::RegParams::Pipeline::getXDomain() {
  return  ::mas::schema::registry::Registrar::CrossDomainRestore::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Registrar::RegParams::Builder::setXDomain( ::mas::schema::registry::Registrar::CrossDomainRestore::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::CrossDomainRestore>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::registry::Registrar::CrossDomainRestore::Builder Registrar::RegParams::Builder::initXDomain() {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::CrossDomainRestore>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Registrar::RegParams::Builder::adoptXDomain(
    ::capnp::Orphan< ::mas::schema::registry::Registrar::CrossDomainRestore>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::CrossDomainRestore>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::registry::Registrar::CrossDomainRestore> Registrar::RegParams::Builder::disownXDomain() {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::CrossDomainRestore>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Registrar::Unregister::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Registrar::Unregister::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Registrar::Unregister::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Registrar::Unregister::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Registrar::Unregister::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::registry::Registrar::Unregister::Client& Registrar::Unregister::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::registry::Registrar::Unregister::Client& Registrar::Unregister::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Registrar::Unregister::UnregisterResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Registrar::Unregister::UnregisterResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Registrar::Unregister::UnregisterResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Registrar::RegisterResults::Reader::hasUnreg() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Registrar::RegisterResults::Builder::hasUnreg() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::registry::Registrar::Unregister::Client Registrar::RegisterResults::Reader::getUnreg() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::Unregister>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::registry::Registrar::Unregister::Client Registrar::RegisterResults::Builder::getUnreg() {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::Unregister>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::registry::Registrar::Unregister::Client Registrar::RegisterResults::Pipeline::getUnreg() {
  return  ::mas::schema::registry::Registrar::Unregister::Client(_typeless.getPointerField(0).asCap());
}
inline void Registrar::RegisterResults::Builder::setUnreg( ::mas::schema::registry::Registrar::Unregister::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Registrar::RegisterResults::Builder::setUnreg( ::mas::schema::registry::Registrar::Unregister::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Registrar::RegisterResults::Builder::adoptUnreg(
    ::capnp::Orphan< ::mas::schema::registry::Registrar::Unregister>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::Unregister>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::registry::Registrar::Unregister> Registrar::RegisterResults::Builder::disownUnreg() {
  return ::capnp::_::PointerHelpers< ::mas::schema::registry::Registrar::Unregister>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Registrar::RegisterResults::Reader::hasReregSR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Registrar::RegisterResults::Builder::hasReregSR() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Reader Registrar::RegisterResults::Reader::getReregSR() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Builder Registrar::RegisterResults::Builder::getReregSR() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Pipeline Registrar::RegisterResults::Pipeline::getReregSR() {
  return  ::mas::schema::persistence::SturdyRef::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Registrar::RegisterResults::Builder::setReregSR( ::mas::schema::persistence::SturdyRef::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Builder Registrar::RegisterResults::Builder::initReregSR() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Registrar::RegisterResults::Builder::adoptReregSR(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> Registrar::RegisterResults::Builder::disownReregSR() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

