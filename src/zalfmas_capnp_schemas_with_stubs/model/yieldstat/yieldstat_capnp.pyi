"""This is an automatically generated stub for `yieldstat.capnp`."""

from __future__ import annotations

from collections.abc import Iterator, Sequence
from contextlib import contextmanager
from enum import Enum
from io import BufferedWriter
from typing import Any, BinaryIO, Literal

from capnp import _DynamicListBuilder

class ResultId(Enum):
    primaryYield = "primaryYield"
    dryMatter = "dryMatter"
    carbonInAboveGroundBiomass = "carbonInAboveGroundBiomass"
    sumFertilizer = "sumFertilizer"
    sumIrrigation = "sumIrrigation"
    primaryYieldCU = "primaryYieldCU"

class RestInput:
    @property
    def useDevTrend(self) -> bool: ...
    @property
    def useCO2Increase(self) -> bool: ...
    @property
    def dgm(self) -> float: ...
    @property
    def hft(self) -> int: ...
    @property
    def nft(self) -> int: ...
    @property
    def sft(self) -> int: ...
    @property
    def slope(self) -> int: ...
    @property
    def steino(self) -> int: ...
    @property
    def az(self) -> int: ...
    @property
    def klz(self) -> int: ...
    @property
    def stt(self) -> int: ...
    @property
    def germanFederalStates(self) -> int: ...
    @property
    def getDryYearWaterNeed(self) -> bool: ...
    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[RestInputReader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RestInputReader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        useDevTrend: bool | None = None,
        useCO2Increase: bool | None = None,
        dgm: float | None = None,
        hft: int | None = None,
        nft: int | None = None,
        sft: int | None = None,
        slope: int | None = None,
        steino: int | None = None,
        az: int | None = None,
        klz: int | None = None,
        stt: int | None = None,
        germanFederalStates: int | None = None,
        getDryYearWaterNeed: bool | None = None,
    ) -> RestInputBuilder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RestInputReader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RestInputReader: ...
    def to_dict(self) -> dict[str, Any]: ...

class RestInputReader(RestInput):
    def as_builder(self) -> RestInputBuilder: ...

class RestInputBuilder(RestInput):
    @property
    def useDevTrend(self) -> bool: ...
    @useDevTrend.setter
    def useDevTrend(self, value: bool) -> None: ...
    @property
    def useCO2Increase(self) -> bool: ...
    @useCO2Increase.setter
    def useCO2Increase(self, value: bool) -> None: ...
    @property
    def dgm(self) -> float: ...
    @dgm.setter
    def dgm(self, value: float) -> None: ...
    @property
    def hft(self) -> int: ...
    @hft.setter
    def hft(self, value: int) -> None: ...
    @property
    def nft(self) -> int: ...
    @nft.setter
    def nft(self, value: int) -> None: ...
    @property
    def sft(self) -> int: ...
    @sft.setter
    def sft(self, value: int) -> None: ...
    @property
    def slope(self) -> int: ...
    @slope.setter
    def slope(self, value: int) -> None: ...
    @property
    def steino(self) -> int: ...
    @steino.setter
    def steino(self, value: int) -> None: ...
    @property
    def az(self) -> int: ...
    @az.setter
    def az(self, value: int) -> None: ...
    @property
    def klz(self) -> int: ...
    @klz.setter
    def klz(self, value: int) -> None: ...
    @property
    def stt(self) -> int: ...
    @stt.setter
    def stt(self, value: int) -> None: ...
    @property
    def germanFederalStates(self) -> int: ...
    @germanFederalStates.setter
    def germanFederalStates(self, value: int) -> None: ...
    @property
    def getDryYearWaterNeed(self) -> bool: ...
    @getDryYearWaterNeed.setter
    def getDryYearWaterNeed(self, value: bool) -> None: ...
    @staticmethod
    def from_dict(dictionary: dict[str, Any]) -> RestInputBuilder: ...
    def copy(self) -> RestInputBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> RestInputReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...

class Result:
    class ResultToValue:
        @property
        def id(self) -> ResultId: ...
        @property
        def value(self) -> float: ...
        @staticmethod
        @contextmanager
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[Result.ResultToValueReader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Result.ResultToValueReader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            id: ResultId
            | Literal[
                "primaryYield",
                "dryMatter",
                "carbonInAboveGroundBiomass",
                "sumFertilizer",
                "sumIrrigation",
                "primaryYieldCU",
            ]
            | None = None,
            value: float | None = None,
        ) -> Result.ResultToValueBuilder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Result.ResultToValueReader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Result.ResultToValueReader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class ResultToValueReader(Result.ResultToValue):
        def as_builder(self) -> Result.ResultToValueBuilder: ...

    class ResultToValueBuilder(Result.ResultToValue):
        @property
        def id(self) -> ResultId: ...
        @id.setter
        def id(
            self,
            value: ResultId
            | Literal[
                "primaryYield",
                "dryMatter",
                "carbonInAboveGroundBiomass",
                "sumFertilizer",
                "sumIrrigation",
                "primaryYieldCU",
            ],
        ) -> None: ...
        @property
        def value(self) -> float: ...
        @value.setter
        def value(self, value: float) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Result.ResultToValueBuilder: ...
        def copy(self) -> Result.ResultToValueBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Result.ResultToValueReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @property
    def cultivar(self) -> str: ...
    @property
    def isNoData(self) -> bool: ...
    @property
    def values(self) -> Sequence[Result.ResultToValue]: ...
    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[ResultReader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> ResultReader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        cultivar: str | None = None,
        isNoData: bool | None = None,
        values: Sequence[Result.ResultToValueBuilder]
        | Sequence[dict[str, Any]]
        | None = None,
    ) -> ResultBuilder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> ResultReader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> ResultReader: ...
    def to_dict(self) -> dict[str, Any]: ...

class ResultReader(Result):
    @property
    def values(self) -> Sequence[Result.ResultToValueReader]: ...
    def as_builder(self) -> ResultBuilder: ...

class ResultBuilder(Result):
    @property
    def cultivar(self) -> str: ...
    @cultivar.setter
    def cultivar(self, value: str) -> None: ...
    @property
    def isNoData(self) -> bool: ...
    @isNoData.setter
    def isNoData(self, value: bool) -> None: ...
    @property
    def values(self) -> Sequence[Result.ResultToValueBuilder]: ...
    @values.setter
    def values(
        self,
        value: Sequence[
            Result.ResultToValue
            | Result.ResultToValueBuilder
            | Result.ResultToValueReader
        ]
        | Sequence[dict[str, Any]],
    ) -> None: ...
    @staticmethod
    def from_dict(dictionary: dict[str, Any]) -> ResultBuilder: ...
    def init(
        self, name: Literal["values"], size: int = ...
    ) -> _DynamicListBuilder[Result.ResultToValueBuilder]: ...
    def copy(self) -> ResultBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> ResultReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...

class Output:
    class YearToResult:
        @property
        def year(self) -> int: ...
        @property
        def result(self) -> Result: ...
        def init(self, name: Literal["result"]) -> Result: ...
        @staticmethod
        @contextmanager
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[Output.YearToResultReader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Output.YearToResultReader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            year: int | None = None,
            result: ResultBuilder | dict[str, Any] | None = None,
        ) -> Output.YearToResultBuilder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Output.YearToResultReader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Output.YearToResultReader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class YearToResultReader(Output.YearToResult):
        @property
        def result(self) -> ResultReader: ...
        def as_builder(self) -> Output.YearToResultBuilder: ...

    class YearToResultBuilder(Output.YearToResult):
        @property
        def year(self) -> int: ...
        @year.setter
        def year(self, value: int) -> None: ...
        @property
        def result(self) -> ResultBuilder: ...
        @result.setter
        def result(
            self, value: Result | ResultBuilder | ResultReader | dict[str, Any]
        ) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Output.YearToResultBuilder: ...
        def init(self, name: Literal["result"]) -> ResultBuilder: ...
        def copy(self) -> Output.YearToResultBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Output.YearToResultReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @property
    def id(self) -> str: ...
    @property
    def runFailed(self) -> bool: ...
    @property
    def reason(self) -> str: ...
    @property
    def results(self) -> Sequence[Output.YearToResult]: ...
    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[OutputReader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> OutputReader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        id: str | None = None,
        runFailed: bool | None = None,
        reason: str | None = None,
        results: Sequence[Output.YearToResultBuilder]
        | Sequence[dict[str, Any]]
        | None = None,
    ) -> OutputBuilder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> OutputReader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> OutputReader: ...
    def to_dict(self) -> dict[str, Any]: ...

class OutputReader(Output):
    @property
    def results(self) -> Sequence[Output.YearToResultReader]: ...
    def as_builder(self) -> OutputBuilder: ...

class OutputBuilder(Output):
    @property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @property
    def runFailed(self) -> bool: ...
    @runFailed.setter
    def runFailed(self, value: bool) -> None: ...
    @property
    def reason(self) -> str: ...
    @reason.setter
    def reason(self, value: str) -> None: ...
    @property
    def results(self) -> Sequence[Output.YearToResultBuilder]: ...
    @results.setter
    def results(
        self,
        value: Sequence[
            Output.YearToResult | Output.YearToResultBuilder | Output.YearToResultReader
        ]
        | Sequence[dict[str, Any]],
    ) -> None: ...
    @staticmethod
    def from_dict(dictionary: dict[str, Any]) -> OutputBuilder: ...
    def init(
        self, name: Literal["results"], size: int = ...
    ) -> _DynamicListBuilder[Output.YearToResultBuilder]: ...
    def copy(self) -> OutputBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> OutputReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
