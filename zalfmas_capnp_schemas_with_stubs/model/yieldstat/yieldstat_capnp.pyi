"""This is an automatically generated stub for `yieldstat.capnp`."""

from __future__ import annotations

from collections.abc import MutableSequence, Sequence
from enum import Enum
from typing import Any, Literal, TypeAlias, override

from capnp.lib.capnp import (
    _DynamicCapabilityClient,
    _DynamicCapabilityServer,
    _DynamicStructBuilder,
    _DynamicStructReader,
    _InterfaceModule,
    _Request,
    _StructModule,
)

class _ResultIdModule(Enum):
    primaryYield = 0
    dryMatter = 1
    carbonInAboveGroundBiomass = 2
    sumFertilizer = 3
    sumIrrigation = 4
    primaryYieldCU = 5

ResultId: TypeAlias = _ResultIdModule

class _RestInputModule(_StructModule):
    class Reader(_DynamicStructReader):
        @property
        def useDevTrend(self) -> bool: ...
        @property
        def useCO2Increase(self) -> bool: ...
        @property
        def dgm(self) -> float: ...
        @property
        def hft(self) -> int: ...
        @property
        def nft(self) -> int: ...
        @property
        def sft(self) -> int: ...
        @property
        def slope(self) -> int: ...
        @property
        def steino(self) -> int: ...
        @property
        def az(self) -> int: ...
        @property
        def klz(self) -> int: ...
        @property
        def stt(self) -> int: ...
        @property
        def germanFederalStates(self) -> int: ...
        @property
        def getDryYearWaterNeed(self) -> bool: ...
        @override
        def as_builder(self, num_first_segment_words: int | None = None, allocate_seg_callable: Any = None) -> _RestInputModule.Builder: ...

    class Builder(_DynamicStructBuilder):
        @property
        def useDevTrend(self) -> bool: ...
        @useDevTrend.setter
        def useDevTrend(self, value: bool) -> None: ...
        @property
        def useCO2Increase(self) -> bool: ...
        @useCO2Increase.setter
        def useCO2Increase(self, value: bool) -> None: ...
        @property
        def dgm(self) -> float: ...
        @dgm.setter
        def dgm(self, value: float) -> None: ...
        @property
        def hft(self) -> int: ...
        @hft.setter
        def hft(self, value: int) -> None: ...
        @property
        def nft(self) -> int: ...
        @nft.setter
        def nft(self, value: int) -> None: ...
        @property
        def sft(self) -> int: ...
        @sft.setter
        def sft(self, value: int) -> None: ...
        @property
        def slope(self) -> int: ...
        @slope.setter
        def slope(self, value: int) -> None: ...
        @property
        def steino(self) -> int: ...
        @steino.setter
        def steino(self, value: int) -> None: ...
        @property
        def az(self) -> int: ...
        @az.setter
        def az(self, value: int) -> None: ...
        @property
        def klz(self) -> int: ...
        @klz.setter
        def klz(self, value: int) -> None: ...
        @property
        def stt(self) -> int: ...
        @stt.setter
        def stt(self, value: int) -> None: ...
        @property
        def germanFederalStates(self) -> int: ...
        @germanFederalStates.setter
        def germanFederalStates(self, value: int) -> None: ...
        @property
        def getDryYearWaterNeed(self) -> bool: ...
        @getDryYearWaterNeed.setter
        def getDryYearWaterNeed(self, value: bool) -> None: ...
        @override
        def as_reader(self) -> _RestInputModule.Reader: ...

    @override
    def new_message(
        self,
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        useDevTrend: bool | None = None,
        useCO2Increase: bool | None = None,
        dgm: float | None = None,
        hft: int | None = None,
        nft: int | None = None,
        sft: int | None = None,
        slope: int | None = None,
        steino: int | None = None,
        az: int | None = None,
        klz: int | None = None,
        stt: int | None = None,
        germanFederalStates: int | None = None,
        getDryYearWaterNeed: bool | None = None,
    ) -> _RestInputModule.Builder: ...

RestInputReader: TypeAlias = _RestInputModule.Reader
RestInputBuilder: TypeAlias = _RestInputModule.Builder
RestInput: _RestInputModule

class _ResultModule(_StructModule):
    class _ResultToValueModule(_StructModule):
        class Reader(_DynamicStructReader):
            @property
            def id(self) -> _ResultIdModule: ...
            @property
            def value(self) -> float: ...
            @override
            def as_builder(self, num_first_segment_words: int | None = None, allocate_seg_callable: Any = None) -> _ResultModule._ResultToValueModule.Builder: ...

        class Builder(_DynamicStructBuilder):
            @property
            def id(self) -> _ResultIdModule: ...
            @id.setter
            def id(self, value: _ResultIdModule | Literal["primaryYield", "dryMatter", "carbonInAboveGroundBiomass", "sumFertilizer", "sumIrrigation", "primaryYieldCU"]) -> None: ...
            @property
            def value(self) -> float: ...
            @value.setter
            def value(self, value: float) -> None: ...
            @override
            def as_reader(self) -> _ResultModule._ResultToValueModule.Reader: ...

        @override
        def new_message(
            self, num_first_segment_words: int | None = None, allocate_seg_callable: Any = None, id: _ResultIdModule | Literal["primaryYield", "dryMatter", "carbonInAboveGroundBiomass", "sumFertilizer", "sumIrrigation", "primaryYieldCU"] | None = None, value: float | None = None
        ) -> _ResultModule._ResultToValueModule.Builder: ...

    ResultToValueReader: TypeAlias = _ResultToValueModule.Reader
    ResultToValueBuilder: TypeAlias = _ResultToValueModule.Builder
    ResultToValue: _ResultToValueModule
    class Reader(_DynamicStructReader):
        @property
        def cultivar(self) -> str: ...
        @property
        def isNoData(self) -> bool: ...
        @property
        def values(self) -> Sequence[_ResultModule._ResultToValueModule.Reader]: ...
        @override
        def as_builder(self, num_first_segment_words: int | None = None, allocate_seg_callable: Any = None) -> _ResultModule.Builder: ...

    class Builder(_DynamicStructBuilder):
        @property
        def cultivar(self) -> str: ...
        @cultivar.setter
        def cultivar(self, value: str) -> None: ...
        @property
        def isNoData(self) -> bool: ...
        @isNoData.setter
        def isNoData(self, value: bool) -> None: ...
        @property
        def values(self) -> MutableSequence[_ResultModule._ResultToValueModule.Builder]: ...
        @values.setter
        def values(self, value: Sequence[_ResultModule._ResultToValueModule.Builder | _ResultModule._ResultToValueModule.Reader] | Sequence[dict[str, Any]]) -> None: ...
        def init(self, field: Literal["values"], size: int | None = None) -> MutableSequence[_ResultModule._ResultToValueModule.Builder]: ...
        @override
        def as_reader(self) -> _ResultModule.Reader: ...

    @override
    def new_message(self, num_first_segment_words: int | None = None, allocate_seg_callable: Any = None, cultivar: str | None = None, isNoData: bool | None = None, values: Sequence[_ResultModule._ResultToValueModule.Builder] | Sequence[dict[str, Any]] | None = None) -> _ResultModule.Builder: ...

ResultReader: TypeAlias = _ResultModule.Reader
ResultBuilder: TypeAlias = _ResultModule.Builder
Result: _ResultModule

class _OutputModule(_StructModule):
    class _YearToResultModule(_StructModule):
        class Reader(_DynamicStructReader):
            @property
            def year(self) -> int: ...
            @property
            def result(self) -> _ResultModule.Reader: ...
            @override
            def as_builder(self, num_first_segment_words: int | None = None, allocate_seg_callable: Any = None) -> _OutputModule._YearToResultModule.Builder: ...

        class Builder(_DynamicStructBuilder):
            @property
            def year(self) -> int: ...
            @year.setter
            def year(self, value: int) -> None: ...
            @property
            def result(self) -> _ResultModule.Builder: ...
            @result.setter
            def result(self, value: _ResultModule.Builder | _ResultModule.Reader | dict[str, Any]) -> None: ...
            def init(self, field: Literal["result"], size: int | None = None) -> _ResultModule.Builder: ...
            @override
            def as_reader(self) -> _OutputModule._YearToResultModule.Reader: ...

        @override
        def new_message(self, num_first_segment_words: int | None = None, allocate_seg_callable: Any = None, year: int | None = None, result: _ResultModule.Builder | dict[str, Any] | None = None) -> _OutputModule._YearToResultModule.Builder: ...

    YearToResultReader: TypeAlias = _YearToResultModule.Reader
    YearToResultBuilder: TypeAlias = _YearToResultModule.Builder
    YearToResult: _YearToResultModule
    class Reader(_DynamicStructReader):
        @property
        def id(self) -> str: ...
        @property
        def runFailed(self) -> bool: ...
        @property
        def reason(self) -> str: ...
        @property
        def results(self) -> Sequence[_OutputModule._YearToResultModule.Reader]: ...
        @override
        def as_builder(self, num_first_segment_words: int | None = None, allocate_seg_callable: Any = None) -> _OutputModule.Builder: ...

    class Builder(_DynamicStructBuilder):
        @property
        def id(self) -> str: ...
        @id.setter
        def id(self, value: str) -> None: ...
        @property
        def runFailed(self) -> bool: ...
        @runFailed.setter
        def runFailed(self, value: bool) -> None: ...
        @property
        def reason(self) -> str: ...
        @reason.setter
        def reason(self, value: str) -> None: ...
        @property
        def results(self) -> MutableSequence[_OutputModule._YearToResultModule.Builder]: ...
        @results.setter
        def results(self, value: Sequence[_OutputModule._YearToResultModule.Builder | _OutputModule._YearToResultModule.Reader] | Sequence[dict[str, Any]]) -> None: ...
        def init(self, field: Literal["results"], size: int | None = None) -> MutableSequence[_OutputModule._YearToResultModule.Builder]: ...
        @override
        def as_reader(self) -> _OutputModule.Reader: ...

    @override
    def new_message(self, num_first_segment_words: int | None = None, allocate_seg_callable: Any = None, id: str | None = None, runFailed: bool | None = None, reason: str | None = None, results: Sequence[_OutputModule._YearToResultModule.Builder] | Sequence[dict[str, Any]] | None = None) -> _OutputModule.Builder: ...

OutputReader: TypeAlias = _OutputModule.Reader
OutputBuilder: TypeAlias = _OutputModule.Builder
Output: _OutputModule

# Top-level type aliases for use in type annotations
ResultToValueBuilder: TypeAlias = _ResultModule._ResultToValueModule.Builder
ResultToValueReader: TypeAlias = _ResultModule._ResultToValueModule.Reader
YearToResultBuilder: TypeAlias = _OutputModule._YearToResultModule.Builder
YearToResultReader: TypeAlias = _OutputModule._YearToResultModule.Reader
