"""This is an automatically generated stub for `yieldstat.capnp`."""

from __future__ import annotations

from collections.abc import Iterator, Sequence
from contextlib import contextmanager
from enum import Enum
from io import BufferedWriter
from typing import Any, BinaryIO, Literal, TypeAlias

class ResultId(Enum):
    primaryYield = "primaryYield"
    dryMatter = "dryMatter"
    carbonInAboveGroundBiomass = "carbonInAboveGroundBiomass"
    sumFertilizer = "sumFertilizer"
    sumIrrigation = "sumIrrigation"
    primaryYieldCU = "primaryYieldCU"

RestInputBuilder: TypeAlias = RestInput.Builder
RestInputReader: TypeAlias = RestInput.Reader

class RestInput:
    class Reader:
        @property
        def useDevTrend(self) -> bool: ...
        @property
        def useCO2Increase(self) -> bool: ...
        @property
        def dgm(self) -> float: ...
        @property
        def hft(self) -> int: ...
        @property
        def nft(self) -> int: ...
        @property
        def sft(self) -> int: ...
        @property
        def slope(self) -> int: ...
        @property
        def steino(self) -> int: ...
        @property
        def az(self) -> int: ...
        @property
        def klz(self) -> int: ...
        @property
        def stt(self) -> int: ...
        @property
        def germanFederalStates(self) -> int: ...
        @property
        def getDryYearWaterNeed(self) -> bool: ...
        def as_builder(self) -> RestInput.Builder: ...

    class Builder:
        @property
        def useDevTrend(self) -> bool: ...
        @useDevTrend.setter
        def useDevTrend(self, value: bool) -> None: ...
        @property
        def useCO2Increase(self) -> bool: ...
        @useCO2Increase.setter
        def useCO2Increase(self, value: bool) -> None: ...
        @property
        def dgm(self) -> float: ...
        @dgm.setter
        def dgm(self, value: float) -> None: ...
        @property
        def hft(self) -> int: ...
        @hft.setter
        def hft(self, value: int) -> None: ...
        @property
        def nft(self) -> int: ...
        @nft.setter
        def nft(self, value: int) -> None: ...
        @property
        def sft(self) -> int: ...
        @sft.setter
        def sft(self, value: int) -> None: ...
        @property
        def slope(self) -> int: ...
        @slope.setter
        def slope(self, value: int) -> None: ...
        @property
        def steino(self) -> int: ...
        @steino.setter
        def steino(self, value: int) -> None: ...
        @property
        def az(self) -> int: ...
        @az.setter
        def az(self, value: int) -> None: ...
        @property
        def klz(self) -> int: ...
        @klz.setter
        def klz(self, value: int) -> None: ...
        @property
        def stt(self) -> int: ...
        @stt.setter
        def stt(self, value: int) -> None: ...
        @property
        def germanFederalStates(self) -> int: ...
        @germanFederalStates.setter
        def germanFederalStates(self, value: int) -> None: ...
        @property
        def getDryYearWaterNeed(self) -> bool: ...
        @getDryYearWaterNeed.setter
        def getDryYearWaterNeed(self, value: bool) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> RestInput.Builder: ...
        def copy(self) -> RestInput.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> RestInput.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @contextmanager
    @staticmethod
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[RestInput.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RestInput.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        useDevTrend: bool | None = None,
        useCO2Increase: bool | None = None,
        dgm: float | None = None,
        hft: int | None = None,
        nft: int | None = None,
        sft: int | None = None,
        slope: int | None = None,
        steino: int | None = None,
        az: int | None = None,
        klz: int | None = None,
        stt: int | None = None,
        germanFederalStates: int | None = None,
        getDryYearWaterNeed: bool | None = None,
    ) -> RestInput.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RestInput.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RestInput.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

ResultBuilder: TypeAlias = Result.Builder
ResultReader: TypeAlias = Result.Reader

class Result:
    ResultToValueBuilder: TypeAlias = ResultToValue.Builder
    ResultToValueReader: TypeAlias = ResultToValue.Reader
    class ResultToValue:
        class Reader:
            @property
            def id(self) -> ResultId: ...
            @property
            def value(self) -> float: ...
            def as_builder(self) -> Result.ResultToValue.Builder: ...

        class Builder:
            @property
            def id(self) -> ResultId: ...
            @id.setter
            def id(
                self,
                value: ResultId
                | Literal[
                    "primaryYield",
                    "dryMatter",
                    "carbonInAboveGroundBiomass",
                    "sumFertilizer",
                    "sumIrrigation",
                    "primaryYieldCU",
                ],
            ) -> None: ...
            @property
            def value(self) -> float: ...
            @value.setter
            def value(self, value: float) -> None: ...
            @staticmethod
            def from_dict(
                dictionary: dict[str, Any],
            ) -> Result.ResultToValue.Builder: ...
            def copy(self) -> Result.ResultToValue.Builder: ...
            def to_bytes(self) -> bytes: ...
            def to_bytes_packed(self) -> bytes: ...
            def to_segments(self) -> list[bytes]: ...
            def as_reader(self) -> Result.ResultToValue.Reader: ...
            @staticmethod
            def write(file: BufferedWriter) -> None: ...
            @staticmethod
            def write_packed(file: BufferedWriter) -> None: ...

        @contextmanager
        @staticmethod
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[Result.ResultToValue.Reader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Result.ResultToValue.Reader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            id: ResultId
            | Literal[
                "primaryYield",
                "dryMatter",
                "carbonInAboveGroundBiomass",
                "sumFertilizer",
                "sumIrrigation",
                "primaryYieldCU",
            ]
            | None = None,
            value: float | None = None,
        ) -> Result.ResultToValue.Builder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Result.ResultToValue.Reader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Result.ResultToValue.Reader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class Reader:
        @property
        def cultivar(self) -> str: ...
        @property
        def isNoData(self) -> bool: ...
        @property
        def values(self) -> Sequence[Result.ResultToValue.Reader]: ...
        def as_builder(self) -> Result.Builder: ...

    class Builder:
        @property
        def cultivar(self) -> str: ...
        @cultivar.setter
        def cultivar(self, value: str) -> None: ...
        @property
        def isNoData(self) -> bool: ...
        @isNoData.setter
        def isNoData(self, value: bool) -> None: ...
        @property
        def values(self) -> Sequence[Result.ResultToValue.Builder]: ...
        @values.setter
        def values(
            self,
            value: Sequence[Result.ResultToValue.Builder | Result.ResultToValue.Reader]
            | Sequence[dict[str, Any]],
        ) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Result.Builder: ...
        def init(
            self, name: Literal["values"], size: int = ...
        ) -> Sequence[Result.ResultToValue.Builder]: ...
        def copy(self) -> Result.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Result.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @contextmanager
    @staticmethod
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[Result.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Result.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        cultivar: str | None = None,
        isNoData: bool | None = None,
        values: Sequence[Result.ResultToValue.Builder]
        | Sequence[dict[str, Any]]
        | None = None,
    ) -> Result.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Result.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Result.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

OutputBuilder: TypeAlias = Output.Builder
OutputReader: TypeAlias = Output.Reader

class Output:
    YearToResultBuilder: TypeAlias = YearToResult.Builder
    YearToResultReader: TypeAlias = YearToResult.Reader
    class YearToResult:
        class Reader:
            @property
            def year(self) -> int: ...
            @property
            def result(self) -> Result.Reader: ...
            def as_builder(self) -> Output.YearToResult.Builder: ...

        class Builder:
            @property
            def year(self) -> int: ...
            @year.setter
            def year(self, value: int) -> None: ...
            @property
            def result(self) -> Result.Builder: ...
            @result.setter
            def result(
                self, value: Result.Builder | Result.Reader | dict[str, Any]
            ) -> None: ...
            @staticmethod
            def from_dict(
                dictionary: dict[str, Any],
            ) -> Output.YearToResult.Builder: ...
            def init(self, name: Literal["result"]) -> Result.Builder: ...
            def copy(self) -> Output.YearToResult.Builder: ...
            def to_bytes(self) -> bytes: ...
            def to_bytes_packed(self) -> bytes: ...
            def to_segments(self) -> list[bytes]: ...
            def as_reader(self) -> Output.YearToResult.Reader: ...
            @staticmethod
            def write(file: BufferedWriter) -> None: ...
            @staticmethod
            def write_packed(file: BufferedWriter) -> None: ...

        def init(self, name: Literal["result"]) -> Result: ...
        @contextmanager
        @staticmethod
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[Output.YearToResult.Reader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Output.YearToResult.Reader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            year: int | None = None,
            result: Result.Builder | dict[str, Any] | None = None,
        ) -> Output.YearToResult.Builder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Output.YearToResult.Reader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Output.YearToResult.Reader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class Reader:
        @property
        def id(self) -> str: ...
        @property
        def runFailed(self) -> bool: ...
        @property
        def reason(self) -> str: ...
        @property
        def results(self) -> Sequence[Output.YearToResult.Reader]: ...
        def as_builder(self) -> Output.Builder: ...

    class Builder:
        @property
        def id(self) -> str: ...
        @id.setter
        def id(self, value: str) -> None: ...
        @property
        def runFailed(self) -> bool: ...
        @runFailed.setter
        def runFailed(self, value: bool) -> None: ...
        @property
        def reason(self) -> str: ...
        @reason.setter
        def reason(self, value: str) -> None: ...
        @property
        def results(self) -> Sequence[Output.YearToResult.Builder]: ...
        @results.setter
        def results(
            self,
            value: Sequence[Output.YearToResult.Builder | Output.YearToResult.Reader]
            | Sequence[dict[str, Any]],
        ) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Output.Builder: ...
        def init(
            self, name: Literal["results"], size: int = ...
        ) -> Sequence[Output.YearToResult.Builder]: ...
        def copy(self) -> Output.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Output.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @contextmanager
    @staticmethod
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[Output.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Output.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        id: str | None = None,
        runFailed: bool | None = None,
        reason: str | None = None,
        results: Sequence[Output.YearToResult.Builder]
        | Sequence[dict[str, Any]]
        | None = None,
    ) -> Output.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Output.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Output.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...
