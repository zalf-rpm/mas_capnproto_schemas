"""This is an automatically generated stub for `geo.capnp`."""

from __future__ import annotations

from collections.abc import Iterator
from contextlib import contextmanager
from enum import Enum
from io import BufferedWriter
from typing import Any, BinaryIO, Generic, Literal, TypeAlias, TypeVar, overload

_CoordinateType = TypeVar("_CoordinateType")

class CoordType(Enum):
    gk = "gk"
    utm = "utm"
    latlon = "latlon"

EPSGBuilder: TypeAlias = EPSG.Builder
EPSGReader: TypeAlias = EPSG.Reader

class EPSG:
    wgs84: int
    utm21S: int
    utm32N: int
    gk5: int
    gk4: int
    gk3: int
    class Reader:
        def as_builder(self) -> EPSG.Builder: ...

    class Builder:
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> EPSG.Builder: ...
        def copy(self) -> EPSG.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> EPSG.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[EPSG.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> EPSG.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None, allocate_seg_callable: Any = None
    ) -> EPSG.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> EPSG.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> EPSG.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

UTMCoordBuilder: TypeAlias = UTMCoord.Builder
UTMCoordReader: TypeAlias = UTMCoord.Reader

class UTMCoord:
    class Reader:
        @property
        def zone(self) -> int: ...
        @property
        def latitudeBand(self) -> str: ...
        @property
        def r(self) -> float: ...
        @property
        def h(self) -> float: ...
        def as_builder(self) -> UTMCoord.Builder: ...

    class Builder:
        @property
        def zone(self) -> int: ...
        @zone.setter
        def zone(self, value: int) -> None: ...
        @property
        def latitudeBand(self) -> str: ...
        @latitudeBand.setter
        def latitudeBand(self, value: str) -> None: ...
        @property
        def r(self) -> float: ...
        @r.setter
        def r(self, value: float) -> None: ...
        @property
        def h(self) -> float: ...
        @h.setter
        def h(self, value: float) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> UTMCoord.Builder: ...
        def copy(self) -> UTMCoord.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> UTMCoord.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[UTMCoord.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> UTMCoord.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        zone: int | None = None,
        latitudeBand: str | None = None,
        r: float | None = None,
        h: float | None = None,
    ) -> UTMCoord.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> UTMCoord.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> UTMCoord.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

LatLonCoordBuilder: TypeAlias = LatLonCoord.Builder
LatLonCoordReader: TypeAlias = LatLonCoord.Reader

class LatLonCoord:
    class Reader:
        @property
        def lat(self) -> float: ...
        @property
        def lon(self) -> float: ...
        def as_builder(self) -> LatLonCoord.Builder: ...

    class Builder:
        @property
        def lat(self) -> float: ...
        @lat.setter
        def lat(self, value: float) -> None: ...
        @property
        def lon(self) -> float: ...
        @lon.setter
        def lon(self, value: float) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> LatLonCoord.Builder: ...
        def copy(self) -> LatLonCoord.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> LatLonCoord.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[LatLonCoord.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> LatLonCoord.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        lat: float | None = None,
        lon: float | None = None,
    ) -> LatLonCoord.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> LatLonCoord.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> LatLonCoord.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

GKCoordBuilder: TypeAlias = GKCoord.Builder
GKCoordReader: TypeAlias = GKCoord.Reader

class GKCoord:
    class Reader:
        @property
        def meridianNo(self) -> int: ...
        @property
        def r(self) -> float: ...
        @property
        def h(self) -> float: ...
        def as_builder(self) -> GKCoord.Builder: ...

    class Builder:
        @property
        def meridianNo(self) -> int: ...
        @meridianNo.setter
        def meridianNo(self, value: int) -> None: ...
        @property
        def r(self) -> float: ...
        @r.setter
        def r(self, value: float) -> None: ...
        @property
        def h(self) -> float: ...
        @h.setter
        def h(self, value: float) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> GKCoord.Builder: ...
        def copy(self) -> GKCoord.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> GKCoord.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[GKCoord.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> GKCoord.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        meridianNo: int | None = None,
        r: float | None = None,
        h: float | None = None,
    ) -> GKCoord.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> GKCoord.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> GKCoord.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

Point2DBuilder: TypeAlias = Point2D.Builder
Point2DReader: TypeAlias = Point2D.Reader

class Point2D:
    class Reader:
        @property
        def x(self) -> float: ...
        @property
        def y(self) -> float: ...
        def as_builder(self) -> Point2D.Builder: ...

    class Builder:
        @property
        def x(self) -> float: ...
        @x.setter
        def x(self, value: float) -> None: ...
        @property
        def y(self) -> float: ...
        @y.setter
        def y(self, value: float) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Point2D.Builder: ...
        def copy(self) -> Point2D.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Point2D.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[Point2D.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Point2D.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        x: float | None = None,
        y: float | None = None,
    ) -> Point2D.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Point2D.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Point2D.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

RowColBuilder: TypeAlias = RowCol.Builder
RowColReader: TypeAlias = RowCol.Reader

class RowCol:
    class Reader:
        @property
        def row(self) -> int: ...
        @property
        def col(self) -> int: ...
        def as_builder(self) -> RowCol.Builder: ...

    class Builder:
        @property
        def row(self) -> int: ...
        @row.setter
        def row(self, value: int) -> None: ...
        @property
        def col(self) -> int: ...
        @col.setter
        def col(self, value: int) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> RowCol.Builder: ...
        def copy(self) -> RowCol.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> RowCol.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[RowCol.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RowCol.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        row: int | None = None,
        col: int | None = None,
    ) -> RowCol.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RowCol.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RowCol.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

CoordBuilder: TypeAlias = Coord.Builder
CoordReader: TypeAlias = Coord.Reader

class Coord:
    class Reader:
        @property
        def gk(self) -> GKCoord.Reader: ...
        @property
        def latlon(self) -> LatLonCoord.Reader: ...
        @property
        def utm(self) -> UTMCoord.Reader: ...
        @property
        def p2D(self) -> Point2D.Reader: ...
        @property
        def rowcol(self) -> RowCol.Reader: ...
        def which(self) -> Literal["gk", "latlon", "utm", "p2D", "rowcol"]: ...
        def as_builder(self) -> Coord.Builder: ...

    class Builder:
        @property
        def gk(self) -> GKCoord.Builder: ...
        @gk.setter
        def gk(
            self, value: GKCoord.Builder | GKCoord.Reader | dict[str, Any]
        ) -> None: ...
        @property
        def latlon(self) -> LatLonCoord.Builder: ...
        @latlon.setter
        def latlon(
            self, value: LatLonCoord.Builder | LatLonCoord.Reader | dict[str, Any]
        ) -> None: ...
        @property
        def utm(self) -> UTMCoord.Builder: ...
        @utm.setter
        def utm(
            self, value: UTMCoord.Builder | UTMCoord.Reader | dict[str, Any]
        ) -> None: ...
        @property
        def p2D(self) -> Point2D.Builder: ...
        @p2D.setter
        def p2D(
            self, value: Point2D.Builder | Point2D.Reader | dict[str, Any]
        ) -> None: ...
        @property
        def rowcol(self) -> RowCol.Builder: ...
        @rowcol.setter
        def rowcol(
            self, value: RowCol.Builder | RowCol.Reader | dict[str, Any]
        ) -> None: ...
        def which(self) -> Literal["gk", "latlon", "utm", "p2D", "rowcol"]: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Coord.Builder: ...
        @overload
        def init(self: Any, name: Literal["gk"]) -> GKCoord.Builder: ...
        @overload
        def init(self: Any, name: Literal["latlon"]) -> LatLonCoord.Builder: ...
        @overload
        def init(self: Any, name: Literal["utm"]) -> UTMCoord.Builder: ...
        @overload
        def init(self: Any, name: Literal["p2D"]) -> Point2D.Builder: ...
        @overload
        def init(self: Any, name: Literal["rowcol"]) -> RowCol.Builder: ...
        def init(self: Any, name: str, size: int = ...) -> Any: ...
        def copy(self) -> Coord.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Coord.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    def which(self) -> Literal["gk", "latlon", "utm", "p2D", "rowcol"]: ...
    @overload
    def init(self, name: Literal["gk"]) -> GKCoord: ...
    @overload
    def init(self, name: Literal["latlon"]) -> LatLonCoord: ...
    @overload
    def init(self, name: Literal["utm"]) -> UTMCoord: ...
    @overload
    def init(self, name: Literal["p2D"]) -> Point2D: ...
    @overload
    def init(self, name: Literal["rowcol"]) -> RowCol: ...
    def init(self: Any, name: str, size: int = ...) -> Any: ...
    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[Coord.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Coord.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        gk: GKCoord.Builder | dict[str, Any] | None = None,
        latlon: LatLonCoord.Builder | dict[str, Any] | None = None,
        utm: UTMCoord.Builder | dict[str, Any] | None = None,
        p2D: Point2D.Builder | dict[str, Any] | None = None,
        rowcol: RowCol.Builder | dict[str, Any] | None = None,
    ) -> Coord.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Coord.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Coord.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

RectBoundsBuilder: TypeAlias = RectBounds.Builder
RectBoundsReader: TypeAlias = RectBounds.Reader

class RectBounds(Generic[_CoordinateType]):
    class Reader:
        @property
        def tl(self) -> _CoordinateType: ...
        @property
        def br(self) -> _CoordinateType: ...
        def as_builder(self) -> RectBounds.Builder: ...

    class Builder:
        @property
        def tl(self) -> _CoordinateType: ...
        @tl.setter
        def tl(self, value: _CoordinateType) -> None: ...
        @property
        def br(self) -> _CoordinateType: ...
        @br.setter
        def br(self, value: _CoordinateType) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> RectBounds.Builder: ...
        def copy(self) -> RectBounds.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> RectBounds.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[RectBounds.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RectBounds.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        tl: _CoordinateType | None = None,
        br: _CoordinateType | None = None,
    ) -> RectBounds.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RectBounds.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> RectBounds.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...
