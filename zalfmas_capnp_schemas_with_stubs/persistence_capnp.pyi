"""This is an automatically generated stub for `persistence.capnp`."""

from __future__ import annotations

from collections.abc import Awaitable, Iterator
from contextlib import contextmanager
from io import BufferedWriter
from typing import Any, BinaryIO, Literal, NamedTuple, Protocol, overload

from .common_capnp import Identifiable

class VatId:
    @property
    def publicKey0(self) -> int: ...
    @property
    def publicKey1(self) -> int: ...
    @property
    def publicKey2(self) -> int: ...
    @property
    def publicKey3(self) -> int: ...
    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[VatIdReader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> VatIdReader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        publicKey0: int | None = None,
        publicKey1: int | None = None,
        publicKey2: int | None = None,
        publicKey3: int | None = None,
    ) -> VatIdBuilder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> VatIdReader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> VatIdReader: ...
    def to_dict(self) -> dict[str, Any]: ...

class VatIdReader(VatId):
    def as_builder(self) -> VatIdBuilder: ...

class VatIdBuilder(VatId):
    @property
    def publicKey0(self) -> int: ...
    @publicKey0.setter
    def publicKey0(self, value: int) -> None: ...
    @property
    def publicKey1(self) -> int: ...
    @publicKey1.setter
    def publicKey1(self, value: int) -> None: ...
    @property
    def publicKey2(self) -> int: ...
    @publicKey2.setter
    def publicKey2(self, value: int) -> None: ...
    @property
    def publicKey3(self) -> int: ...
    @publicKey3.setter
    def publicKey3(self, value: int) -> None: ...
    @staticmethod
    def from_dict(dictionary: dict[str, Any]) -> VatIdBuilder: ...
    def copy(self) -> VatIdBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> VatIdReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...

class Address:
    class Ip6:
        @property
        def lower64(self) -> int: ...
        @property
        def upper64(self) -> int: ...
        @staticmethod
        @contextmanager
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[Address.Ip6Reader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Address.Ip6Reader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            lower64: int | None = None,
            upper64: int | None = None,
        ) -> Address.Ip6Builder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Address.Ip6Reader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Address.Ip6Reader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class Ip6Reader(Address.Ip6):
        def as_builder(self) -> Address.Ip6Builder: ...

    class Ip6Builder(Address.Ip6):
        @property
        def lower64(self) -> int: ...
        @lower64.setter
        def lower64(self, value: int) -> None: ...
        @property
        def upper64(self) -> int: ...
        @upper64.setter
        def upper64(self, value: int) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Address.Ip6Builder: ...
        def copy(self) -> Address.Ip6Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Address.Ip6Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @property
    def ip6(self) -> Address.Ip6: ...
    @property
    def port(self) -> int: ...
    @property
    def host(self) -> str: ...
    def which(self) -> Literal["ip6", "host"]: ...
    def init(self, name: Literal["ip6"]) -> Address.Ip6: ...
    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[AddressReader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> AddressReader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        ip6: Address.Ip6Builder | dict[str, Any] | None = None,
        port: int | None = None,
        host: str | None = None,
    ) -> AddressBuilder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> AddressReader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> AddressReader: ...
    def to_dict(self) -> dict[str, Any]: ...

class AddressReader(Address):
    @property
    def ip6(self) -> Address.Ip6Reader: ...
    def as_builder(self) -> AddressBuilder: ...

class AddressBuilder(Address):
    @property
    def ip6(self) -> Address.Ip6Builder: ...
    @ip6.setter
    def ip6(
        self,
        value: Address.Ip6 | Address.Ip6Builder | Address.Ip6Reader | dict[str, Any],
    ) -> None: ...
    @property
    def port(self) -> int: ...
    @port.setter
    def port(self, value: int) -> None: ...
    @property
    def host(self) -> str: ...
    @host.setter
    def host(self, value: str) -> None: ...
    @staticmethod
    def from_dict(dictionary: dict[str, Any]) -> AddressBuilder: ...
    def init(self, name: Literal["ip6"]) -> Address.Ip6Builder: ...
    def copy(self) -> AddressBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> AddressReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...

class VatPath:
    @property
    def id(self) -> VatId: ...
    @property
    def address(self) -> Address: ...
    @overload
    def init(self, name: Literal["id"]) -> VatId: ...
    @overload
    def init(self, name: Literal["address"]) -> Address: ...
    def init(self: Any, name: str, size: int = ...) -> Any: ...
    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[VatPathReader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> VatPathReader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        id: VatIdBuilder | dict[str, Any] | None = None,
        address: AddressBuilder | dict[str, Any] | None = None,
    ) -> VatPathBuilder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> VatPathReader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> VatPathReader: ...
    def to_dict(self) -> dict[str, Any]: ...

class VatPathReader(VatPath):
    @property
    def id(self) -> VatIdReader: ...
    @property
    def address(self) -> AddressReader: ...
    def as_builder(self) -> VatPathBuilder: ...

class VatPathBuilder(VatPath):
    @property
    def id(self) -> VatIdBuilder: ...
    @id.setter
    def id(
        self, value: VatId | VatIdBuilder | VatIdReader | dict[str, Any]
    ) -> None: ...
    @property
    def address(self) -> AddressBuilder: ...
    @address.setter
    def address(
        self, value: Address | AddressBuilder | AddressReader | dict[str, Any]
    ) -> None: ...
    @staticmethod
    def from_dict(dictionary: dict[str, Any]) -> VatPathBuilder: ...
    @overload
    def init(self: Any, name: Literal["id"]) -> VatIdBuilder: ...
    @overload
    def init(self: Any, name: Literal["address"]) -> AddressBuilder: ...
    def init(self: Any, name: str, size: int = ...) -> Any: ...
    def copy(self) -> VatPathBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> VatPathReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...

class SturdyRef:
    class Owner:
        @property
        def guid(self) -> str: ...
        @staticmethod
        @contextmanager
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[SturdyRef.OwnerReader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> SturdyRef.OwnerReader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            guid: str | None = None,
        ) -> SturdyRef.OwnerBuilder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> SturdyRef.OwnerReader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> SturdyRef.OwnerReader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class OwnerReader(SturdyRef.Owner):
        def as_builder(self) -> SturdyRef.OwnerBuilder: ...

    class OwnerBuilder(SturdyRef.Owner):
        @property
        def guid(self) -> str: ...
        @guid.setter
        def guid(self, value: str) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> SturdyRef.OwnerBuilder: ...
        def copy(self) -> SturdyRef.OwnerBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> SturdyRef.OwnerReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    class Token:
        @property
        def text(self) -> str: ...
        @property
        def data(self) -> bytes: ...
        def which(self) -> Literal["text", "data"]: ...
        @staticmethod
        @contextmanager
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[SturdyRef.TokenReader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> SturdyRef.TokenReader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            text: str | None = None,
            data: bytes | None = None,
        ) -> SturdyRef.TokenBuilder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> SturdyRef.TokenReader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> SturdyRef.TokenReader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class TokenReader(SturdyRef.Token):
        def as_builder(self) -> SturdyRef.TokenBuilder: ...

    class TokenBuilder(SturdyRef.Token):
        @property
        def text(self) -> str: ...
        @text.setter
        def text(self, value: str) -> None: ...
        @property
        def data(self) -> bytes: ...
        @data.setter
        def data(self, value: bytes) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> SturdyRef.TokenBuilder: ...
        def copy(self) -> SturdyRef.TokenBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> SturdyRef.TokenReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @property
    def vat(self) -> VatPath: ...
    @property
    def localRef(self) -> SturdyRef.Token: ...
    @overload
    def init(self, name: Literal["vat"]) -> VatPath: ...
    @overload
    def init(self, name: Literal["localRef"]) -> SturdyRef.Token: ...
    def init(self: Any, name: str, size: int = ...) -> Any: ...
    @staticmethod
    @contextmanager
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[SturdyRefReader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> SturdyRefReader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        vat: VatPathBuilder | dict[str, Any] | None = None,
        localRef: SturdyRef.TokenBuilder | dict[str, Any] | None = None,
    ) -> SturdyRefBuilder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> SturdyRefReader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> SturdyRefReader: ...
    def to_dict(self) -> dict[str, Any]: ...

class SturdyRefReader(SturdyRef):
    @property
    def vat(self) -> VatPathReader: ...
    @property
    def localRef(self) -> SturdyRef.TokenReader: ...
    def as_builder(self) -> SturdyRefBuilder: ...

class SturdyRefBuilder(SturdyRef):
    @property
    def vat(self) -> VatPathBuilder: ...
    @vat.setter
    def vat(
        self, value: VatPath | VatPathBuilder | VatPathReader | dict[str, Any]
    ) -> None: ...
    @property
    def localRef(self) -> SturdyRef.TokenBuilder: ...
    @localRef.setter
    def localRef(
        self,
        value: SturdyRef.Token
        | SturdyRef.TokenBuilder
        | SturdyRef.TokenReader
        | dict[str, Any],
    ) -> None: ...
    @staticmethod
    def from_dict(dictionary: dict[str, Any]) -> SturdyRefBuilder: ...
    @overload
    def init(self: Any, name: Literal["vat"]) -> VatPathBuilder: ...
    @overload
    def init(self: Any, name: Literal["localRef"]) -> SturdyRef.TokenBuilder: ...
    def init(self: Any, name: str, size: int = ...) -> Any: ...
    def copy(self) -> SturdyRefBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> SturdyRefReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...

class Heartbeat(Protocol):
    class BeatResultsBuilder(Protocol): ...

    class BeatCallContext(Protocol):
        results: Heartbeat.BeatResultsBuilder

    def beat(self) -> Awaitable[None]: ...
    class BeatRequest(Protocol):
        def send(self) -> Awaitable[None]: ...

    def beat_request(self) -> BeatRequest: ...
    @classmethod
    def _new_client(cls, server: Heartbeat.Server) -> Heartbeat: ...
    class Server:
        def beat(
            self, _context: Heartbeat.BeatCallContext, **kwargs: Any
        ) -> Awaitable[None]: ...

class Persistent(Protocol):
    class SaveParams:
        @property
        def sealFor(self) -> SturdyRef.Owner: ...
        def init(self, name: Literal["sealFor"]) -> SturdyRef.Owner: ...
        @staticmethod
        @contextmanager
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[Persistent.SaveParamsReader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Persistent.SaveParamsReader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            sealFor: SturdyRef.OwnerBuilder | dict[str, Any] | None = None,
        ) -> Persistent.SaveParamsBuilder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Persistent.SaveParamsReader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Persistent.SaveParamsReader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class SaveParamsReader(Persistent.SaveParams):
        @property
        def sealFor(self) -> SturdyRef.OwnerReader: ...
        def as_builder(self) -> Persistent.SaveParamsBuilder: ...

    class SaveParamsBuilder(Persistent.SaveParams):
        @property
        def sealFor(self) -> SturdyRef.OwnerBuilder: ...
        @sealFor.setter
        def sealFor(
            self,
            value: SturdyRef.Owner
            | SturdyRef.OwnerBuilder
            | SturdyRef.OwnerReader
            | dict[str, Any],
        ) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Persistent.SaveParamsBuilder: ...
        def init(self, name: Literal["sealFor"]) -> SturdyRef.OwnerBuilder: ...
        def copy(self) -> Persistent.SaveParamsBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Persistent.SaveParamsReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    class SaveResults:
        @property
        def sturdyRef(self) -> SturdyRef: ...
        @property
        def unsaveSR(self) -> SturdyRef: ...
        @overload
        def init(self, name: Literal["sturdyRef"]) -> SturdyRef: ...
        @overload
        def init(self, name: Literal["unsaveSR"]) -> SturdyRef: ...
        def init(self: Any, name: str, size: int = ...) -> Any: ...
        @staticmethod
        @contextmanager
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[Persistent.SaveResultsReader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Persistent.SaveResultsReader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            sturdyRef: SturdyRefBuilder | dict[str, Any] | None = None,
            unsaveSR: SturdyRefBuilder | dict[str, Any] | None = None,
        ) -> Persistent.SaveResultsBuilder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Persistent.SaveResultsReader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Persistent.SaveResultsReader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class SaveResultsReader(Persistent.SaveResults):
        @property
        def sturdyRef(self) -> SturdyRefReader: ...
        @property
        def unsaveSR(self) -> SturdyRefReader: ...
        def as_builder(self) -> Persistent.SaveResultsBuilder: ...

    class SaveResultsBuilder(Persistent.SaveResults):
        @property
        def sturdyRef(self) -> SturdyRefBuilder: ...
        @sturdyRef.setter
        def sturdyRef(
            self, value: SturdyRef | SturdyRefBuilder | SturdyRefReader | dict[str, Any]
        ) -> None: ...
        @property
        def unsaveSR(self) -> SturdyRefBuilder: ...
        @unsaveSR.setter
        def unsaveSR(
            self, value: SturdyRef | SturdyRefBuilder | SturdyRefReader | dict[str, Any]
        ) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Persistent.SaveResultsBuilder: ...
        @overload
        def init(self: Any, name: Literal["sturdyRef"]) -> SturdyRefBuilder: ...
        @overload
        def init(self: Any, name: Literal["unsaveSR"]) -> SturdyRefBuilder: ...
        def init(self: Any, name: str, size: int = ...) -> Any: ...
        def copy(self) -> Persistent.SaveResultsBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Persistent.SaveResultsReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    class ReleaseSturdyRef(Protocol):
        class ReleaseResult(Awaitable[ReleaseResult], Protocol):
            success: bool

        class ReleaseResultsBuilder(Protocol):
            success: bool

        class ReleaseCallContext(Protocol):
            results: Persistent.ReleaseSturdyRef.ReleaseResultsBuilder

        def release(self) -> ReleaseResult: ...
        class ReleaseRequest(Protocol):
            def send(self) -> Persistent.ReleaseSturdyRef.ReleaseResult: ...

        def release_request(self) -> ReleaseRequest: ...
        @classmethod
        def _new_client(
            cls, server: Persistent.ReleaseSturdyRef.Server
        ) -> Persistent.ReleaseSturdyRef: ...
        class Server:
            def release(
                self,
                _context: Persistent.ReleaseSturdyRef.ReleaseCallContext,
                **kwargs: Any,
            ) -> Awaitable[bool]: ...

    class SaveResult(Protocol):
        sturdyRef: SturdyRefReader
        unsaveSR: SturdyRefReader

    class SaveCallContext(Protocol):
        results: Persistent.SaveResult

    def save(
        self, sealFor: SturdyRef.Owner | dict[str, Any]
    ) -> Awaitable[Persistent.SaveResult]: ...
    class SaveRequest(Protocol):
        sealFor: SturdyRef.OwnerBuilder
        def send(self) -> Awaitable[Persistent.SaveResult]: ...

    def save_request(self) -> SaveRequest: ...
    @classmethod
    def _new_client(cls, server: Persistent.Server) -> Persistent: ...
    class Server:
        class SaveResult(NamedTuple):
            sturdyRef: SturdyRef
            unsaveSR: SturdyRef

        def save(
            self,
            sealFor: SturdyRef.OwnerReader,
            _context: Persistent.SaveCallContext,
            **kwargs: Any,
        ) -> Awaitable[Persistent.Server.SaveResult]: ...

class Restorer(Protocol):
    class RestoreParams:
        @property
        def localRef(self) -> SturdyRef.Token: ...
        @property
        def sealedBy(self) -> SturdyRef.Owner: ...
        @overload
        def init(self, name: Literal["localRef"]) -> SturdyRef.Token: ...
        @overload
        def init(self, name: Literal["sealedBy"]) -> SturdyRef.Owner: ...
        def init(self: Any, name: str, size: int = ...) -> Any: ...
        @staticmethod
        @contextmanager
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[Restorer.RestoreParamsReader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Restorer.RestoreParamsReader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            localRef: SturdyRef.TokenBuilder | dict[str, Any] | None = None,
            sealedBy: SturdyRef.OwnerBuilder | dict[str, Any] | None = None,
        ) -> Restorer.RestoreParamsBuilder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Restorer.RestoreParamsReader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Restorer.RestoreParamsReader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class RestoreParamsReader(Restorer.RestoreParams):
        @property
        def localRef(self) -> SturdyRef.TokenReader: ...
        @property
        def sealedBy(self) -> SturdyRef.OwnerReader: ...
        def as_builder(self) -> Restorer.RestoreParamsBuilder: ...

    class RestoreParamsBuilder(Restorer.RestoreParams):
        @property
        def localRef(self) -> SturdyRef.TokenBuilder: ...
        @localRef.setter
        def localRef(
            self,
            value: SturdyRef.Token
            | SturdyRef.TokenBuilder
            | SturdyRef.TokenReader
            | dict[str, Any],
        ) -> None: ...
        @property
        def sealedBy(self) -> SturdyRef.OwnerBuilder: ...
        @sealedBy.setter
        def sealedBy(
            self,
            value: SturdyRef.Owner
            | SturdyRef.OwnerBuilder
            | SturdyRef.OwnerReader
            | dict[str, Any],
        ) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Restorer.RestoreParamsBuilder: ...
        @overload
        def init(self: Any, name: Literal["localRef"]) -> SturdyRef.TokenBuilder: ...
        @overload
        def init(self: Any, name: Literal["sealedBy"]) -> SturdyRef.OwnerBuilder: ...
        def init(self: Any, name: str, size: int = ...) -> Any: ...
        def copy(self) -> Restorer.RestoreParamsBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Restorer.RestoreParamsReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    class RestoreResult(Awaitable[RestoreResult], Protocol):
        cap: Any

    class RestoreResultsBuilder(Protocol):
        cap: Any

    class RestoreCallContext(Protocol):
        results: Restorer.RestoreResultsBuilder

    def restore(
        self,
        localRef: SturdyRef.Token | dict[str, Any],
        sealedBy: SturdyRef.Owner | dict[str, Any],
    ) -> RestoreResult: ...
    class RestoreRequest(Protocol):
        localRef: SturdyRef.TokenBuilder
        sealedBy: SturdyRef.OwnerBuilder
        def send(self) -> Restorer.RestoreResult: ...

    def restore_request(self) -> RestoreRequest: ...
    @classmethod
    def _new_client(cls, server: Restorer.Server) -> Restorer: ...
    class Server:
        def restore(
            self,
            localRef: SturdyRef.TokenReader,
            sealedBy: SturdyRef.OwnerReader,
            _context: Restorer.RestoreCallContext,
            **kwargs: Any,
        ) -> Awaitable[Any]: ...

class HostPortResolver(Identifiable, Restorer, Protocol):
    class Registrar(Protocol):
        class RegisterParams:
            @property
            def base64VatId(self) -> str: ...
            @property
            def host(self) -> str: ...
            @property
            def port(self) -> int: ...
            @property
            def alias(self) -> str: ...
            @property
            def identityProof(self) -> bytes: ...
            @staticmethod
            @contextmanager
            def from_bytes(
                data: bytes,
                traversal_limit_in_words: int | None = ...,
                nesting_limit: int | None = ...,
            ) -> Iterator[HostPortResolver.Registrar.RegisterParamsReader]: ...
            @staticmethod
            def from_bytes_packed(
                data: bytes,
                traversal_limit_in_words: int | None = ...,
                nesting_limit: int | None = ...,
            ) -> HostPortResolver.Registrar.RegisterParamsReader: ...
            @staticmethod
            def new_message(
                num_first_segment_words: int | None = None,
                allocate_seg_callable: Any = None,
                base64VatId: str | None = None,
                host: str | None = None,
                port: int | None = None,
                alias: str | None = None,
                identityProof: bytes | None = None,
            ) -> HostPortResolver.Registrar.RegisterParamsBuilder: ...
            @staticmethod
            def read(
                file: BinaryIO,
                traversal_limit_in_words: int | None = ...,
                nesting_limit: int | None = ...,
            ) -> HostPortResolver.Registrar.RegisterParamsReader: ...
            @staticmethod
            def read_packed(
                file: BinaryIO,
                traversal_limit_in_words: int | None = ...,
                nesting_limit: int | None = ...,
            ) -> HostPortResolver.Registrar.RegisterParamsReader: ...
            def to_dict(self) -> dict[str, Any]: ...

        class RegisterParamsReader(HostPortResolver.Registrar.RegisterParams):
            def as_builder(
                self,
            ) -> HostPortResolver.Registrar.RegisterParamsBuilder: ...

        class RegisterParamsBuilder(HostPortResolver.Registrar.RegisterParams):
            @property
            def base64VatId(self) -> str: ...
            @base64VatId.setter
            def base64VatId(self, value: str) -> None: ...
            @property
            def host(self) -> str: ...
            @host.setter
            def host(self, value: str) -> None: ...
            @property
            def port(self) -> int: ...
            @port.setter
            def port(self, value: int) -> None: ...
            @property
            def alias(self) -> str: ...
            @alias.setter
            def alias(self, value: str) -> None: ...
            @property
            def identityProof(self) -> bytes: ...
            @identityProof.setter
            def identityProof(self, value: bytes) -> None: ...
            @staticmethod
            def from_dict(
                dictionary: dict[str, Any],
            ) -> HostPortResolver.Registrar.RegisterParamsBuilder: ...
            def copy(self) -> HostPortResolver.Registrar.RegisterParamsBuilder: ...
            def to_bytes(self) -> bytes: ...
            def to_bytes_packed(self) -> bytes: ...
            def to_segments(self) -> list[bytes]: ...
            def as_reader(self) -> HostPortResolver.Registrar.RegisterParamsReader: ...
            @staticmethod
            def write(file: BufferedWriter) -> None: ...
            @staticmethod
            def write_packed(file: BufferedWriter) -> None: ...

        class RegisterResult(Awaitable[RegisterResult], Protocol):
            heartbeat: Heartbeat
            secsHeartbeatInterval: int

        class RegisterResultsBuilder(Protocol):
            heartbeat: Heartbeat
            secsHeartbeatInterval: int

        class RegisterCallContext(Protocol):
            results: HostPortResolver.Registrar.RegisterResultsBuilder

        def register(
            self,
            base64VatId: str,
            host: str,
            port: int,
            alias: str,
            identityProof: bytes,
        ) -> RegisterResult: ...
        class RegisterRequest(Protocol):
            base64VatId: str
            host: str
            port: int
            alias: str
            identityProof: bytes
            def send(self) -> HostPortResolver.Registrar.RegisterResult: ...

        def register_request(self) -> RegisterRequest: ...
        @classmethod
        def _new_client(
            cls, server: HostPortResolver.Registrar.Server
        ) -> HostPortResolver.Registrar: ...
        class Server:
            def register(
                self,
                base64VatId: str,
                host: str,
                port: int,
                alias: str,
                identityProof: bytes,
                _context: HostPortResolver.Registrar.RegisterCallContext,
                **kwargs: Any,
            ) -> Awaitable[tuple[Heartbeat, int]]: ...

    class ResolveResult(Awaitable[ResolveResult], Protocol):
        host: str
        port: int

    class ResolveResultsBuilder(Protocol):
        host: str
        port: int

    class ResolveCallContext(Protocol):
        results: HostPortResolver.ResolveResultsBuilder

    def resolve(self, id: str) -> ResolveResult: ...
    class ResolveRequest(Protocol):
        id: str
        def send(self) -> HostPortResolver.ResolveResult: ...

    def resolve_request(self) -> ResolveRequest: ...
    @classmethod
    def _new_client(
        cls, server: HostPortResolver.Server | Identifiable.Server | Restorer.Server
    ) -> HostPortResolver: ...
    class Server(Identifiable.Server, Restorer.Server):
        def resolve(
            self, id: str, _context: HostPortResolver.ResolveCallContext, **kwargs: Any
        ) -> Awaitable[tuple[str, int]]: ...

class Gateway(Identifiable, Restorer, Protocol):
    class RegResults:
        @property
        def sturdyRef(self) -> SturdyRef: ...
        @property
        def heartbeat(self) -> Heartbeat: ...
        @property
        def secsHeartbeatInterval(self) -> int: ...
        def init(self, name: Literal["sturdyRef"]) -> SturdyRef: ...
        @staticmethod
        @contextmanager
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[Gateway.RegResultsReader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Gateway.RegResultsReader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            sturdyRef: SturdyRefBuilder | dict[str, Any] | None = None,
            heartbeat: Heartbeat | Heartbeat.Server | None = None,
            secsHeartbeatInterval: int | None = None,
        ) -> Gateway.RegResultsBuilder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Gateway.RegResultsReader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Gateway.RegResultsReader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class RegResultsReader(Gateway.RegResults):
        @property
        def sturdyRef(self) -> SturdyRefReader: ...
        def as_builder(self) -> Gateway.RegResultsBuilder: ...

    class RegResultsBuilder(Gateway.RegResults):
        @property
        def sturdyRef(self) -> SturdyRefBuilder: ...
        @sturdyRef.setter
        def sturdyRef(
            self, value: SturdyRef | SturdyRefBuilder | SturdyRefReader | dict[str, Any]
        ) -> None: ...
        @property
        def heartbeat(self) -> Heartbeat: ...
        @heartbeat.setter
        def heartbeat(self, value: Heartbeat | Heartbeat.Server) -> None: ...
        @property
        def secsHeartbeatInterval(self) -> int: ...
        @secsHeartbeatInterval.setter
        def secsHeartbeatInterval(self, value: int) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Gateway.RegResultsBuilder: ...
        def init(self, name: Literal["sturdyRef"]) -> SturdyRefBuilder: ...
        def copy(self) -> Gateway.RegResultsBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Gateway.RegResultsReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    class RegisterResult(Protocol):
        sturdyRef: SturdyRefReader
        heartbeat: Heartbeat
        secsHeartbeatInterval: int

    class RegisterCallContext(Protocol):
        results: Gateway.RegisterResult

    def register(self, cap: Any) -> Awaitable[Gateway.RegisterResult]: ...
    class RegisterRequest(Protocol):
        cap: Any
        def send(self) -> Awaitable[Gateway.RegisterResult]: ...

    def register_request(self) -> RegisterRequest: ...
    @classmethod
    def _new_client(
        cls, server: Gateway.Server | Identifiable.Server | Restorer.Server
    ) -> Gateway: ...
    class Server(Identifiable.Server, Restorer.Server):
        class RegisterResult(NamedTuple):
            sturdyRef: SturdyRef
            heartbeat: Heartbeat
            secsHeartbeatInterval: int

        def register(
            self, cap: Any, _context: Gateway.RegisterCallContext, **kwargs: Any
        ) -> Awaitable[Gateway.Server.RegisterResult]: ...
