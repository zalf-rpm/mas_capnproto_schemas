"""This is an automatically generated stub for `common.capnp`."""

from __future__ import annotations

from collections.abc import Awaitable, Iterator, Sequence
from contextlib import contextmanager
from enum import Enum
from io import BufferedWriter
from typing import (
    Any,
    BinaryIO,
    Generic,
    Literal,
    NamedTuple,
    Protocol,
    TypeAlias,
    TypeVar,
    overload,
)

Value_F = TypeVar("Value_F")
Value_S = TypeVar("Value_S")

IdInformationBuilder: TypeAlias = IdInformation.Builder
IdInformationReader: TypeAlias = IdInformation.Reader

class IdInformation:
    class Reader:
        @property
        def id(self) -> str: ...
        @property
        def name(self) -> str: ...
        @property
        def description(self) -> str: ...
        def as_builder(self) -> IdInformation.Builder: ...

    class Builder:
        @property
        def id(self) -> str: ...
        @id.setter
        def id(self, value: str) -> None: ...
        @property
        def name(self) -> str: ...
        @name.setter
        def name(self, value: str) -> None: ...
        @property
        def description(self) -> str: ...
        @description.setter
        def description(self, value: str) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> IdInformation.Builder: ...
        def copy(self) -> IdInformation.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> IdInformation.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @contextmanager
    @staticmethod
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[IdInformation.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> IdInformation.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        id: str | None = None,
        name: str | None = None,
        description: str | None = None,
    ) -> IdInformation.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> IdInformation.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> IdInformation.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

class Identifiable:
    class InfoRequest(Protocol):
        def send(self) -> Identifiable.InfoResult: ...

    class InfoResult(Awaitable[InfoResult], Protocol):
        id: str
        name: str
        description: str

    @classmethod
    def _new_client(cls, server: Identifiable.Server) -> IdentifiableClient: ...
    class Server(Protocol):
        class InfoResultTuple(NamedTuple):
            id: str
            name: str
            description: str

        class InfoCallContext(Protocol):
            params: Identifiable.InfoRequest
            results: Identifiable.InfoResult

        def info(
            self, _context: Identifiable.Server.InfoCallContext, **kwargs: Any
        ) -> Awaitable[Identifiable.Server.InfoResultTuple | None]: ...
        def info_context(
            self, context: Identifiable.Server.InfoCallContext
        ) -> Awaitable[None]: ...

class IdentifiableClient(Protocol):
    def info(self) -> Identifiable.InfoResult: ...
    def info_request(self) -> Identifiable.InfoRequest: ...

StructuredTextBuilder: TypeAlias = StructuredText.Builder
StructuredTextReader: TypeAlias = StructuredText.Reader

class StructuredText:
    class Type(Enum):
        unstructured = "unstructured"
        json = "json"
        xml = "xml"
        toml = "toml"
        sturdyRef = "sturdyRef"

    StructureBuilder: TypeAlias = Structure.Builder
    StructureReader: TypeAlias = Structure.Reader
    class Structure:
        class Reader:
            @property
            def none(self) -> None: ...
            @property
            def json(self) -> None: ...
            @property
            def xml(self) -> None: ...
            @property
            def toml(self) -> None: ...
            def which(self) -> Literal["none", "json", "xml", "toml"]: ...
            def as_builder(self) -> StructuredText.Structure.Builder: ...

        class Builder:
            @property
            def none(self) -> None: ...
            @none.setter
            def none(self, value: None) -> None: ...
            @property
            def json(self) -> None: ...
            @json.setter
            def json(self, value: None) -> None: ...
            @property
            def xml(self) -> None: ...
            @xml.setter
            def xml(self, value: None) -> None: ...
            @property
            def toml(self) -> None: ...
            @toml.setter
            def toml(self, value: None) -> None: ...
            def which(self) -> Literal["none", "json", "xml", "toml"]: ...
            @staticmethod
            def from_dict(
                dictionary: dict[str, Any],
            ) -> StructuredText.Structure.Builder: ...
            def copy(self) -> StructuredText.Structure.Builder: ...
            def to_bytes(self) -> bytes: ...
            def to_bytes_packed(self) -> bytes: ...
            def to_segments(self) -> list[bytes]: ...
            def as_reader(self) -> StructuredText.Structure.Reader: ...
            @staticmethod
            def write(file: BufferedWriter) -> None: ...
            @staticmethod
            def write_packed(file: BufferedWriter) -> None: ...

        def which(self) -> Literal["none", "json", "xml", "toml"]: ...
        @contextmanager
        @staticmethod
        def from_bytes(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> Iterator[StructuredText.Structure.Reader]: ...
        @staticmethod
        def from_bytes_packed(
            data: bytes,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> StructuredText.Structure.Reader: ...
        @staticmethod
        def new_message(
            num_first_segment_words: int | None = None,
            allocate_seg_callable: Any = None,
            none: None | None = None,
            json: None | None = None,
            xml: None | None = None,
            toml: None | None = None,
        ) -> StructuredText.Structure.Builder: ...
        @staticmethod
        def read(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> StructuredText.Structure.Reader: ...
        @staticmethod
        def read_packed(
            file: BinaryIO,
            traversal_limit_in_words: int | None = ...,
            nesting_limit: int | None = ...,
        ) -> StructuredText.Structure.Reader: ...
        def to_dict(self) -> dict[str, Any]: ...

    class Reader:
        @property
        def value(self) -> str: ...
        @property
        def structure(self) -> StructuredText.Structure.Reader: ...
        @property
        def type(self) -> StructuredText.Type: ...
        def as_builder(self) -> StructuredText.Builder: ...

    class Builder:
        @property
        def value(self) -> str: ...
        @value.setter
        def value(self, value: str) -> None: ...
        @property
        def structure(self) -> StructuredText.Structure.Builder: ...
        @structure.setter
        def structure(
            self,
            value: StructuredText.Structure.Builder
            | StructuredText.Structure.Reader
            | dict[str, Any],
        ) -> None: ...
        @property
        def type(self) -> StructuredText.Type: ...
        @type.setter
        def type(
            self,
            value: StructuredText.Type
            | Literal["unstructured", "json", "xml", "toml", "sturdyRef"],
        ) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> StructuredText.Builder: ...
        def init(
            self, name: Literal["structure"]
        ) -> StructuredText.Structure.Builder: ...
        def copy(self) -> StructuredText.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> StructuredText.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    def init(self, name: Literal["structure"]) -> StructuredText.Structure: ...
    @contextmanager
    @staticmethod
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[StructuredText.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> StructuredText.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        value: str | None = None,
        structure: StructuredText.Structure.Builder | dict[str, Any] | None = None,
        type: StructuredText.Type
        | Literal["unstructured", "json", "xml", "toml", "sturdyRef"]
        | None = None,
    ) -> StructuredText.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> StructuredText.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> StructuredText.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

PairBuilder: TypeAlias = Pair.Builder
PairReader: TypeAlias = Pair.Reader

class Pair(Generic[Value_F, Value_S]):
    class Reader:
        @property
        def fst(self) -> Value_F: ...
        @property
        def snd(self) -> Value_S: ...
        def as_builder(self) -> Pair.Builder: ...

    class Builder:
        @property
        def fst(self) -> Value_F: ...
        @fst.setter
        def fst(self, value: Value_F) -> None: ...
        @property
        def snd(self) -> Value_S: ...
        @snd.setter
        def snd(self, value: Value_S) -> None: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Pair.Builder: ...
        def copy(self) -> Pair.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Pair.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    @contextmanager
    @staticmethod
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[Pair.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Pair.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        fst: Value_F | None = None,
        snd: Value_S | None = None,
    ) -> Pair.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Pair.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Pair.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

ValueBuilder: TypeAlias = Value.Builder
ValueReader: TypeAlias = Value.Reader

class Value:
    class Reader:
        @property
        def f64(self) -> float: ...
        @property
        def f32(self) -> float: ...
        @property
        def i64(self) -> int: ...
        @property
        def i32(self) -> int: ...
        @property
        def i16(self) -> int: ...
        @property
        def i8(self) -> int: ...
        @property
        def ui64(self) -> int: ...
        @property
        def ui32(self) -> int: ...
        @property
        def ui16(self) -> int: ...
        @property
        def ui8(self) -> int: ...
        @property
        def b(self) -> bool: ...
        @property
        def t(self) -> str: ...
        @property
        def d(self) -> bytes: ...
        @property
        def p(self) -> Any: ...
        @property
        def cap(self) -> Any: ...
        @property
        def lf64(self) -> Sequence[float]: ...
        @property
        def lf32(self) -> Sequence[float]: ...
        @property
        def li64(self) -> Sequence[int]: ...
        @property
        def li32(self) -> Sequence[int]: ...
        @property
        def li16(self) -> Sequence[int]: ...
        @property
        def li8(self) -> Sequence[int]: ...
        @property
        def lui64(self) -> Sequence[int]: ...
        @property
        def lui32(self) -> Sequence[int]: ...
        @property
        def lui16(self) -> Sequence[int]: ...
        @property
        def lui8(self) -> Sequence[int]: ...
        @property
        def lb(self) -> Sequence[bool]: ...
        @property
        def lt(self) -> Sequence[str]: ...
        @property
        def ld(self) -> Sequence[bytes]: ...
        @property
        def lcap(self) -> Sequence[Any]: ...
        @property
        def lpair(self) -> Sequence[Pair.Reader]: ...
        def which(
            self,
        ) -> Literal[
            "f64",
            "f32",
            "i64",
            "i32",
            "i16",
            "i8",
            "ui64",
            "ui32",
            "ui16",
            "ui8",
            "b",
            "t",
            "d",
            "p",
            "cap",
            "lf64",
            "lf32",
            "li64",
            "li32",
            "li16",
            "li8",
            "lui64",
            "lui32",
            "lui16",
            "lui8",
            "lb",
            "lt",
            "ld",
            "lcap",
            "lpair",
        ]: ...
        def as_builder(self) -> Value.Builder: ...

    class Builder:
        @property
        def f64(self) -> float: ...
        @f64.setter
        def f64(self, value: float) -> None: ...
        @property
        def f32(self) -> float: ...
        @f32.setter
        def f32(self, value: float) -> None: ...
        @property
        def i64(self) -> int: ...
        @i64.setter
        def i64(self, value: int) -> None: ...
        @property
        def i32(self) -> int: ...
        @i32.setter
        def i32(self, value: int) -> None: ...
        @property
        def i16(self) -> int: ...
        @i16.setter
        def i16(self, value: int) -> None: ...
        @property
        def i8(self) -> int: ...
        @i8.setter
        def i8(self, value: int) -> None: ...
        @property
        def ui64(self) -> int: ...
        @ui64.setter
        def ui64(self, value: int) -> None: ...
        @property
        def ui32(self) -> int: ...
        @ui32.setter
        def ui32(self, value: int) -> None: ...
        @property
        def ui16(self) -> int: ...
        @ui16.setter
        def ui16(self, value: int) -> None: ...
        @property
        def ui8(self) -> int: ...
        @ui8.setter
        def ui8(self, value: int) -> None: ...
        @property
        def b(self) -> bool: ...
        @b.setter
        def b(self, value: bool) -> None: ...
        @property
        def t(self) -> str: ...
        @t.setter
        def t(self, value: str) -> None: ...
        @property
        def d(self) -> bytes: ...
        @d.setter
        def d(self, value: bytes) -> None: ...
        @property
        def p(self) -> Any: ...
        @p.setter
        def p(self, value: Any) -> None: ...
        @property
        def cap(self) -> Any: ...
        @cap.setter
        def cap(self, value: Any) -> None: ...
        @property
        def lf64(self) -> Sequence[float]: ...
        @lf64.setter
        def lf64(self, value: Sequence[float]) -> None: ...
        @property
        def lf32(self) -> Sequence[float]: ...
        @lf32.setter
        def lf32(self, value: Sequence[float]) -> None: ...
        @property
        def li64(self) -> Sequence[int]: ...
        @li64.setter
        def li64(self, value: Sequence[int]) -> None: ...
        @property
        def li32(self) -> Sequence[int]: ...
        @li32.setter
        def li32(self, value: Sequence[int]) -> None: ...
        @property
        def li16(self) -> Sequence[int]: ...
        @li16.setter
        def li16(self, value: Sequence[int]) -> None: ...
        @property
        def li8(self) -> Sequence[int]: ...
        @li8.setter
        def li8(self, value: Sequence[int]) -> None: ...
        @property
        def lui64(self) -> Sequence[int]: ...
        @lui64.setter
        def lui64(self, value: Sequence[int]) -> None: ...
        @property
        def lui32(self) -> Sequence[int]: ...
        @lui32.setter
        def lui32(self, value: Sequence[int]) -> None: ...
        @property
        def lui16(self) -> Sequence[int]: ...
        @lui16.setter
        def lui16(self, value: Sequence[int]) -> None: ...
        @property
        def lui8(self) -> Sequence[int]: ...
        @lui8.setter
        def lui8(self, value: Sequence[int]) -> None: ...
        @property
        def lb(self) -> Sequence[bool]: ...
        @lb.setter
        def lb(self, value: Sequence[bool]) -> None: ...
        @property
        def lt(self) -> Sequence[str]: ...
        @lt.setter
        def lt(self, value: Sequence[str]) -> None: ...
        @property
        def ld(self) -> Sequence[bytes]: ...
        @ld.setter
        def ld(self, value: Sequence[bytes]) -> None: ...
        @property
        def lcap(self) -> Sequence[Any]: ...
        @lcap.setter
        def lcap(self, value: Sequence[Any]) -> None: ...
        @property
        def lpair(self) -> Sequence[Pair.Builder]: ...
        @lpair.setter
        def lpair(
            self, value: Sequence[Pair.Builder | Pair.Reader] | Sequence[dict[str, Any]]
        ) -> None: ...
        def which(
            self,
        ) -> Literal[
            "f64",
            "f32",
            "i64",
            "i32",
            "i16",
            "i8",
            "ui64",
            "ui32",
            "ui16",
            "ui8",
            "b",
            "t",
            "d",
            "p",
            "cap",
            "lf64",
            "lf32",
            "li64",
            "li32",
            "li16",
            "li8",
            "lui64",
            "lui32",
            "lui16",
            "lui8",
            "lb",
            "lt",
            "ld",
            "lcap",
            "lpair",
        ]: ...
        @staticmethod
        def from_dict(dictionary: dict[str, Any]) -> Value.Builder: ...
        @overload
        def init(
            self: Any, name: Literal["lf64"], size: int = ...
        ) -> Sequence[float]: ...
        @overload
        def init(
            self: Any, name: Literal["lf32"], size: int = ...
        ) -> Sequence[float]: ...
        @overload
        def init(
            self: Any, name: Literal["li64"], size: int = ...
        ) -> Sequence[int]: ...
        @overload
        def init(
            self: Any, name: Literal["li32"], size: int = ...
        ) -> Sequence[int]: ...
        @overload
        def init(
            self: Any, name: Literal["li16"], size: int = ...
        ) -> Sequence[int]: ...
        @overload
        def init(self: Any, name: Literal["li8"], size: int = ...) -> Sequence[int]: ...
        @overload
        def init(
            self: Any, name: Literal["lui64"], size: int = ...
        ) -> Sequence[int]: ...
        @overload
        def init(
            self: Any, name: Literal["lui32"], size: int = ...
        ) -> Sequence[int]: ...
        @overload
        def init(
            self: Any, name: Literal["lui16"], size: int = ...
        ) -> Sequence[int]: ...
        @overload
        def init(
            self: Any, name: Literal["lui8"], size: int = ...
        ) -> Sequence[int]: ...
        @overload
        def init(self: Any, name: Literal["lb"], size: int = ...) -> Sequence[bool]: ...
        @overload
        def init(self: Any, name: Literal["lt"], size: int = ...) -> Sequence[str]: ...
        @overload
        def init(
            self: Any, name: Literal["ld"], size: int = ...
        ) -> Sequence[bytes]: ...
        @overload
        def init(
            self: Any, name: Literal["lcap"], size: int = ...
        ) -> Sequence[Any]: ...
        @overload
        def init(
            self: Any, name: Literal["lpair"], size: int = ...
        ) -> Sequence[Pair.Builder]: ...
        def init(self: Any, name: str, size: int = ...) -> Any: ...
        def copy(self) -> Value.Builder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> Value.Reader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...

    def which(
        self,
    ) -> Literal[
        "f64",
        "f32",
        "i64",
        "i32",
        "i16",
        "i8",
        "ui64",
        "ui32",
        "ui16",
        "ui8",
        "b",
        "t",
        "d",
        "p",
        "cap",
        "lf64",
        "lf32",
        "li64",
        "li32",
        "li16",
        "li8",
        "lui64",
        "lui32",
        "lui16",
        "lui8",
        "lb",
        "lt",
        "ld",
        "lcap",
        "lpair",
    ]: ...
    @contextmanager
    @staticmethod
    def from_bytes(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Iterator[Value.Reader]: ...
    @staticmethod
    def from_bytes_packed(
        data: bytes,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Value.Reader: ...
    @staticmethod
    def new_message(
        num_first_segment_words: int | None = None,
        allocate_seg_callable: Any = None,
        f64: float | None = None,
        f32: float | None = None,
        i64: int | None = None,
        i32: int | None = None,
        i16: int | None = None,
        i8: int | None = None,
        ui64: int | None = None,
        ui32: int | None = None,
        ui16: int | None = None,
        ui8: int | None = None,
        b: bool | None = None,
        t: str | None = None,
        d: bytes | None = None,
        p: Any | None = None,
        cap: Any | None = None,
        lf64: Sequence[float] | None = None,
        lf32: Sequence[float] | None = None,
        li64: Sequence[int] | None = None,
        li32: Sequence[int] | None = None,
        li16: Sequence[int] | None = None,
        li8: Sequence[int] | None = None,
        lui64: Sequence[int] | None = None,
        lui32: Sequence[int] | None = None,
        lui16: Sequence[int] | None = None,
        lui8: Sequence[int] | None = None,
        lb: Sequence[bool] | None = None,
        lt: Sequence[str] | None = None,
        ld: Sequence[bytes] | None = None,
        lcap: Sequence[Any] | None = None,
        lpair: Sequence[Pair.Builder] | Sequence[dict[str, Any]] | None = None,
    ) -> Value.Builder: ...
    @staticmethod
    def read(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Value.Reader: ...
    @staticmethod
    def read_packed(
        file: BinaryIO,
        traversal_limit_in_words: int | None = ...,
        nesting_limit: int | None = ...,
    ) -> Value.Reader: ...
    def to_dict(self) -> dict[str, Any]: ...

class Holder:
    class ValueRequest(Protocol):
        def send(self) -> Holder.ValueResult: ...

    class ValueResult(Awaitable[ValueResult], Protocol):
        value: Any

    @classmethod
    def _new_client(cls, server: Holder.Server) -> HolderClient: ...
    class Server(Protocol):
        class ValueResultTuple(NamedTuple):
            value: Any

        class ValueCallContext(Protocol):
            params: Holder.ValueRequest
            results: Holder.ValueResult

        def value(
            self, _context: Holder.Server.ValueCallContext, **kwargs: Any
        ) -> Awaitable[Holder.Server.ValueResultTuple | None]: ...
        def value_context(
            self, context: Holder.Server.ValueCallContext
        ) -> Awaitable[None]: ...

class HolderClient(Protocol):
    def value(self) -> Holder.ValueResult: ...
    def value_request(self) -> Holder.ValueRequest: ...

class IdentifiableHolder:
    @classmethod
    def _new_client(
        cls, server: IdentifiableHolder.Server | Holder.Server | Identifiable.Server
    ) -> IdentifiableHolderClient: ...
    class Server(Identifiable.Server, Holder.Server): ...

class IdentifiableHolderClient(IdentifiableClient, HolderClient): ...
